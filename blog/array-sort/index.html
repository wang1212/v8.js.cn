<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Getting things sorted in V8 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Starting with V8 v7.0 / Chrome 70, Array.prototype.sort is stable." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Getting things sorted in V8</h1><p class=meta>发布时间 <time datetime="2018-09-28 11:20:37" itemprop=datePublished title="2018-09-28 11:20:37">2018-09-28</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a> <a href=/blog/tags/internals/ class=tag>internals</a></header><div itemprop=articleBody><p><code>Array.prototype.sort</code> was among the last builtins implemented in self-hosted JavaScript in V8. Porting it offered us the opportunity to experiment with different algorithms and implementation strategies and finally <a href=https://mathiasbynens.be/demo/sort-stability>make it stable</a> in V8 v7.0 / Chrome 70.<h2 id=background>Background <a href=#background class=bookmark>#</a></h2><p>Sorting in JavaScript is hard. This blog post looks at some of the quirks in the interaction between a sorting algorithm and the JavaScript language, and describes our journey to move V8 to a stable algorithm and make performance more predictable.<p>When comparing different sorting algorithms we look at their worst and average performance given as a bound on the asymptotic growth (i.e. “Big O” notation) of either memory operations or number of comparisons. Note that in dynamic languages, such as JavaScript, a comparison operation is usually a magnitude more expensive than a memory access. This is due to the fact that comparing two values while sorting usually involves calls to user code.<p>Let’s take a look at a simple example of sorting some numbers into ascending order based on a user-provided comparison function. A <em>consistent</em> comparison function returns <code>-1</code> (or any other negative value), <code>0</code>, or <code>1</code> (or any other positive value) when the two provided values are either smaller, equal, or greater respectively. A comparison function that does not follow this pattern is <em>inconsistent</em> and can have arbitrary side-effects, such as modifying the array it’s intended to sort.<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br><span class="token keyword">function</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// Arbitrary code goes here, e.g. `array.push(1);`.</span><br>  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// A “typical” sort call.</span><br>array<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>compare<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Even in the next example, calls to user code may happen. The “default” comparison function calls <code>toString</code> on both values and does a lexicographical comparison on the string representations.<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Arbitrary code goes here, e.g. `array.push(1);`.</span><br>    <span class="token keyword">return</span> <span class="token string">'42'</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Sort without a comparison function.</span><br>array<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id=accessors-prototype>More fun with accessors and prototype-chain interactions <a href=#accessors-prototype class=bookmark>#</a></h3><p>This is the part where we leave the spec behind and venture into “implementation-defined” behavior land. The spec has a whole list of conditions that, when met, allow the engine to sort the object/array as it sees fit — or not at all. Engines still have to follow some ground rules but everything else is pretty much up in the air. On the one hand, this gives engine developers the freedom to experiment with different implementations. On the other hand, users expect some reasonable behavior even though the spec doesn’t require there to be any. This is further complicated by the fact that “reasonable behavior” is not always straightforward to determine.<p>This section shows that there are still some aspects of <code>Array#sort</code> where engine behavior differs greatly. These are hard edge cases, and as mentioned above it’s not always clear what “the right thing to do” actually is. We <em>highly</em> recommend not writing code like this; engines won’t optimize for it.<p>The first example shows an array with some accessors (i.e. getters and setters) and a “call log” in different JavaScript engines. Accessors are the first case where the resulting sort order is implementation-defined:<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get 0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set 0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>array<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Here’s the output of that snippet in various engines. Note that there are no “right” or “wrong” answers here — the spec leaves this up to the implementation!<pre><code>// Chakra
get 0
get 1
set 0
set 1

// JavaScriptCore
get 0
get 1
get 0
get 0
get 1
get 1
set 0
set 1

// V8
get 0
get 0
get 1
get 1
get 1
get 0

#### SpiderMonkey
get 0
get 1
set 0
set 1
</code></pre><p>The next example shows interactions with the prototype chain. For the sake of brevity we don’t show the call log.<pre class=language-js><code class=language-js><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span><br> <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'d1'</span><span class="token punctuation">,</span><br> <span class="token number">2</span><span class="token operator">:</span> <span class="token string">'c1'</span><span class="token punctuation">,</span><br> <span class="token number">3</span><span class="token operator">:</span> <span class="token string">'b1'</span><span class="token punctuation">,</span><br> <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span><br> __proto__<span class="token operator">:</span> <span class="token punctuation">{</span><br>   length<span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span><br>   <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'e2'</span><span class="token punctuation">,</span><br>   <span class="token number">10</span><span class="token operator">:</span> <span class="token string">'a2'</span><span class="token punctuation">,</span><br>   <span class="token number">100</span><span class="token operator">:</span> <span class="token string">'b2'</span><span class="token punctuation">,</span><br>   <span class="token number">1000</span><span class="token operator">:</span> <span class="token string">'c2'</span><span class="token punctuation">,</span><br>   <span class="token number">2000</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span><br>   <span class="token number">8000</span><span class="token operator">:</span> <span class="token string">'d2'</span><span class="token punctuation">,</span><br>   <span class="token number">12000</span><span class="token operator">:</span> <span class="token string">'XX'</span><span class="token punctuation">,</span><br>   __proto__<span class="token operator">:</span> <span class="token punctuation">{</span><br>     <span class="token number">0</span><span class="token operator">:</span> <span class="token string">'e3'</span><span class="token punctuation">,</span><br>     <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'d3'</span><span class="token punctuation">,</span><br>     <span class="token number">2</span><span class="token operator">:</span> <span class="token string">'c3'</span><span class="token punctuation">,</span><br>     <span class="token number">3</span><span class="token operator">:</span> <span class="token string">'b3'</span><span class="token punctuation">,</span><br>     <span class="token number">4</span><span class="token operator">:</span> <span class="token string">'f3'</span><span class="token punctuation">,</span><br>     <span class="token number">5</span><span class="token operator">:</span> <span class="token string">'a3'</span><span class="token punctuation">,</span><br>     <span class="token number">6</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span><br>   <span class="token punctuation">}</span><span class="token punctuation">,</span><br> <span class="token punctuation">}</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The output shows the <code>object</code> after it’s sorted. Again, there is no right answer here. This example just shows how weird the interaction between indexed properties and the prototype chain can get:<pre class=language-js><code class=language-js><span class="token comment">// Chakra</span><br><span class="token punctuation">[</span><span class="token string">'a2'</span><span class="token punctuation">,</span> <span class="token string">'a3'</span><span class="token punctuation">,</span> <span class="token string">'b1'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'c1'</span><span class="token punctuation">,</span> <span class="token string">'c2'</span><span class="token punctuation">,</span> <span class="token string">'d1'</span><span class="token punctuation">,</span> <span class="token string">'d2'</span><span class="token punctuation">,</span> <span class="token string">'e3'</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span><br><br><span class="token comment">// JavaScriptCore</span><br><span class="token punctuation">[</span><span class="token string">'a2'</span><span class="token punctuation">,</span> <span class="token string">'a2'</span><span class="token punctuation">,</span> <span class="token string">'a3'</span><span class="token punctuation">,</span> <span class="token string">'b1'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'c1'</span><span class="token punctuation">,</span> <span class="token string">'c2'</span><span class="token punctuation">,</span> <span class="token string">'d1'</span><span class="token punctuation">,</span> <span class="token string">'d2'</span><span class="token punctuation">,</span> <span class="token string">'e3'</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span><br><br><span class="token comment">// V8</span><br><span class="token punctuation">[</span><span class="token string">'a2'</span><span class="token punctuation">,</span> <span class="token string">'a3'</span><span class="token punctuation">,</span> <span class="token string">'b1'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'c1'</span><span class="token punctuation">,</span> <span class="token string">'c2'</span><span class="token punctuation">,</span> <span class="token string">'d1'</span><span class="token punctuation">,</span> <span class="token string">'d2'</span><span class="token punctuation">,</span> <span class="token string">'e3'</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span><br><br><span class="token comment">// SpiderMonkey</span><br><span class="token punctuation">[</span><span class="token string">'a2'</span><span class="token punctuation">,</span> <span class="token string">'a3'</span><span class="token punctuation">,</span> <span class="token string">'b1'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'c1'</span><span class="token punctuation">,</span> <span class="token string">'c2'</span><span class="token punctuation">,</span> <span class="token string">'d1'</span><span class="token punctuation">,</span> <span class="token string">'d2'</span><span class="token punctuation">,</span> <span class="token string">'e3'</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span></code></pre><h3 id=before-sort>What V8 does before and after sorting <a href=#before-sort class=bookmark>#</a></h3><div class=note><p><strong>Note:</strong> This section was updated in June 2019 to reflect changes to <code>Array#sort</code> pre- and post-processing in V8 v7.7.</div><p>V8 has one pre-processing step before it actually sorts anything and also one post-processing step. The basic idea is to collect all non-<code>undefined</code> values into a temporary list, sort this temporary list and then write the sorted values back into the actual array or object. This frees V8 from caring about interacting with accessors or the prototype chain during the sorting itself.<p>The spec expects <code>Array#sort</code> to produce a sort-order that can conceptually be partitioned into three segments:<ol><li>All non-<code>undefined</code> values sorted w.r.t. to the comparison function.<li>All <code>undefined</code>s.<li>All holes, i.e. non-existing properties.</ol><p>The actual sorting algorithm only needs to be applied to the first segment. To achieve this, V8 has a pre-processing step works roughly as follows:<ol><li>Let <code>length</code> be the value of the <code>”length”</code> property of the array or object to sort.<li>Let <code>numberOfUndefineds</code> be 0.<li>For each <code>value</code> in the range of <code>[0, length)</code>:<br>a. If <code>value</code> is a hole: do nothing<br>b. If <code>value</code> is <code>undefined</code>: increment <code>numberOfUndefineds</code> by 1.<br>c. Otherwise add <code>value</code> to a temporary list <code>elements</code>.</ol><p>After these steps are executed, all non-<code>undefined</code> values are contained in the temporary list <code>elements</code>. <code>undefined</code>s are simply counted, instead of added to <code>elements</code>. As mentioned above, the spec requires that <code>undefined</code>s must be sorted to the end. Except, <code>undefined</code> values are not actually passed to the user-provided comparison function, so we can get away with only counting the number of <code>undefined</code>s that occurred.<p>The next step is to actually sort <code>elements</code>. See <a href=/blog/array-sort#timsort>the section about TimSort</a> for a detailed description.<p>After sorting is done, the sorted values have to be written back to the original array or object. The post-processing step consists of three phases that handle the conceptual segments:<ol><li>Write back all values from <code>elements</code> to the original object in the range of <code>[0, elements.length)</code>.<li>Set all values from <code>[elements.length, elements.length + numberOfUndefineds)</code> to <code>undefined</code>.<li>Delete all values in the range from <code>[elements.length + numberOfUndefineds, length)</code>.</ol><p>Step 3 is needed in case the original object contained holes in the sorting range. Values in the range of <code>[elements.length + numberOfUndefineds, length)</code> have already been moved to the front and not performing step 3 would result in duplicate values.<h2 id=history>History <a href=#history class=bookmark>#</a></h2><p><code>Array.prototype.sort</code> and <code>TypedArray.prototype.sort</code> relied on the same Quicksort implementation written in JavaScript. The sorting algorithm itself is rather straightforward: The basis is a Quicksort with an Insertion Sort fall-back for shorter arrays (length &lt; 10). The Insertion Sort fall-back was also used when Quicksort recursion reached a sub-array length of 10. Insertion Sort is more efficient for smaller arrays. This is because Quicksort gets called recursively twice after partitioning. Each such recursive call had the overhead of creating (and discarding) a stack frame.<p>Choosing a suitable pivot element has a big impact when it comes to Quicksort. V8 employed two strategies:<ul><li>The pivot was chosen as the median of the first, last, and a third element of the sub-array that gets sorted. For smaller arrays that third element is simply the middle element.<li>For larger arrays a sample was taken, then sorted and the median of the sorted sample served as the third element in the above calculation.</ul><p>One of the advantages of Quicksort is that it sorts in-place. The memory overhead comes from allocating a small array for the sample when sorting large arrays, and log(n) stack space. The downside is that it’s not a stable algorithm and there’s a chance the algorithm hits the worst-case scenario where QuickSort degrades to 𝒪(n²).<h3 id=introducing-v8-torque>Introducing V8 Torque <a href=#introducing-v8-torque class=bookmark>#</a></h3><p>As an avid reader of the V8 blog you might have heard of <a href=/blog/csa><code>CodeStubAssembler</code></a> or CSA for short. CSA is a V8 component that allows us to write low-level TurboFan IR directly in C++ that later gets translated to machine code for the appropriate architecture using TurboFan’s backend.<p>CSA is heavily utilized to write so-called “fast-paths” for JavaScript builtins. A fast-path version of a builtin usually checks whether certain invariants hold (e.g. no elements on the prototype chain, no accessors, etc) and then uses faster, more specific operations to implement the builtin functionality. This can result in execution times that are an order of magnitude faster than a more generic version.<p>The downside of CSA is that it really can be considered an assembly language. Control-flow is modeled using explicit <code>labels</code> and <code>gotos</code>, which makes implementing more complex algorithms in CSA hard to read and error-prone.<p>Enter <a href=/docs/torque>V8 Torque</a>. Torque is a domain-specific language with TypeScript-like syntax that currently uses CSA as its sole compilation target. Torque allows nearly the same level of control as CSA does while at the same time offering higher-level constructs such as <code>while</code> and <code>for</code> loops. Additionally, it’s strongly typed and will in the future contain security checks such as automatic out-of-bound checks providing V8 engineers with stronger guarantees.<p>The first major builtins that were re-written in V8 Torque were <a href=/blog/v8-release-68><code>TypedArray#sort</code></a> and <a href=/blog/dataview><code>Dataview</code> operations</a>. Both served the additional purpose of providing feedback to the Torque developers on what languages features are needed and idioms should be used to write builtins efficiently. At the time of writing, several <code>JSArray</code> builtins had their self-hosted JavaScript fall-back implementations moved to Torque (e.g. <code>Array#unshift</code>) while others were completely re-written (e.g. <code>Array#splice</code> and <code>Array#reverse</code>).<h3 id=moving-array%23sort-to-torque>Moving <code>Array#sort</code> to Torque <a href=#moving-array%23sort-to-torque class=bookmark>#</a></h3><p>The initial <code>Array#sort</code> Torque version was more or less a straight up port of the JavaScript implementation. The only difference was that instead of using a sampling approach for larger arrays, the third element for the pivot calculation was chosen at random.<p>This worked reasonably well, but as it still utilized Quicksort, <code>Array#sort</code> remained unstable. <a href="https://bugs.chromium.org/p/v8/issues/detail?id=90">The request for a stable <code>Array#sort</code></a> is among the oldest tickets in V8’s bug tracker. Experimenting with Timsort as a next step offered us multiple things. First, we like that it’s stable and offers some nice algorithmic guarantees (see next section). Second, Torque was still a work-in-progress and implementing a more complex builtin such as <code>Array#sort</code> with Timsort resulted in lots of actionable feedback influencing Torque as a language.<h2 id=timsort>Timsort <a href=#timsort class=bookmark>#</a></h2><p>Timsort, initially developed by Tim Peters for Python in 2002, could best be described as an adaptive stable Mergesort variant. Even though the details are rather complex and are best described by <a href=https://github.com/python/cpython/blob/master/Objects/listsort.txt>the man himself</a> or the <a href=https://en.wikipedia.org/wiki/Timsort>Wikipedia page</a>, the basics are easy to understand. While Mergesort usually works in recursive fashion, Timsort works iteratively. It processes an array from left to right and looks for so-called <em>runs</em>. A run is simply a sequence that is already sorted. This includes sequences that are sorted “the wrong way” as these sequences can simply be reversed to form a run. At the start of the sorting process a minimum run length is determined that depends on the length of the input. If Timsort can’t find natural runs of this minimum run length a run is “boosted artificially” using Insertion Sort.<p>Runs that are found this way are tracked using a stack that remembers a starting index and a length of each run. From time to time runs on the stack are merged together until only one sorted run remains. Timsort tries to maintain a balance when it comes to deciding which runs to merge. On the one hand you want to try and merge early as the data of those runs has a high chance of already being in the cache, on the other hand you want to merge as late as possible to take advantage of patterns in the data that might emerge. To accomplish this, Timsort maintains two invariants. Assuming <code>A</code>, <code>B</code>, and <code>C</code> are the three top-most runs:<ul><li><code>|C| > |B| + |A|</code><li><code>|B| > |A|</code></ul><figure><img alt="" height=427 loading=lazy src=/_img/array-sort/runs-stack.svg width=770><figcaption>Runs stack before and after merging <code>A</code> with <code>B</code></figcaption></figure><p>The image shows the case where <code>|A| > |B|</code> so <code>B</code> is merged with the smaller of the two runs.<p>Note that Timsort only merges consecutive runs, this is needed to maintain stability, otherwise equal elements would be transferred between runs. Also the first invariant makes sure that run lengths grow at least as fast as the Fibonacci numbers, giving an upper bound on the size of the run stack when we know the maximum array length.<p>One can now see that already-sorted sequences are sorted in 𝒪(n) as such an array would result in a single run that does not need to get merged. The worst case is 𝒪(n log n). These algorithmic properties together with the stable nature of Timsort were a few of the reasons why we chose Timsort over Quicksort in the end.<h3 id=implementing-timsort-in-torque>Implementing Timsort in Torque <a href=#implementing-timsort-in-torque class=bookmark>#</a></h3><p>Builtins usually have different code-paths that are chosen during runtime depending on various variables. The most generic version can handle any kind of object, regardless if its a <code>JSProxy</code>, has interceptors or needs to do prototype chain lookups when retrieving or setting properties.<br>The generic path is rather slow in most cases, as it needs to account for all eventualities. But if we know upfront that the object to sort is a simple <code>JSArray</code> containing only Smis, all these expensive <code>[[Get]]</code> and <code>[[Set]]</code> operations can be replaced by simple Loads and Stores to a <code>FixedArray</code>. The main differentiator is the <a href=/blog/elements-kinds><code>ElementsKind</code></a>.<p>The problem now becomes how to implement a fast-path. The core algorithm stays the same for all but the way we access elements changes based on the <code>ElementsKind</code>. One way we could accomplish this is to dispatch to the correct “accessor” on each call-site. Imagine a switch for each “load”/”store” operation where we choose a different branch based on the chosen fast-path.<p>Another solution (and this was the first approach tried) is to just copy the whole builtin once for each fast-path and inline the correct load/store access method. This approach turned out to be infeasible for Timsort as it’s a big builtin and making a copy for each fast-path turned out to require 106 KB in total, which is way too much for a single builtin.<p>The final solution is slightly different. Each load/store operation for each fast-path is put into its own “mini-builtin”. See the code example which shows the “load” operation for <code>FixedDoubleArray</code>s.<pre class=language-torque><code class=language-torque>Load<span class="token operator">&lt;</span>FastDoubleElements<span class="token operator">></span><span class="token punctuation">(</span><br>    context<span class="token class-name">: Context,</span> sortState<span class="token class-name">: FixedArray,</span> elements<span class="token class-name">: HeapObject,</span><br>    index<span class="token class-name">: Smi)</span><span class="token class-name">: Object {</span><br>  <span class="token keyword">try</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> elems<span class="token class-name">: FixedDoubleArray =</span> <span class="token builtin">UnsafeCast</span><span class="token operator">&lt;</span>FixedDoubleArray<span class="token operator">></span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">const</span> value<span class="token class-name">: float64 =</span><br>        LoadDoubleWithHoleCheck<span class="token punctuation">(</span>elems<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token keyword">otherwise</span> Bailout<span class="token punctuation">;</span><br>    <span class="token keyword">return</span> AllocateHeapNumberWithValue<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">label</span> Bailout <span class="token punctuation">{</span><br>    <span class="token comment">// The pre-processing step removed all holes by compacting all elements</span><br>    <span class="token comment">// at the start of the array. Finding a hole means the cmp function or</span><br>    <span class="token comment">// ToString changes the array.</span><br>    <span class="token keyword">return</span> Failure<span class="token punctuation">(</span>sortState<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>To compare, the most generic “load” operation is simply a call to <code>GetProperty</code>. But while the above version generates efficient and fast machine code to load and convert a <code>Number</code>, <code>GetProperty</code> is a call to another builtin that could potentially involve a prototype chain lookup or invoke an accessor function.<pre class=language-js><code class=language-js>builtin Load<span class="token operator">&lt;</span>ElementsAccessor <span class="token operator">:</span> type<span class="token operator">></span><span class="token punctuation">(</span><br>    context<span class="token operator">:</span> Context<span class="token punctuation">,</span> sortState<span class="token operator">:</span> FixedArray<span class="token punctuation">,</span> elements<span class="token operator">:</span> HeapObject<span class="token punctuation">,</span><br>    index<span class="token operator">:</span> Smi<span class="token punctuation">)</span><span class="token operator">:</span> Object <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token function">GetProperty</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> elements<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>A fast-path then simply becomes a set of function pointers. This means we only need one copy of the core algorithm while setting up all relevant function pointers once upfront. While this greatly reduces the needed code space (down to 20k) it comes at the cost of an indirect branch at each access site. This is even exacerbated by the recent change to use <a href=/blog/embedded-builtins>embedded builtins</a>.<h3 id=sort-state>Sort state <a href=#sort-state class=bookmark>#</a></h3><figure><img alt="" height=710 loading=lazy src=/_img/array-sort/sort-state.svg width=570></figure><p>The picture above shows the “sort state”. It’s a <code>FixedArray</code> that keeps track of all the things needed while sorting. Each time <code>Array#sort</code> is called, such a sort state is allocated. Entry 4 to 7 are the set of function pointers discussed above that comprise a fast-path.<p>The “check” builtin is used every time we return from user JavaScript code, to check if we can continue on the current fast-path. It uses the “initial receiver map” and “initial receiver length” for this. Should the user code have modified the current object, we simply abandon the sorting run, reset all pointers to their most generic version and restart the sorting process. The “bailout status” in slot 8 is used to signal this reset.<p>The “compare” entry can point to two different builtins. One calls a user-provided comparison function while the other implements the default comparison that calls <code>toString</code> on both arguments and then does a lexicographical comparison.<p>The rest of the fields (with the exception of the fast path ID) are Timsort-specific. The run stack (described above) is initialized with a size of 85 which is enough to sort arrays of length 2<sup>64</sup>. The temporary array is used for merging runs. It grows in size as needed but never exceeds <code>n/2</code> where <code>n</code> is the input length.<h3 id=performance-trade-offs>Performance trade-offs <a href=#performance-trade-offs class=bookmark>#</a></h3><p>Moving sorting from self-hosted JavaScript to Torque comes with performance trade-offs. As <code>Array#sort</code> is written in Torque, it’s now a statically compiled piece of code, meaning we still can build fast-paths for certain <a href=/blog/elements-kinds><code>ElementsKind</code>s</a> but it will never be as fast as a highly optimized TurboFan version that can utilize type feedback. On the other hand, in cases where the code doesn’t get hot enough to warrant JIT compilation or the call-site is megamorphic, we are stuck with the interpreter or a slow/generic version. The parsing, compiling and possible optimizing of the self-hosted JavaScript version is also an overhead that is not needed with the Torque implementation.<p>While the Torque approach doesn’t result in the same peak performance for sorting, it does avoid performance cliffs. The result is a sorting performance that is much more predictable than it previously was. Keep in mind that Torque is very much in flux and in addition of targeting CSA it might target TurboFan in the future, allowing JIT compilation of code written in Torque.<h3 id=microbenchmarks>Microbenchmarks <a href=#microbenchmarks class=bookmark>#</a></h3><p>Before we started with <code>Array#sort</code>, we added a lot of different micro-benchmarks to get a better understanding of the impact the re-implementation would have. The first chart shows the “normal” use case of sorting various ElementsKinds with a user-provided comparison function.<p>Keep in mind that in these cases the JIT compiler can do a lot of work, since sorting is nearly all we do. This also allows the optimizing compiler to inline the comparison function in the JavaScript version, while we have the call overhead from the builtin to JavaScript in the Torque case. Still, we perform better in nearly all cases.<figure><img alt="" height=371 loading=lazy src=/_img/array-sort/micro-bench-basic.svg width=616></figure><p>The next chart shows the impact of Timsort when processing arrays that are already sorted completely, or have sub-sequences that are already sorted one-way or another. The chart uses Quicksort as a baseline and shows the speedup of Timsort (up to 17× in the case of “DownDown” where the array consists of two reverse-sorted sequences). As can be seen, except in the case of random data, Timsort performs better in all other cases, even though we are sorting <code>PACKED_SMI_ELEMENTS</code>, where Quicksort outperformed Timsort in the microbenchmark above.<figure><img alt="" height=371 loading=lazy src=/_img/array-sort/micro-bench-presorted.svg width=600></figure><h3 id=web-tooling-benchmark>Web Tooling Benchmark <a href=#web-tooling-benchmark class=bookmark>#</a></h3><p>The <a href=https://github.com/v8/web-tooling-benchmark>Web Tooling Benchmark</a> is a collection of workloads of tools usually used by web developers such as Babel and TypeScript. The chart uses JavaScript Quicksort as a baseline and compares the speedup of Timsort against it. In almost all benchmarks we retain the same performance with the exception of chai.<figure><img alt="" height=612 loading=lazy src=/_img/array-sort/web-tooling-benchmark.svg width=990></figure><p>The chai benchmark spends <em>a third</em> of its time inside a single comparison function (a string distance calculation). The benchmark is the test suite of chai itself. Due to the data, Timsort needs some more comparisons in this case, which has a bigger impact on the overall runtime, as such a big portion of time is spent inside that particular comparison function.<h3 id=memory-impact>Memory impact <a href=#memory-impact class=bookmark>#</a></h3><p>Analyzing V8 heap snapshots while browsing some 50 sites (both on mobile as well as on desktop) didn’t show any memory regressions or improvements. On the one hand, this is surprising: the switch from Quicksort to Timsort introduced the need for a temporary array for merging runs, which can grow much larger than the temporary arrays used for sampling. On the other hand, these temporary arrays are very short-lived (only for the duration of the <code>sort</code> call) and can be allocated and discarded rather quickly in V8’s new space.<h2 id=conclusion>Conclusion <a href=#conclusion class=bookmark>#</a></h2><p>In summary we feel much better about the algorithmic properties and the predictable performance behavior of a Timsort implemented in Torque. Timsort is available starting with V8 v7.0 and Chrome 70. Happy sorting!</div><footer><div><picture><source srcset="/_img/avatars/simon-zuend.avif, /_img/avatars/simon-zuend@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/simon-zuend.jpg width=96 srcset="/_img/avatars/simon-zuend@2x.jpg 2x"></picture><p>作者：Simon Zünd (<a href=https://twitter.com/nimODota>@nimODota</a>), consistent comparator.</div><a href=https://twitter.com/v8js/status/1045656758700650502 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/array-sort>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/array-sort.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>