<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Understanding the ECMAScript spec, part 3 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Tutorial on reading the ECMAScript specification" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Understanding the ECMAScript spec, part 3</h1><p class=meta>发布时间 <time datetime="2020-04-01 00:00:00" itemprop=datePublished title="2020-04-01 00:00:00">2020-04-01</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a> <a href=/blog/tags/understanding-ecmascript/ class=tag>Understanding ECMAScript</a></header><div itemprop=articleBody><p><a href=/blog/tags/understanding-ecmascript>All episodes</a><p>In this episode, we’ll go deeper in the definition of the ECMAScript language and its syntax. If you’re not familiar with <a href=https://en.wikipedia.org/wiki/Context-free_grammar>context-free grammars</a>, now is a good time to check out the basics, since the spec uses context-free grammars to define the language.<h2 id=ecmascript-grammars>ECMAScript grammars <a href=#ecmascript-grammars class=bookmark>#</a></h2><p>The ECMAScript spec defines four grammars:<p>The <a href=https://tc39.es/ecma262/#sec-ecmascript-language-lexical-grammar>lexical grammar</a> describes how <a href=https://en.wikipedia.org/wiki/Unicode#Architecture_and_terminology>Unicode code points</a> are translated into a sequence of <strong>input elements</strong> (tokens, line terminators, comments, white space).<p>The <a href=https://tc39.es/ecma262/#sec-syntactic-grammar>syntactic grammar</a> defines how syntactically correct programs are composed of tokens.<p>The <a href=https://tc39.es/ecma262/#sec-patterns>RegExp grammar</a> describes how Unicode code points are translated into regular expressions.<p>The <a href=https://tc39.es/ecma262/#sec-tonumber-applied-to-the-string-type>numeric string grammar</a> describes how Strings are translated into numeric values.<p>Each grammar is defined as a context-free grammar, consisting of a set of productions.<p>The grammars use slightly different notation: the syntactic grammar uses <code>LeftHandSideSymbol :</code> whereas the lexical grammar and the RegExp grammar use <code>LeftHandSideSymbol ::</code> and the numeric string grammar uses <code>LeftHandSideSymbol :::</code>.<p>Next we’ll look into the lexical grammar and the syntactic grammar in more detail.<h2 id=lexical-grammar>Lexical grammar <a href=#lexical-grammar class=bookmark>#</a></h2><p>The spec defines ECMAScript source text as a sequence of Unicode code points. For example, variable names are not limited to ASCII characters but can also include other Unicode characters. The spec doesn’t talk about the actual encoding (for example, UTF-8 or UTF-16). It assumes that the source code has already been converted into a sequence of Unicode code points according to the encoding it was in.<p>It’s not possible to tokenize ECMAScript source code in advance, which makes defining the lexical grammar slightly more complicated.<p>For example, we cannot determine whether <code>/</code> is the division operator or the start of a RegExp without looking at the larger context it occurs in:<pre class=language-js><code class=language-js><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre><p>Here <code>/</code> is a <code>DivPunctuator</code>.<pre class=language-js><code class=language-js><span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token language-regex regex-source">foo</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span></code></pre><p>Here the first <code>/</code> is the start of a <code>RegularExpressionLiteral</code>.<p>Templates introduce a similar ambiguity — the interpretation of <code>}`</code> depends on the context it occurs in:<pre class=language-js><code class=language-js><span class="token keyword">const</span> what1 <span class="token operator">=</span> <span class="token string">'temp'</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> what2 <span class="token operator">=</span> <span class="token string">'late'</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> t <span class="token operator">=</span> <span class="token template-string"><span class="token string template-punctuation">`</span><span class="token string">I am a </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> what1 <span class="token operator">+</span> what2 <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string template-punctuation">`</span></span><span class="token punctuation">;</span></code></pre><p>Here <code>`I am a ${</code> is <code>TemplateHead</code> and <code>}`</code> is a <code>TemplateTail</code>.<pre class=language-js><code class=language-js><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br><span class="token punctuation">}</span><span class="token template-string"><span class="token string template-punctuation">`</span><span class="token string">not very useful</span><span class="token string template-punctuation">`</span></span><span class="token punctuation">;</span></code></pre><p>Here <code>}</code> is a <code>RightBracePunctuator</code> and <code>`</code> is the start of a <code>NoSubstitutionTemplate</code>.<p>Even though the interpretation of <code>/</code> and <code>}`</code> depends on their “context” — their position in the syntactic structure of the code — the grammars we’ll describe next are still context-free.<p>The lexical grammar uses several goal symbols to distinguish between the contexts where some input elements are permitted and some are not. For example, the goal symbol <code>InputElementDiv</code> is used in contexts where <code>/</code> is a division and <code>/=</code> is a division-assignment. The <a href=https://tc39.es/ecma262/#prod-InputElementDiv><code>InputElementDiv</code></a> productions list the possible tokens which can be produced in this context:<pre class=language-grammar><code class=language-grammar><span class="token production-name">InputElementDiv</span> <span class="token literal">::</span><br>  <span class="token production-name">WhiteSpace</span><br>  <span class="token production-name">LineTerminator</span><br>  <span class="token production-name">Comment</span><br>  <span class="token production-name">CommonToken</span><br>  <span class="token production-name">DivPunctuator</span><br>  <span class="token production-name">RightBracePunctuator</span></code></pre><p>In this context, encountering <code>/</code> produces the <code>DivPunctuator</code> input element. Producing a <code>RegularExpressionLiteral</code> is not an option here.<p>On the other hand, <a href=https://tc39.es/ecma262/#prod-InputElementRegExp><code>InputElementRegExp</code></a> is the goal symbol for the contexts where <code>/</code> is the beginning of a RegExp:<pre class=language-grammar><code class=language-grammar><span class="token production-name">InputElementRegExp</span> <span class="token literal">::</span><br>  <span class="token production-name">WhiteSpace</span><br>  <span class="token production-name">LineTerminator</span><br>  <span class="token production-name">Comment</span><br>  <span class="token production-name">CommonToken</span><br>  <span class="token production-name">RightBracePunctuator</span><br>  <span class="token production-name">RegularExpressionLiteral</span></code></pre><p>As we see from the productions, it’s possible that this produces the <code>RegularExpressionLiteral</code> input element, but producing <code>DivPunctuator</code> is not possible.<p>Similarly, there is another goal symbol, <code>InputElementRegExpOrTemplateTail</code>, for contexts where <code>TemplateMiddle</code> and <code>TemplateTail</code> are permitted, in addition to <code>RegularExpressionLiteral</code>. And finally, <code>InputElementTemplateTail</code> is the goal symbol for contexts where only <code>TemplateMiddle</code> and <code>TemplateTail</code> are permitted but <code>RegularExpressionLiteral</code> is not permitted.<p>In implementations, the syntactic grammar analyzer (“parser”) may call the lexical grammar analyzer (“tokenizer” or “lexer”), passing the goal symbol as a parameter and asking for the next input element suitable for that goal symbol.<h2 id=syntactic-grammar>Syntactic grammar <a href=#syntactic-grammar class=bookmark>#</a></h2><p>We looked into the lexical grammar, which defines how we construct tokens from Unicode code points. The syntactic grammar builds on it: it defines how syntactically correct programs are composed of tokens.<h3 id=example%3A-allowing-legacy-identifiers>Example: Allowing legacy identifiers <a href=#example%3A-allowing-legacy-identifiers class=bookmark>#</a></h3><p>Introducing a new keyword to the grammar is a possibly breaking change — what if existing code already uses the keyword as an identifier?<p>For example, before <code>await</code> was a keyword, someone might have written the following code:<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">old</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">var</span> <span class="token keyword">await</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The ECMAScript grammar carefully added the <code>await</code> keyword in such a way that this code continues to work. Inside async functions, <code>await</code> is a keyword, so this doesn’t work:<pre class=language-js><code class=language-js><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">modern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">var</span> <span class="token keyword">await</span><span class="token punctuation">;</span> <span class="token comment">// Syntax error</span><br><span class="token punctuation">}</span></code></pre><p>Allowing <code>yield</code> as an identifier in non-generators and disallowing it in generators works similarly.<p>Understanding how <code>await</code> is allowed as an identifier requires understanding ECMAScript-specific syntactic grammar notation. Let’s dive right in!<h3 id=productions-and-shorthands>Productions and shorthands <a href=#productions-and-shorthands class=bookmark>#</a></h3><p>Let’s look at how the productions for <a href=https://tc39.es/ecma262/#prod-VariableStatement><code>VariableStatement</code></a> are defined. At the first glance, the grammar can look a bit scary:<pre class=language-grammar><code class=language-grammar><span class="token production-name">VariableStatement</span><span class="token production-params">[Yield, Await]</span> <span class="token literal">:</span><br>  <span class="token literal">var</span> <span class="token production-name">VariableDeclarationList</span><span class="token production-params">[+In, ?Yield, ?Await]</span> <span class="token literal">;</span></code></pre><p>What do the subscripts (<code>[Yield, Await]</code>) and prefixes (<code>+</code> in <code>+In</code> and <code>?</code> in <code>?Async</code>) mean?<p>The notation is explained in the section <a href=https://tc39.es/ecma262/#sec-grammar-notation>Grammar Notation</a>.<p>The subscripts are a shorthand for expressing a set of productions, for a set of left-hand side symbols, all at once. The left-hand side symbol has two parameters, which expands into four "real" left-hand side symbols: <code>VariableStatement</code>, <code>VariableStatement_Yield</code>, <code>VariableStatement_Await</code>, and <code>VariableStatement_Yield_Await</code>.<p>Note that here the plain <code>VariableStatement</code> means “<code>VariableStatement</code> without <code>_Await</code> and <code>_Yield</code>”. It should not be confused with <code>VariableStatement<sub>[Yield, Await]</sub></code>.<p>On the right-hand side of the production, we see the shorthand <code>+In</code>, meaning "use the version with <code>_In</code>", and <code>?Await</code>, meaning “use the version with <code>_Await</code> if and only if the left-hand side symbol has <code>_Await</code>” (similarly with <code>?Yield</code>).<p>The third shorthand, <code>~Foo</code>, meaning “use the version without <code>_Foo</code>”, is not used in this production.<p>With this information, we can expand the productions like this:<pre class=language-grammar><code class=language-grammar><span class="token production-name">VariableStatement</span> <span class="token literal">:</span><br>  <span class="token literal">var</span> <span class="token production-name">VariableDeclarationList_In</span> <span class="token literal">;</span><br><br><span class="token production-name">VariableStatement_Yield</span> <span class="token literal">:</span><br>  <span class="token literal">var</span> <span class="token production-name">VariableDeclarationList_In_Yield</span> <span class="token literal">;</span><br><br><span class="token production-name">VariableStatement_Await</span> <span class="token literal">:</span><br>  <span class="token literal">var</span> <span class="token production-name">VariableDeclarationList_In_Await</span> <span class="token literal">;</span><br><br><span class="token production-name">VariableStatement_Yield_Await</span> <span class="token literal">:</span><br>  <span class="token literal">var</span> <span class="token production-name">VariableDeclarationList_In_Yield_Await</span> <span class="token literal">;</span></code></pre><p>Ultimately, we need to find out two things:<ol><li>Where is it decided whether we’re in the case with <code>_Await</code> or without <code>_Await</code>?<li>Where does it make a difference — where do the productions for <code>Something_Await</code> and <code>Something</code> (without <code>_Await</code>) diverge?</ol><h3 id=_await-or-no-_await%3F><code>_Await</code> or no <code>_Await</code>? <a href=#_await-or-no-_await%3F class=bookmark>#</a></h3><p>Let’s tackle question 1 first. It’s somewhat easy to guess that non-async functions and async functions differ in whether we pick the parameter <code>_Await</code> for the function body or not. Reading the productions for async function declarations, we find <a href=https://tc39.es/ecma262/#prod-AsyncFunctionBody>this</a>:<pre class=language-grammar><code class=language-grammar><span class="token production-name">AsyncFunctionBody</span> <span class="token literal">:</span><br>  <span class="token production-name">FunctionBody</span><span class="token production-params">[~Yield, +Await]</span></code></pre><p>Note that <code>AsyncFunctionBody</code> has no parameters — they get added to the <code>FunctionBody</code> on the right-hand side.<p>If we expand this production, we get:<pre class=language-grammar><code class=language-grammar><span class="token production-name">AsyncFunctionBody</span> <span class="token literal">:</span><br>  <span class="token production-name">FunctionBody_Await</span></code></pre><p>In other words, async functions have <code>FunctionBody_Await</code>, meaning a function body where <code>await</code> is treated as a keyword.<p>On the other hand, if we’re inside a non-async function, <a href=https://tc39.es/ecma262/#prod-FunctionDeclaration>the relevant production</a> is:<pre class=language-grammar><code class=language-grammar><span class="token production-name">FunctionDeclaration</span><span class="token production-params">[Yield, Await, Default]</span> <span class="token literal">:</span><br>  <span class="token literal">function</span> <span class="token production-name">BindingIdentifier</span><span class="token production-params">[?Yield, ?Await]</span> <span class="token literal">(</span> <span class="token production-name">FormalParameters</span><span class="token production-params">[~Yield, ~Await]</span> <span class="token literal">)</span> <span class="token literal">{</span> <span class="token production-name">FunctionBody</span><span class="token production-params">[~Yield, ~Await]</span> <span class="token literal">}</span></code></pre><p>(<code>FunctionDeclaration</code> has another production, but it’s not relevant for our code example.)<p>To avoid combinatorial expansion, let’s ignore the <code>Default</code> parameter which is not used in this particular production.<p>The expanded form of the production is:<pre class=language-grammar><code class=language-grammar><span class="token production-name">FunctionDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">function</span> <span class="token production-name">BindingIdentifier</span> <span class="token literal">(</span> <span class="token production-name">FormalParameters</span> <span class="token literal">)</span> <span class="token literal">{</span> <span class="token production-name">FunctionBody</span> <span class="token literal">}</span><br><br><span class="token production-name">FunctionDeclaration_Yield</span> <span class="token literal">:</span><br>  <span class="token literal">function</span> <span class="token production-name">BindingIdentifier_Yield</span> <span class="token literal">(</span> <span class="token production-name">FormalParameters</span> <span class="token literal">)</span> <span class="token literal">{</span> <span class="token production-name">FunctionBody</span> <span class="token literal">}</span><br><br><span class="token production-name">FunctionDeclaration_Await</span> <span class="token literal">:</span><br>  <span class="token literal">function</span> <span class="token production-name">BindingIdentifier_Await</span> <span class="token literal">(</span> <span class="token production-name">FormalParameters</span> <span class="token literal">)</span> <span class="token literal">{</span> <span class="token production-name">FunctionBody</span> <span class="token literal">}</span><br><br><span class="token production-name">FunctionDeclaration_Yield_Await</span> <span class="token literal">:</span><br>  <span class="token literal">function</span> <span class="token production-name">BindingIdentifier_Yield_Await</span> <span class="token literal">(</span> <span class="token production-name">FormalParameters</span> <span class="token literal">)</span> <span class="token literal">{</span> <span class="token production-name">FunctionBody</span> <span class="token literal">}</span></code></pre><p>In this production we always get <code>FunctionBody</code> and <code>FormalParameters</code> (without <code>_Yield</code> and without <code>_Await</code>), since they are parameterized with <code>[~Yield, ~Await]</code> in the non-expanded production.<p>Function name is treated differently: it gets the parameters <code>_Await</code> and <code>_Yield</code> if the left-hand side symbol has them.<p>To summarize: Async functions have a <code>FunctionBody_Await</code> and non-async functions have a <code>FunctionBody</code> (without <code>_Await</code>). Since we’re talking about non-generator functions, both our async example function and our non-async example function are parameterized without <code>_Yield</code>.<p>Maybe it’s hard to remember which one is <code>FunctionBody</code> and which <code>FunctionBody_Await</code>. Is <code>FunctionBody_Await</code> for a function where <code>await</code> is an identifier, or for a function where <code>await</code> is a keyword?<p>You can think of the <code>_Await</code> parameter meaning "<code>await</code> is a keyword". This approach is also future proof. Imagine a new keyword, <code>blob</code> being added, but only inside "blobby" functions. Non-blobby non-async non-generators would still have <code>FunctionBody</code> (without <code>_Await</code>, <code>_Yield</code> or <code>_Blob</code>), exactly like they have now. Blobby functions would have a <code>FunctionBody_Blob</code>, async blobby functions would have <code>FunctionBody_Await_Blob</code> and so on. We’d still need to add the <code>Blob</code> subscript to the productions, but the expanded forms of <code>FunctionBody</code> for already existing functions stay the same.<h3 id=disallowing-await-as-an-identifier>Disallowing <code>await</code> as an identifier <a href=#disallowing-await-as-an-identifier class=bookmark>#</a></h3><p>Next, we need to find out how <code>await</code> is disallowed as an identifier if we're inside a <code>FunctionBody_Await</code>.<p>We can follow the productions further to see that the <code>_Await</code> parameter gets carried unchanged from <code>FunctionBody</code> all the way to the <code>VariableStatement</code> production we were previously looking at.<p>Thus, inside an async function, we’ll have a <code>VariableStatement_Await</code> and inside a non-async function, we’ll have a <code>VariableStatement</code>.<p>We can follow the productions further and keep track of the parameters. We already saw the productions for <a href=https://tc39.es/ecma262/#prod-VariableStatement><code>VariableStatement</code></a>:<pre class=language-grammar><code class=language-grammar><span class="token production-name">VariableStatement</span><span class="token production-params">[Yield, Await]</span> <span class="token literal">:</span><br>  <span class="token literal">var</span> <span class="token production-name">VariableDeclarationList</span><span class="token production-params">[+In, ?Yield, ?Await]</span> <span class="token literal">;</span></code></pre><p>All productions for <a href=https://tc39.es/ecma262/#prod-VariableDeclarationList><code>VariableDeclarationList</code></a> just carry the parameters on as is:<pre class=language-grammar><code class=language-grammar><span class="token production-name">VariableDeclarationList</span><span class="token production-params">[In, Yield, Await]</span> <span class="token literal">:</span><br>  <span class="token production-name">VariableDeclaration</span><span class="token production-params">[?In, ?Yield, ?Await]</span></code></pre><p>(Here we show only the <a href=https://tc39.es/ecma262/#prod-VariableDeclaration>production</a> relevant to our example.)<pre class=language-grammar><code class=language-grammar><span class="token production-name">VariableDeclaration</span><span class="token production-params">[In, Yield, Await]</span> <span class="token literal">:</span><br>  <span class="token production-name">BindingIdentifier</span><span class="token production-params">[?Yield, ?Await]</span> <span class="token production-name">Initializer</span><span class="token production-params">[?In, ?Yield, ?Await]</span> <span class="token keyword">opt</span></code></pre><p>The <code>opt</code> shorthand means that the right-hand side symbol is optional; there are in fact two productions, one with the optional symbol, and one without.<p>In the simple case relevant to our example, <code>VariableStatement</code> consists of the keyword <code>var</code>, followed by a single <code>BindingIdentifier</code> without an initializer, and ending with a semicolon.<p>To disallow or allow <code>await</code> as a <code>BindingIdentifier</code>, we hope to end up with something like this:<pre class=language-grammar><code class=language-grammar><span class="token production-name">BindingIdentifier_Await</span> <span class="token literal">:</span><br>  <span class="token production-name">Identifier</span><br>  <span class="token literal">yield</span><br><br><span class="token production-name">BindingIdentifier</span> <span class="token literal">:</span><br>  <span class="token production-name">Identifier</span><br>  <span class="token literal">yield</span><br>  <span class="token literal">await</span></code></pre><p>This would disallow <code>await</code> as an identifier inside async functions and allow it as an identifier inside non-async functions.<p>But the spec doesn’t define it like this, instead we find this <a href=https://tc39.es/ecma262/#prod-BindingIdentifier>production</a>:<pre class=language-grammar><code class=language-grammar><span class="token production-name">BindingIdentifier</span><span class="token production-params">[Yield, Await]</span> <span class="token literal">:</span><br>  <span class="token production-name">Identifier</span><br>  <span class="token literal">yield</span><br>  <span class="token literal">await</span></code></pre><p>Expanded, this means the following productions:<pre class=language-grammar><code class=language-grammar><span class="token production-name">BindingIdentifier_Await</span> <span class="token literal">:</span><br>  <span class="token production-name">Identifier</span><br>  <span class="token literal">yield</span><br>  <span class="token literal">await</span><br><br><span class="token production-name">BindingIdentifier</span> <span class="token literal">:</span><br>  <span class="token production-name">Identifier</span><br>  <span class="token literal">yield</span><br>  <span class="token literal">await</span></code></pre><p>(We’re omitting the productions for <code>BindingIdentifier_Yield</code> and <code>BindingIdentifier_Yield_Await</code> which are not needed in our example.)<p>This looks like <code>await</code> and <code>yield</code> would be always allowed as identifiers. What’s up with that? Is the whole blog post for nothing?<h3 id=statics-semantics-to-the-rescue>Statics semantics to the rescue <a href=#statics-semantics-to-the-rescue class=bookmark>#</a></h3><p>It turns out that <strong>static semantics</strong> are needed for forbidding <code>await</code> as an identifier inside async functions.<p>Static semantics describe static rules — that is, rules that are checked before the program runs.<p>In this case, the <a href=https://tc39.es/ecma262/#sec-identifiers-static-semantics-early-errors>static semantics for <code>BindingIdentifier</code></a> define the following syntax-directed rule:<blockquote><pre class=language-grammar><code class=language-grammar><span class="token production-name">BindingIdentifier</span><span class="token production-params">[Yield, Await]</span> <span class="token literal">:</span> <span class="token literal">await</span></code></pre><p>It is a Syntax Error if this production has an <code><sub>[Await]</sub></code> parameter.</blockquote><p>Effectively, this forbids the <code>BindingIdentifier_Await : await</code> production.<p>The spec explains that the reason for having this production but defining it as a Syntax Error by the static semantics is because of interference with automatic semicolon insertion (ASI).<p>Remember that ASI kicks in when we’re unable to parse a line of code according to the grammar productions. ASI tries to add semicolons to satisfy the requirement that statements and declarations must end with a semicolon. (We’ll describe ASI in more detail in a later episode.)<p>Consider the following code (example from the spec):<pre class=language-js><code class=language-js><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">too_few_semicolons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span><br>  <span class="token keyword">await</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>If the grammar disallowed <code>await</code> as an identifier, ASI would kick in and transform the code into the following grammatically correct code, which also uses <code>let</code> as an identifier:<pre class=language-js><code class=language-js><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">too_few_semicolons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span><span class="token punctuation">;</span><br>  <span class="token keyword">await</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>This kind of interference with ASI was deemed too confusing, so static semantics were used for disallowing <code>await</code> as an identifier.<h3 id=disallowed-stringvalues-of-identifiers>Disallowed <code>StringValues</code> of identifiers <a href=#disallowed-stringvalues-of-identifiers class=bookmark>#</a></h3><p>There’s also another related rule:<blockquote><pre class=language-grammar><code class=language-grammar><span class="token production-name">BindingIdentifier</span> <span class="token literal">:</span> <span class="token production-name">Identifier</span></code></pre><p>It is a Syntax Error if this production has an <code><sub>[Await]</sub></code> parameter and <code>StringValue</code> of <code>Identifier</code> is <code>"await"</code>.</blockquote><p>This might be confusing at first. <a href=https://tc39.es/ecma262/#prod-Identifier><code>Identifier</code></a> is defined like this:<pre class=language-grammar><code class=language-grammar><span class="token production-name">Identifier</span> <span class="token literal">:</span><br>  <span class="token production-name">IdentifierName</span> <span class="token skip">but not</span> <span class="token production-name">ReservedWord</span></code></pre><p><code>await</code> is a <code>ReservedWord</code>, so how can an <code>Identifier</code> ever be <code>await</code>?<p>As it turns out, <code>Identifier</code> cannot be <code>await</code>, but it can be something else whose <code>StringValue</code> is <code>"await"</code> — a different representation of the character sequence <code>await</code>.<p><a href=https://tc39.es/ecma262/#sec-identifier-names-static-semantics-stringvalue>Static semantics for identifier names</a> define how the <code>StringValue</code> of an identifier name is computed. For example, the Unicode escape sequence for <code>a</code> is <code>\u0061</code>, so <code>\u0061wait</code> has the <code>StringValue</code> <code>"await"</code>. <code>\u0061wait</code> won’t be recognized as a keyword by the lexical grammar, instead it will be an <code>Identifier</code>. The static semantics for forbid using it as a variable name inside async functions.<p>So this works:<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">old</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">var</span> \u0061wait<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>And this doesn’t:<pre class=language-js><code class=language-js><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">modern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">var</span> \u0061wait<span class="token punctuation">;</span> <span class="token comment">// Syntax error</span><br><span class="token punctuation">}</span></code></pre><h2 id=summary>Summary <a href=#summary class=bookmark>#</a></h2><p>In this episode, we familiarized ourselves with the lexical grammar, the syntactic grammar, and the shorthands used for defining the syntactic grammar. As an example, we looked into forbidding using <code>await</code> as an identifier inside async functions but allowing it inside non-async functions.<p>Other interesting parts of the syntactic grammar, such as automatic semicolon insertion and cover grammars will be covered in a later episode. Stay tuned!</div><footer><div><picture><source srcset="/_img/avatars/marja-holtta.avif, /_img/avatars/marja-holtta@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/marja-holtta.jpg srcset="/_img/avatars/marja-holtta@2x.jpg 2x" width=96></picture><p>作者：<a href=https://twitter.com/marjakh>Marja Hölttä</a>, speculative specification spectator.</div><a href=https://twitter.com/v8js/status/1245400717667577857 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/understanding-ecmascript-part-3>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/understanding-ecmascript-part-3.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>