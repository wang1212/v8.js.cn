<!doctype html><html lang=zh-CN><meta charset=utf-8><title>V8 release v7.9 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="V8 v7.9 features removed deprecation for Double ⇒ Tagged transitions, handling API getters in builtins, OSR caching, and Wasm support for multiple code spaces." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>V8 release v7.9</h1><p class=meta>发布时间 <time datetime="2019-11-20 00:00:00" itemprop=datePublished title="2019-11-20 00:00:00">2019-11-20</time> · 标签： <a href=/blog/tags/release/ class=tag>release</a></header><div itemprop=articleBody><p>Every six weeks, we create a new branch of V8 as part of our <a href=/docs/release-process>release process</a>. Each version is branched from V8’s Git master immediately before a Chrome Beta milestone. Today we’re pleased to announce our newest branch, <a href=https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/7.9>V8 version 7.9</a>, which is in beta until its release in coordination with Chrome 79 Stable in several weeks. V8 v7.9 is filled with all sorts of developer-facing goodies. This post provides a preview of some of the highlights in anticipation of the release.<h2 id=performance>Performance (size & speed) <a href=#performance class=bookmark>#</a></h2><h3 id=removed-deprecation-for-double-%E2%87%92-tagged-transitions>Removed deprecation for Double ⇒ Tagged transitions <a href=#removed-deprecation-for-double-%E2%87%92-tagged-transitions class=bookmark>#</a></h3><p>You might remember from previous blog posts that V8 tracks how fields are represented in objects’ shapes. When the representation of a field changes, the current object’s shape has to be “deprecated”, and a new shape is created with the new field representation.<p>One exception to this is when old field values are guaranteed to be compatible with the new representation. In those cases we can simply swap in the new representation in-place on the object shape, and it will still work for the old objects’ field values. In V8 v7.6 we enabled these in-place representation changes for Smi ⇒ Tagged and HeapObject ⇒ Tagged transitions, but we couldn’t avoid Double ⇒ Tagged because of our MutableHeapNumber optimisation.<p>In V8 v7.9, we got rid of MutableHeapNumber, and instead use HeapNumbers that are implicitly mutable when they belong to a Double representation field. This means we have to be a little more careful about dealing with HeapNumbers (which now are mutable if they are on a double field and immutable otherwise), but HeapNumbers are compatible with the Tagged representation, and therefore we can avoid deprecation in the Double ⇒ Tagged case as well.<p>This relatively simple change improved the Speedometer AngularJS score by 4%.<figure><img alt="" height=380 loading=lazy src=/_img/v8-release-79/speedometer-angularjs.svg width=701><figcaption>Speedometer AngularJS score improvements</figcaption></figure><h3 id=handle-api-getters-in-builtins>Handle API getters in builtins <a href=#handle-api-getters-in-builtins class=bookmark>#</a></h3><p>Previously, V8 would always miss to the C++ runtime when handling getters defined by the embedding API (such as Blink). These included getters defined in the HTML spec such as <code>Node.nodeType</code>, <code>Node.nodeName</code>, etc.<p>V8 would do the entire prototype walk in the builtin to load the getter and then bail out to the runtime once it realizes that the getter is defined by the API. In the C++ runtime, it would walk the prototype chain to get the getter again before executing it, duplicating a lot of work.<p>In general, <a href=https://mathiasbynens.be/notes/shapes-ics>the inline caching (IC) mechanism</a> can help mitigate this as V8 would install an IC handler after the first miss to the C++ runtime. But with the new <a href=https://v8.dev/blog/v8-release-77#lazy-feedback-allocation>lazy feedback allocation</a>, V8 doesn’t install IC handlers until the function has been executed for some time.<p>Now in V8 v7.9, these getters are handled in the builtins without having to miss to the C++ runtime even when they don’t have IC handlers installed, by taking advantage of special API stubs that can call directly into the API getter. This results in a 12% decrease in the amount of time spent in IC runtime in Speedometer’s Backbone and jQuery benchmark.<figure><img alt="" height=371 loading=lazy src=/_img/v8-release-79/speedometer.svg width=600><figcaption>Speedometer Backbone and jQuery improvements</figcaption></figure><h3 id=osr-caching>OSR caching <a href=#osr-caching class=bookmark>#</a></h3><p>When V8 identifies that certain functions are hot it marks them for optimization on the next call. When the function executes again, V8 compiles the function using the optimizing compiler and starts using the optimized code from the subsequent call. However, for functions with long running loops this is not sufficient. V8 uses a technique called on-stack replacement (OSR) to install optimized code for the currently executing function. This allows us to start using the optimized code during the first execution of the function, while it is stuck in a hot loop.<p>If the function is executed a second time, it is very likely to be OSRed again. Before V8 v7.9 we needed to re-optimize the function again in order to OSR it. However, from v7.9 we added OSR caching to retain optimized code for OSR replacements, keyed by the loop header that was used as the entry point in the OSRed function. This has improved performance of some peak-performance benchmarks by 5–18%.<figure><img alt="" height=476 loading=lazy src=/_img/v8-release-79/osr-caching.svg width=769><figcaption>OSR caching improvements</figcaption></figure><h2 id=webassembly>WebAssembly <a href=#webassembly class=bookmark>#</a></h2><h3 id=support-for-multiple-code-spaces>Support for multiple code spaces <a href=#support-for-multiple-code-spaces class=bookmark>#</a></h3><p>So far, each WebAssembly module consisted of exactly one code space on 64-bit architectures, which was reserved on module creation. This allowed us to use near calls within a module, but limited us to 128 MB of code space on arm64, and required to reserved 1 GB upfront on x64.<p>In v7.9, V8 got support for multiple code spaces on 64-bit architectures. This allows us to only reserve the estimated needed code space, and add more code spaces later if needed. Far jump is used for calls between code spaces that are too far apart for near jumps. Instead of ~1000 WebAssembly modules per process V8 now supports several million, only limited by the actual amount of memory available.<h2 id=v8-api>V8 API <a href=#v8-api class=bookmark>#</a></h2><p>Please use <code>git log branch-heads/7.8..branch-heads/7.9 include/v8.h</code> to get a list of the API changes.<p>Developers with an <a href=/docs/source-code#using-git>active V8 checkout</a> can use <code>git checkout -b 7.9 -t branch-heads/7.9</code> to experiment with the new features in V8 v7.9. Alternatively you can <a href=https://www.google.com/chrome/browser/beta.html>subscribe to Chrome’s Beta channel</a> and try the new features out yourself soon.</div><footer><div><picture><source srcset="/_img/avatars/santiago-aboy-solanes.avif, /_img/avatars/santiago-aboy-solanes@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/santiago-aboy-solanes.jpg width=96 srcset="/_img/avatars/santiago-aboy-solanes@2x.jpg 2x"></picture><p>作者：Santiago Aboy Solanes, pointer compressor extraordinaire.</div><a href=https://twitter.com/v8js/status/1197187184304050176 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/v8-release-79>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/v8-release-79.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>