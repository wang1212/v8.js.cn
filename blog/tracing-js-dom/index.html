<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Tracing from JS to the DOM and back again · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Chrome’s DevTools can now trace and snapshot C++ DOM objects and display all reachable DOM objects from JavaScript with their references." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Tracing from JS to the DOM and back again</h1><p class=meta>发布时间 <time datetime="2018-03-01 13:33:37" itemprop=datePublished title="2018-03-01 13:33:37">2018-03-01</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a> <a href=/blog/tags/memory/ class=tag>memory</a></header><div itemprop=articleBody><p>Debugging memory leaks in Chrome 66 just became much easier. Chrome’s DevTools can now trace and snapshot C++ DOM objects and display all reachable DOM objects from JavaScript with their references. This feature is one of the benefits of the new C++ tracing mechanism of the V8 garbage collector.<h2 id=background>Background <a href=#background class=bookmark>#</a></h2><p>A memory leak in a garbage collection system occurs when an unused object is not freed due to unintentional references from other objects. Memory leaks in web pages often involve interaction between JavaScript objects and DOM elements.<p>The following <a href=https://ulan.github.io/misc/leak.html>toy example</a> shows a memory leak that happens when a programmer forgets to unregister an event listener. None of the objects referenced by the event listener can be garbage collected. In particular, the iframe window leaks together with the event listener.<pre class=language-js><code class=language-js><span class="token comment">// Main window:</span><br><span class="token keyword">const</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'iframe.html'</span><span class="token punctuation">;</span><br>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span><br>iframe<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> localVariable <span class="token operator">=</span> iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">;</span><br>  <span class="token keyword">function</span> <span class="token function">leakingListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Do something with `localVariable`.</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>localVariable<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'my-debug-event'</span><span class="token punctuation">,</span> leakingListener<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// BUG: forgot to unregister `leakingListener`.</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The leaking iframe window also keeps all its JavaScript objects alive.<pre class=language-js><code class=language-js><span class="token comment">// iframe.html:</span><br><span class="token keyword">class</span> <span class="token class-name">Leak</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>window<span class="token punctuation">.</span>globalVariable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>It is important to understand the notion of retaining paths to find the root cause of a memory leak. A retaining path is a chain of objects that prevents garbage collection of the leaking object. The chain starts at a root object such as the global object of the main window. The chain ends at the leaking object. Each intermediate object in the chain has a direct reference to the next object in the chain. For example, the retaining path of the <code>Leak</code> object in the iframe looks as follows:<figure><img alt="" height=533 loading=lazy src=/_img/tracing-js-dom/retaining-path.svg width=375><figcaption>Figure 1: Retaining path of an object leaked via <code>iframe</code> and event listener</figcaption></figure><p>Note that the retaining path crosses the JavaScript / DOM boundary (highlighted in green/red, respectively) two times. The JavaScript objects live in the V8 heap, while DOM objects are C++ objects in Chrome.<h2 id=devtools-heap-snapshot>DevTools heap snapshot <a href=#devtools-heap-snapshot class=bookmark>#</a></h2><p>We can inspect the retaining path of any object by taking a heap snapshot in DevTools. The heap snapshot precisely captures all objects on the V8 heap. Up until recently it had only approximate information about the C++ DOM objects. For instance, Chrome 65 shows an incomplete retaining path for the <code>Leak</code> object from the toy example:<figure><img alt="" height=877 loading=lazy src=/_img/tracing-js-dom/chrome-65.png width=1513><figcaption>Figure 2: Retaining path in Chrome 65</figcaption></figure><p>Only the first row is precise: the <code>Leak</code> object is indeed stored in the <code>global_variable</code> of the iframe’s window object. Subsequent rows approximate the real retaining path and make debugging of the memory leak hard.<p>As of Chrome 66, DevTools traces through C++ DOM objects and precisely captures the objects and references between them. This is based on the powerful C++ object tracing mechanism that was introduced for cross-component garbage collection earlier. As a result, <a href="https://www.youtube.com/watch?v=ixadA7DFCx8">the retaining path in DevTools</a> is actually correct now:<figure><div class="video video-16:9"><iframe height=360 loading=lazy src=https://www.youtube.com/embed/ixadA7DFCx8 width=640></iframe></div><figcaption>Figure 3: Retaining path in Chrome 66</figcaption></figure><h2 id=under-the-hood%3A-cross-component-tracing>Under the hood: cross-component tracing <a href=#under-the-hood%3A-cross-component-tracing class=bookmark>#</a></h2><p>DOM objects are managed by Blink — the rendering engine of Chrome, which is responsible for translating the DOM into actual text and images on the screen. Blink and its representation of the DOM are written in C++ which means that the DOM cannot be directly exposed to JavaScript. Instead, objects in the DOM come in two halves: a V8 wrapper object available to JavaScript and a C++ object representing the node in the DOM. These objects have direct references to each other. Determining liveness and ownership of objects across multiple components, such as Blink and V8, is difficult because all involved parties need to agree on which objects are still alive and which ones can be reclaimed.<p>In Chrome 56 and older versions (i.e. until Mar 2017), Chrome used a mechanism called <em>object grouping</em> to determine liveness. Objects were assigned groups based on containment in documents. A group with all of its containing objects was kept alive as long as a single object was kept alive through some other retaining path. This made sense in the context of DOM nodes that always refer to their containing document, forming so-called DOM trees. However, this abstraction removed all of the actual retaining paths which made it hard to use for debugging as shown in Figure 2. In the case of objects that did not fit this scenario, e.g. JavaScript closures used as event listeners, this approach also became cumbersome and led to various bugs where JavaScript wrapper objects would prematurely get collected, which resulted in them being replaced by empty JS wrappers that would lose all their properties.<p>Starting from Chrome 57, this approach was replaced by cross-component tracing, which is a mechanism that determines liveness by tracing from JavaScript to the C++ implementation of the DOM and back. We implemented incremental tracing on the C++ side with write barriers to avoid any stop-the-world tracing jank we’ve been talking about in <a href=/blog/orinoco-parallel-scavenger>previous blog posts</a>. Cross-component tracing does not only provide better latency but also approximates liveness of objects across component boundaries better and fixes several <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=501866">scenarios</a> that used to cause leaks. On top of that, it allows DevTools to provide a snapshot that actually represents the DOM, as shown in Figure 3.<p>Try it out! We are happy to hear your feedback.</div><footer><div><picture><source srcset="/_img/avatars/ulan-degenbaev.avif, /_img/avatars/ulan-degenbaev@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/ulan-degenbaev.jpg width=96 srcset="/_img/avatars/ulan-degenbaev@2x.jpg 2x"></picture><picture><source srcset="/_img/avatars/michael-lippautz.avif, /_img/avatars/michael-lippautz@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/michael-lippautz.jpg width=96 srcset="/_img/avatars/michael-lippautz@2x.jpg 2x"></picture><picture><source srcset="/_img/avatars/hannes-payer.avif, /_img/avatars/hannes-payer@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/hannes-payer.jpg width=96 srcset="/_img/avatars/hannes-payer@2x.jpg 2x"></picture><p>作者：Ulan Degenbaev, Alexei Filippov, Michael Lippautz, and Hannes Payer — the fellowship of the DOM.</div><a href=https://twitter.com/v8js/status/969184997545562112 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/tracing-js-dom>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/tracing-js-dom.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>