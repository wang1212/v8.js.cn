<!doctype html><html lang=zh-CN><meta charset=utf-8><title>.wasm 是什么？wasm 反编译简介 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="WABT gains a new decompilation tool that can make it easier to read the contents of Wasm modules." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>.wasm 是什么？wasm 反编译简介</h1><p class=meta>发布时间 <time datetime="2020-04-27 00:00:00" itemprop=datePublished title="2020-04-27 00:00:00">2020-04-27</time> · 标签： <a href=/blog/tags/webassembly/ class=tag>WebAssembly</a> <a href=/blog/tags/tooling/ class=tag>tooling</a></header><div itemprop=articleBody><p>我们有越来越多的生成或操作 <code>.wasm</code> 文件的编译器和其他工具，有时你可能想看看里面。也许您是这种工具的开发人员，或更直接地，您是 <code>Wasm</code> 程序员，并且出于性能或其他原因，想知道生成的代码是什么样的。<p>问题是，Wasm相当底层，很像实际的汇编代码。特别是，与JVM不同，所有数据结构都编译成加载/存储操作，而不是方便地命名类和字段。诸如LLVM之类的编译器可以进行大量的转换，使生成的代码看起来像输入的代码一样。<h2 id=disassemble-or-decompile>反汇编还是..反编译？ <a href=#disassemble-or-decompile class=bookmark>#</a></h2><p>您可以使用 <code>wasm2wat</code>（<a href=https://github.com/WebAssembly/wabt>WABT</a> 工具包的一部分）之类的工具，将 <code>.wasm</code> 转换为 Wasm 的标准文本格式 <code>.wat</code>，是非常忠实但不是特别可读的表示形式。<p>例如，一个简单的计算点积的 C 函数：<pre class=language-c><code class=language-c><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span> <span class="token keyword">float</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span> <span class="token punctuation">}</span> vec3<span class="token punctuation">;</span><br><br><span class="token keyword">float</span> <span class="token function">dot</span><span class="token punctuation">(</span><span class="token keyword">const</span> vec3 <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> vec3 <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> a<span class="token operator">-></span>x <span class="token operator">*</span> b<span class="token operator">-></span>x <span class="token operator">+</span><br>           a<span class="token operator">-></span>y <span class="token operator">*</span> b<span class="token operator">-></span>y <span class="token operator">+</span><br>           a<span class="token operator">-></span>z <span class="token operator">*</span> b<span class="token operator">-></span>z<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>我们使用 <code>clang dot.c -c -target wasm32 -O2</code>，然后使用 <code>wasm2wat -f dot.o</code> 将其转换为下面这个 <code>.wat</code>：<pre class=language-wasm><code class=language-wasm><span class="token punctuation">(</span><span class="token keyword">func</span> <span class="token variable">$dot</span> <span class="token punctuation">(</span><span class="token keyword">type</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">param</span> <span class="token keyword">i32</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">result</span> <span class="token keyword">f32</span><span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>add</span><br>    <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>add</span><br>      <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>mul</span><br>        <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>load</span><br>          <span class="token punctuation">(</span><span class="token keyword">local</span>.get <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>        <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>load</span><br>          <span class="token punctuation">(</span><span class="token keyword">local</span>.get <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>      <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>mul</span><br>        <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>load</span> <span class="token keyword">offset<span class="token operator">=</span></span><span class="token number">4</span><br>          <span class="token punctuation">(</span><span class="token keyword">local</span>.get <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>        <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>load</span> <span class="token keyword">offset<span class="token operator">=</span></span><span class="token number">4</span><br>          <span class="token punctuation">(</span><span class="token keyword">local</span>.get <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>mul</span><br>      <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>load</span> <span class="token keyword">offset<span class="token operator">=</span></span><span class="token number">8</span><br>        <span class="token punctuation">(</span><span class="token keyword">local</span>.get <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>      <span class="token punctuation">(</span><span class="token keyword">f32<span class="token punctuation">.</span>load</span> <span class="token keyword">offset<span class="token operator">=</span></span><span class="token number">8</span><br>        <span class="token punctuation">(</span><span class="token keyword">local</span>.get <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>那只是一小段代码，但是由于许多原因，阅读起来并不好。除了缺乏基于表达式的语法和冗长之外，还不容易让人理解的内存中的数据结构。现在想象一下如果是大型程序的输出，很容易让人崩溃。<p>如果替代 <code>wasm2wat</code>，运行 <code>wasm-decompile dot.o</code>，您将得到：<pre class=language-c><code class=language-c>function <span class="token function">dot</span><span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token punctuation">{</span> a<span class="token operator">:</span><span class="token keyword">float</span><span class="token punctuation">,</span> b<span class="token operator">:</span><span class="token keyword">float</span><span class="token punctuation">,</span> c<span class="token operator">:</span><span class="token keyword">float</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>             b<span class="token operator">:</span><span class="token punctuation">{</span> a<span class="token operator">:</span><span class="token keyword">float</span><span class="token punctuation">,</span> b<span class="token operator">:</span><span class="token keyword">float</span><span class="token punctuation">,</span> c<span class="token operator">:</span><span class="token keyword">float</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token keyword">float</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> a<span class="token punctuation">.</span>a <span class="token operator">*</span> b<span class="token punctuation">.</span>a <span class="token operator">+</span> a<span class="token punctuation">.</span>b <span class="token operator">*</span> b<span class="token punctuation">.</span>b <span class="token operator">+</span> a<span class="token punctuation">.</span>c <span class="token operator">*</span> b<span class="token punctuation">.</span>c<br><span class="token punctuation">}</span></code></pre><p>这看起来要熟悉得多。除了模仿你熟悉的基于表达式语法的编程语言的外，反编译器还会查看函数中的所有加载和存储的数据，并尝试推断其结构。然后，它给每个用作指针的变量添加“内联”的结构声明。它不会创建命名的结构体声明，因为它不一定知道3个浮点数的哪种用法代表相同的概念。<h2 id=decompile-to-what>反编译成什么？ <a href=#decompile-to-what class=bookmark>#</a></h2><p><code>wasm-decompile</code> 的输出结果尽可能看起来像“非常普通的编程语言”，但仍十分接近 Wasm 的表达。<p>它的目标第一是可读性：尽可能用易于理解的代码帮助读者理解 <code>.wasm</code> 中的内容。其次是尽可能 1:1 表示 Wasm，以避免失去它作为反汇编程序的实用性。显然，这两个目标并不总是统一的。<p>这个输出并不意味着是一种实际的编程语言，并且目前无法将其编译回 Wasm。<h3 id=loads-and-stores>加载和存储 <a href=#loads-and-stores class=bookmark>#</a></h3><p>如上所示，<code>wasm-decompile</code> 会查看特定指针上的所有加载和存储。如果它们形成一个连续的访问集，它将输出这些“内联”结构声明之一。<p>如果不是所有“字段”都被访问，则无法确定这是固定结构，还是其他无关的内存访问形式。在这种情况下，它会退回到更简单的类型，例如 <code>float_ptr</code>（如果类型相同），在最坏的情况下，会输出一个类似 <code>o[2]：int</code> 的数组访问，其中 <code>o</code> 指向 <code>int</code> 值，我们正在访问第三个值。<p>最后一种情况发生的频率比你想象的要多，因为 Wasm 局部变量的功能更像寄存器而不是变量，因此优化的代码可能会为不相关的对象共享同一个指针。<p>反编译器尝试在索引方面更加聪明，并检测诸如 <code>(base + (index &lt;&lt; 2))[0]:int</code> 之类的模式，这些模式是由常规的 C 数组索引操作（如 <code>base[index]</code> 其中 <code>base</code> 指向4字节类型）导致的。这些在代码中非常常见，因为 Wasm 在加载和存储上只有恒定的偏移量。<code>wasm-decompile</code> 的输出结果会将它们转换回 <code>base[index]:int</code>。<p>此外，它还知道绝对地址何时引用数据段。<h3 id=control-flow>控制流程 <a href=#control-flow class=bookmark>#</a></h3><p>最常见的是Wasm的if-then结构，它翻译成一个熟悉的 <code>if (cond) { A } else { B }</code> 语法，另外在 Wasm 中它实际上可以返回一个值，所以它也可以表示成在某些语言中像这样的三元语法 <code>cond ? A : B</code>。<p>Wasm 其余的控制流基于 <code>block</code> 和 <code>loop</code> 块，以及 <code>br</code>、<code>br_if</code> 和 <code>br_table</code> 跳转。反编译器会适当地接近这样的结构，而不是试图推断它们可能来自 while/for/switch 的结构，因为这样可以更好地处理优化后的输出。例如，<code>wasm-decompile</code> 输出中典型的循环可能如下所示：<pre class=language-c><code class=language-c>loop A <span class="token punctuation">{</span><br>  <span class="token comment">// body of the loop here.</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>cond<span class="token punctuation">)</span> <span class="token keyword">continue</span> A<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>这里，<code>A</code> 是一个标签，允许嵌套多个。与 while 循环相比，使用 <code>if</code> 和 <code>continue</code> 来控制循环可能看起来有点陌生，但它直接对应于 Wasm 的 <code>br_if</code>。<p><code>block</code> 类似，但它们不是向后分支，而是向前分支：<pre class=language-c><code class=language-c>block <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>cond<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><br>  <span class="token comment">// body goes here.</span><br><span class="token punctuation">}</span></code></pre><p>这实际上实现了 <code>if-then</code>。如果可能的话，未来版本的反编译器可能会将这些代码转换为实际版本。<p>Wasm 最令人惊讶的控制结构是 <code>br_table</code>，它实现了类似 <code>switch</code> 的功能，但使用了嵌套的 <code>block</code>，这往往很难读取。反编译器会将这些 <code>block</code> 展平以使它们更容易理解，例如：<pre class=language-c><code class=language-c>br_table<span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>D<span class="token punctuation">]</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><br>label A<span class="token operator">:</span><br><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><br>label B<span class="token operator">:</span><br><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><br>label C<span class="token operator">:</span><br><span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span><br>label D<span class="token operator">:</span></code></pre><p>这类似于 <code>switch(a)</code> 默认返回 <code>D</code>。<h3 id=other-fun-features>其他有趣的功能 <a href=#other-fun-features class=bookmark>#</a></h3><p>反编译器:<ul><li>可以从调试或链接信息中提取名称，或生成名称本身。当使用现有名称时，它有特殊的代码来简化C++名称中混乱的符号。<li>已经支持多值提案，这使得表达式和语句的转化有点困难。当返回多个值时，将使用其他变量。<li>它甚至可以从数据段的 <em>contents</em> 生成名称<li>输出所有 Wasm section 类型的漂亮声明，而不仅仅是代码。例如，通过文本输出，使其成为可能。<li>支持运算符优先级（大多数类 C 语言通用）以减少公共表达式上的 <code>()</code>。</ul><h3 id=limitations>局限性 <a href=#limitations class=bookmark>#</a></h3><p>反编译 Wasm 比JVM字节码更难。<p>后者是未优化的，因此相对忠于原始代码的结构，即使名称可能丢失，也引用了唯一的类，而不仅仅是内存位置。<p>相比之下，大多数 <code>.wasm</code> 的输出都经过了 LLVM 的大量优化，因此常常会丢失其大部分原始结构。输出代码与程序员编写的代码非常不同。这使得 Wasm 反编译器将会是一个更大的挑战，但这并不意味着我们不应该尝试！<h2 id=more>更多内容 <a href=#more class=bookmark>#</a></h2><p>当然，最好的方法是反编译您自己的 Wasm 项目！<p>此外，关于 <code>wasm-decompile</code> 的更深入的指南，<a href=https://github.com/WebAssembly/wabt/blob/master/docs/decompiler.md>链接</a>。它的实现在源文件中以 <code>decompiler</code> 开头，<a href=https://github.com/WebAssembly/wabt/tree/master/src>链接</a>（欢迎提PR，使它变得更好）。一些测试用例展示了 <code>.wat</code> 和反编译器之间差异的更多示例，<a href=https://github.com/WebAssembly/wabt/tree/master/test/decompile>链接</a>.</div><footer><div><picture><source srcset="/_img/avatars/wouter-van-oortmerssen.avif, /_img/avatars/wouter-van-oortmerssen@2x.avif 2x" type=image/avif><img alt="" height=96 src=/_img/avatars/wouter-van-oortmerssen.jpg srcset="/_img/avatars/wouter-van-oortmerssen@2x.jpg 2x" width=96 loading=lazy></picture><p>作者：Wouter van Oortmerssen (<a href=https://twitter.com/wvo>@wvo</a>).</div><a href=https://twitter.com/v8js/status/1254829913561014272 class=retweet>Retweet this article!</a></footer><footer><div><img alt="" height=96 src=/_img/avatars/vincent-wang.jpg srcset="/_img/avatars/vincent-wang@2x.jpg 2x" width=96 lazyload=on><p>译者：Vincent Wang (<a href=https://github.com/Vincent0700>@Vincent0700</a>)。<br>Blog：<a href=https://vincentstudio.info>https://vincentstudio.info</a>.</div></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/wasm-decompile>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/wasm-decompile.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>