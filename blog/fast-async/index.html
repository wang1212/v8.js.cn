<!doctype html><html lang=zh-CN><meta charset=utf-8><title>更快的异步函数和 Promise · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="更快的、更容易调试的 async 异步函数和 Promise 即将随 V8 v7.2 / Chrome 72 发布" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>更快的异步函数和 Promise</h1><p class=meta>发布时间 <time datetime="2018-11-12 16:45:07" itemprop=datePublished title="2018-11-12 16:45:07">2018-11-12</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a> <a href=/blog/tags/benchmarks/ class=tag>benchmarks</a> <a href=/blog/tags/presentations/ class=tag>presentations</a></header><div itemprop=articleBody><p>JavaScript 中的异步处理历来因其不是特别快而闻名（:p）。更糟糕的是，调试实时 JavaScript 应用程序 - 例如 Node.js 服务器 - 并非易事，尤其是涉及到异步编程时更甚。幸运的是，现在有了一个重大的改变。本文探讨了我们如何在 V8（甚至其它 JavaScript 引擎中）中优化异步函数和 promise，并描述了我们如何改进异步代码的调试体验。<div class=note><p><strong>注</strong>：如果您更喜欢观看演示文稿，请欣赏下面的视频！如果没有，请跳过视频并继续阅读。</div><figure><div class="video video-16:9"><iframe height=360 loading=lazy src=https://www.youtube.com/embed/DFP5DKDQfOc width=640></iframe></div></figure><h2 id=a-new-approach-to-async-programming>一种新的异步编程方法 <a href=#a-new-approach-to-async-programming class=bookmark>#</a></h2><h3 id=from-callbacks-to-promises-to-async-functions>从回调到 Promise 到异步函数 <a href=#from-callbacks-to-promises-to-async-functions class=bookmark>#</a></h3><p>在 promise 被加入到 JavaScript 语言之前，异步代码一般使用基于回调的 API，尤其是在 Node.js 中。这是一个例子：<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">done</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token function">validateParams</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">done</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">dbQuery</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> dbResults</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">done</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token function">serviceCall</span><span class="token punctuation">(</span>dbResults<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> serviceResults</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token function">done</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> serviceResults<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>当嵌套回调变的越来越深以后，我们称这种模式为“回调地狱”，因为它使代码不易读取且难以维护。<p>幸运的是，现在 promise 成了 JavaScript 语言的一部分，相同的代码可以以更优雅和可维护的方式编写：<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token function">validateParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>dbQuery<span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>serviceCall<span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token keyword">return</span> result<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>最近，JavaScript 开始支持了 <a href=https://developers.google.com/web/fundamentals/primers/async-functions>异步函数</a>。现在可以用与同步代码非常相似的方式编写上述异步代码：<pre class=language-js><code class=language-js><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">await</span> <span class="token function">validateParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> dbResults <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">dbQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> results <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">serviceCall</span><span class="token punctuation">(</span>dbResults<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> results<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>使用异步函数，代码变得更加简洁，并且数据流更容易控制，尽管执行仍然是异步的。（请注意，JavaScript 执行仍然发生在一个线程中，这意味着异步函数本身不会创建真实的物理线程。）<h3 id=from-event-listener-callbacks-to-async-iteration>从事件监听回调到异步迭代器 <a href=#from-event-listener-callbacks-to-async-iteration class=bookmark>#</a></h3><p>另一个在 Node.js 中特别常见的异步范例是 <a href=https://nodejs.org/api/stream.html#stream_readable_streams><code>ReadableStream</code></a>。这是一个例子：<pre class=language-js><code class=language-js><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> body <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span><br>  req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    body <span class="token operator">+=</span> chunk<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">1337</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这段代码有点难以理解：传入的数据只能在回调函数中以 chunks 的方式处理，并且流的结束信号也在回调函数内发生。如果你没有意识到函数其实已经立即终止了，并且必须在回调函数中进行实际处理，那么很容易在这里引入错误。<p>幸运的是，一个很酷的新的 ES2018 特性<a href=http://2ality.com/2016/10/asynchronous-iteration.html>异步迭代器 async iteration</a> 可以简化此代码：<pre class=language-js><code class=language-js><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">try</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> body <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span><br>    req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> chunk <span class="token keyword">of</span> req<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      body <span class="token operator">+=</span> chunk<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span><br>    res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span><br>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">1337</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>现在我们不需要将实际处理的逻辑分别放在两个不同的回调函数中 - <code>'data'</code> 和 <code>'end'</code>。我们可以把这些都写成一个单一的异步函数来处理，并使用新的 <code>for await…of</code> 循环来异步的遍历数据块。我们还添加了 <code>try-catch</code> 块来防止出现 'unhandledRejection' 异常<sup class=footnote-ref><a href=#fn1 id=fnref1>[1]</a></sup>。<p>现在已经可以在生产环境中使用这些新函数了！从 <strong>Node.js 8（V8 v6.2 / Chrome 62）开始已经完全支持</strong>异步函数，并且从 <strong>Node.js 10（V8 v6.8 / Chrome 68）开始已经完全支持</strong>异步迭代器和生成器！<h2 id=async-performance-improvements>异步性能改进 <a href=#async-performance-improvements class=bookmark>#</a></h2><p>我们已经成功地在 V8 v5.5（Chrome 55 和 Node.js 7）和 V8 v6.8（Chrome 68 和 Node.js 10）之间显着提高了异步代码的性能。我们已经使引擎达到了一定的性能水平，以便开发者可以安全地使用这些新的编程范例，而无需担心速度。<figure><img alt="" height=371 src=/_img/fast-async/doxbee-benchmark.svg width=600 loading=lazy></figure><p>上图是 <a href=https://github.com/v8/promise-performance-tests/blob/master/lib/doxbee-async.js>doxbee benchmark</a>，它评估了 Promise 的性能。请注意，图表中的执行时间越低意味着性能越好。<p><a href=https://github.com/v8/promise-performance-tests/blob/master/lib/parallel-async.js>parallel benchmark</a> 的结果则更加强调了 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all><code>Promise.all()</code></a> 的性能，更令人兴奋：<figure><img alt="" height=371 src=/_img/fast-async/parallel-benchmark.svg width=600 loading=lazy></figure><p>我们设法将 <code>Promise.all</code> 的性能提高了 <strong>8</strong> 倍。<p>但是，上述基准测试是跑分测试（synthetic micro-benchmarks）。V8 团队对<a href=/blog/real-world-performance>真实世界的实际用户代码性能</a>更感兴趣。<figure><img alt="" height=371 src=/_img/fast-async/http-benchmarks.svg width=600 loading=lazy></figure><p>上面的图表展示了一些流行的 HTTP 中间件及框架的性能，这些框架大量使用了 Promise 和 <code>async</code> 函数。请注意，此图表显示了每秒的请求数（requests/second），因此与之前的图表不同，这个图表中，柱状图越高表示越好。这些框架的性能在 Node.js 7（V8 v5.5）和 Node.js 10（V8 v6.8）之间得到了显着提升。<p>这些性能改进主要得益于以下三项关键成果：<ul><li><a href=/docs/turbofan>TurboFan</a>，新的优化编译器 🎉<li><a href=/blog/orinoco>Orinoco</a>，新的垃圾收集器 🚛<li>Node.js 8 的 bug，<code>await</code> 跳过 microticks 🐛</ul><p>当我们在 <a href=https://medium.com/the-node-js-collection/node-js-8-3-0-is-now-available-shipping-with-the-ignition-turbofan-execution-pipeline-aa5875ad3367>Node.js 8</a> 中<a href=/blog/launching-ignition-and-turbofan>推出TurboFan</a> 时，全面提升了性能。<p>我们一直在研究一种新的垃圾收集器，我们称之为 Orinoco，它可以将垃圾收集工作从主线程中移除，从而显着改善了垃圾收集的请求处理。<p>最后，虽然放在后面但是并非不重要，Node.js 8 中有一个 bug 导致 <code>await</code> 在某些情况下跳过 microticks，从而产生更好的性能。这个 bug 的原因是我们违反了 es 的规范，但它后来给了我们关于优化的灵感。让我们从有缺陷的行为开始：<pre class=language-js><code class=language-js><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">await</span> p<span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after:await'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'tick:a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br> <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'tick:b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面的程序创建了一个状态为 fulfilled 的 Promise：<code>p</code>，然后 <code>await</code> 取得它的结果，与此同时也将后面的 2 个 <code>then</code> 函数处理程序链接到它上面。您希望以哪种顺序执行 <code>console.log</code> 调用呢？<p>既然 <code>p</code> 的状态已经是 fulfilled 了，你可能会认为首先打印 <code>'after:await'</code> 然后再打印 <code>'tick'</code>。实际上，这是 Node.js 8 中的行为：<figure><img alt="" height=446 src=/_img/fast-async/await-bug-node-8.svg width=960 loading=lazy><figcaption>Node.js 8 的 <code>await</code> bug</figcaption></figure><p>虽然这种行为看起来很直观，但根据规范它并不正确。Node.js 10 实现了正确的行为，即首先执行链式处理程序，然后继续使用异步函数。<figure><img alt="" height=446 src=/_img/fast-async/await-bug-node-10.svg width=960 loading=lazy><figcaption>Node.js 10 中不再有 <code>await</code> 的 bug</figcaption></figure><p>可以说，这种“正确的行为”其实并不直观，对 JavaScript 开发者来说实际上是令人惊讶的，所以值得做一些解释。在我们深入了解 Promise 和异步函数的神奇之处前，让我们从一些更加基础的情况开始。<h3 id=tasks-vs.-microtasks>Tasks vs. microtasks <a href=#tasks-vs.-microtasks class=bookmark>#</a></h3><p>在高层次上，JavaScript 中有 <em>task</em> 和 <em>microtask</em>。task 用于处理 I/O 和计时器等事件，每次执行一个。microtask 为 <code>async</code>/<code>await</code> 和 Promise 实现延迟执行，并在每个 task 结束时执行。在每一个事件循环之前，microtask 队列总是被清空（执行）。<figure><img alt="" height=286 src=/_img/fast-async/microtasks-vs-tasks.svg width=833 loading=lazy><figcaption>微任务和任务之间的区别</figcaption></figure><p>更多详细信息，请查看 Jake Archibald 对<a href=https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/ >浏览器中的 tasks、microtasks、queues 与 schedules</a> （<a href=https://hongfanqie.github.io/tasks-microtasks-queues-and-schedules/ >中文翻译</a>）的解释。Node.js 中的任务模型与此非常相似。<h3 id=async-functions>异步函数 <a href=#async-functions class=bookmark>#</a></h3><p>根据 MDN，异步函数是一个使用隐式 Promise 异步操作以返回其结果的函数。异步函数旨在使异步代码看起来像同步代码，为开发者隐藏异步处理的一些复杂性。<p>最简单的异步函数如下所示：<pre class=language-js><code class=language-js><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">computeAnswer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>当这个异步函数被调用时，它返回一个 Promise，你可以像任何其他的 Promise 那样获得它的值。<pre class=language-js><code class=language-js><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">computeAnswer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → Promise</span><br><br>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// prints 42 on the next turn</span></code></pre><p>只有 <code>p</code> 在下次运行 microtask 时才能获得此 Promise 的值。换句话说，上面的程序在语义上等同于对值调用 <code>Promise.resolve</code>：<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">computeAnswer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>异步函数的真正威力来自 <code>await</code> 表达式，它会暂停函数的执行直到 Promise 状态变为 resolved，并在执行后恢复。<code>await</code> 的值是 Promise 被 fulfilled 的值。这意味着什么？下面是一个示例：<pre class=language-js><code class=language-js><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchStatus</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> response<span class="token punctuation">.</span>status<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p><code>await</code> 暂停了函数 <code>fetchStatus</code> 的执行，稍后在 <code>fetch</code> 返回的 Promise 状态变为 fulfilled 时恢复了执行。这或多或少等同于将把处理过程写在 <code>fetch</code> 返回 Promise 的 <code>then</code> 链。<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">fetchStatus</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=></span> response<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>该处理程序在异步函数种包含了 <code>await</code> 代码。<p>通常你会传递 <code>Promise</code> 给 <code>await</code>，但你实际上可以等待（await）任意的 JavaScript 值。如果 <code>await</code> 后面的表达式的值不是 Promise，则将其转换为 Promise。这意味着你可以这样写 <code>await 42</code>：<pre class=language-js><code class=language-js><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> v <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">42</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> v<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → Promise</span><br><br>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// prints `42` eventually</span></code></pre><p>更有趣的是，<code>await</code> 可以使用任何 <a href=https://promisesaplus.com>“thenable”</a>，即任何带有 <code>then</code> 方法的对象，即使它不是真正的 Promise。因此，您可以实现有趣的事情，例如测量实际 sleep 时间的异步 sleep 功能：<pre class=language-js><code class=language-js><span class="token keyword">class</span> <span class="token class-name">Sleep</span> <span class="token punctuation">{</span><br>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">timeout</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>timeout <span class="token operator">=</span> timeout<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> startTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">,</span><br>               <span class="token keyword">this</span><span class="token punctuation">.</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> actualTime <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>actualTime<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>接下来，让我们看看 V8 引擎底层是如何实现 <code>await</code> <a href=https://tc39.github.io/ecma262/#await>规范</a>的。这是一个简单的异步函数 <code>foo</code>：<pre class=language-js><code class=language-js><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> w <span class="token operator">=</span> <span class="token keyword">await</span> v<span class="token punctuation">;</span><br>  <span class="token keyword">return</span> w<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>当函数调用时，它会将参数 <code>v</code> 包装为 Promise 并暂停执行异步函数，直到该 Promise 的状态变为 resolved。一旦发生这种情况，函数的执行将恢复并且这个 fulfilled 的 Promise 的值被赋值给 <code>w</code>。然后从异步函数中返回此值。<h3 id=await-under-the-hood>引擎底层的 <code>await</code> <a href=#await-under-the-hood class=bookmark>#</a></h3><p>首先，V8 将此函数标记为可恢复（<em>resumable</em>），这意味着可以暂停执行并稍后恢复执行（在 <code>await</code> 处）。然后它创建所谓的 <code>implicit_promise</code>（隐式 Promise），这是在调用异步函数时返回的 Promise，并最终解析（resolve）为异步函数生成的值。<figure><img alt="" height=470 src=/_img/fast-async/await-under-the-hood.svg width=960 loading=lazy><figcaption>简单的异步函数与引擎转换之后的代码之间的比较</figcaption></figure><p>然后是有趣的一点：实际的 <code>await</code>。首先，传递给 <code>await</code> 的值被包裹在一个 Promise 中。然后，处理程序附加到这个包装的 Promise，以便在 Promise 变为 fulfilled 后恢复该函数，并且暂停执行异步函数，并将 <code>implicit_promise</code> 返回给调用者。一旦 <code>promise</code> 变为 fulfilled，恢复异步函数的执行，并将 <code>promise</code> 的值赋值给 <code>w</code>，而且这个 <code>w</code> 也是 <code>implicit_promise</code> 被 resolved 后的值。<p>简而言之，<code>await v</code> 的最初的执行步骤是：<ol><li>将 <code>v</code> 转换为 Promise- <code>v</code> 代表传递给 <code>await</code> 的值。<li>给 Promise 附加处理程序以便稍后恢复异步函数。<li>挂起异步函数并返回 <code>implicit_promise</code> 给调用者。</ol><p>让我们一步一步地完成各个操作。假设传递给 <code>await</code> 的内容已经是一个 Promise，而它的 fulfilled 的值是 <code>42</code>。随后 V8 引擎又创建一个新的 <code>promise</code> 并对 <code>await</code> 后面的 Promise 执行 resolve 操作从而取出值。这确实推迟了下一轮的 Promise 处理链，这些被定义在规范中的 <a href=https://tc39.github.io/ecma262/#sec-promiseresolvethenablejob><code>PromiseResolveThenableJob</code></a>。<figure><img alt="" height=543 src=/_img/fast-async/await-step-1.svg width=814 loading=lazy></figure><p>然后引擎创造了另一个所谓的 <code>throwaway</code> Promise。它被称为 <em>throwaway</em>，因为它的 <code>then</code> 链没有任何处理程序 - 它完全在引擎内部。此 <code>throwaway</code> 然后被链接到 <code>promise</code>，使用适当的处理程序来恢复异步函数。这个 <code>performPromiseThen</code> 操作基本上就是 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then><code>Promise.prototype.then()</code></a> 的幕后操作。最后，暂停执行异步函数，并且控制权返回给调用者。<figure><img alt="" height=543 src=/_img/fast-async/await-step-2.svg width=814 loading=lazy></figure><p>调用者继续执行，最终调用栈变空。然后 JavaScript 引擎开始运行 microtask：它运行之前安排的计划任务 <a href=https://tc39.github.io/ecma262/#sec-promiseresolvethenablejob><code>PromiseResolveThenableJob</code></a>，该计划任务又安排了新的 <a href=https://tc39.github.io/ecma262/#sec-promisereactionjob><code>PromiseReactionJob</code></a>，作为 <code>await</code> 之后的 Promise 的处理链。然后，引擎返回并处理 microtask 队列，因为在继续主事件循环之前必须清空 microtask 队列。<figure><img alt="" height=543 src=/_img/fast-async/await-step-3.svg width=814 loading=lazy></figure><p>接下来是 <a href=https://tc39.github.io/ecma262/#sec-promisereactionjob><code>PromiseReactionJob</code></a>，它将 <code>promise</code> 设置为状态 fulfilled，其值是我们正在 <code>await</code> 的 Promise 值 - 在这个例子中是 <code>42</code> - 并且将计划任务链到 <code>throwaway</code> Promise。然后引擎再次返回 microtask 循环，其中包含要处理的最终 microtask。<figure><img alt="" height=543 src=/_img/fast-async/await-step-4-final.svg width=814 loading=lazy></figure><p>现在这第二个 <a href=https://tc39.github.io/ecma262/#sec-promisereactionjob><code>PromiseReactionJob</code></a> 将 resove 的值传播到 <code>throwaway</code> promise，并恢复异步函数的执行，<code>await</code> 的返回值为 <code>42</code>。<figure><img alt="" height=465 src=/_img/fast-async/await-overhead.svg width=958 loading=lazy><figcaption><code>await</code> 的开销</figcaption></figure><p>总结一下，每个 <code>await</code> 引擎必须创建<strong>两个额外</strong>的 Promise（即使右侧已经是一个 Promise）并且它需要<strong>至少三个</strong> microtask 队列 ticks。谁会意识到仅仅是一个 <code>await</code> 表达就导致了如此之多的开销？！<figure><img alt="" height=215 src=/_img/fast-async/await-code-before.svg width=451 loading=lazy></figure><p>我们来看看这些开销来自哪里。第一行创建了 Promise 包装器。第二行立即使用 <code>await</code> 解析 Promise 包装器 <code>v</code> 的值。这两行导致了另外一个额外的 Promise 和三个 microtick 中的两个。如果 <code>v</code> 已经是一个 Promise（这是常见的情况，因为应用程序通常会在 Promise 上调用 <code>await</code>），这是非常昂贵的。在开发者不常使用的情况下，例如 <code>await 42</code>，引擎仍然需要为其创建 Promise 包装器。<p>事实证明，规范中已经有一个 <a href=https://tc39.github.io/ecma262/#sec-promise-resolve><code>promiseResolve</code></a> 操作，此操作只在需要时执行包装器：<figure><img alt="" height=376 src=/_img/fast-async/await-code-comparison.svg width=950 loading=lazy></figure><p>此操作返回没有修改过的 promise，并且只在必要时将其值包装到 promise 中。当传递给 <code>await</code> 的值已经是一个 Promise 时，这可以节省其中一个额外的 promise，加上 microtick 队列上的两个 tick。从 V8 v7.1 开始，该行为可以通过 V8 的命令行参数 <code>--harmony-await-optimization</code> 开启。我们也提交了对 <a href=https://github.com/tc39/ecma262/pull/1250>proposed this change to the ECMAScript specification</a> 的变更，此变更已经被合并。<p>以下是在引擎底层对 <code>await</code> 的改进，其按步执行的工作方式如下：<figure><img alt="" height=545 src=/_img/fast-async/await-new-step-1.svg width=792 loading=lazy></figure><p>让我们再次假设我们 <code>await</code> 后面的 Promise 返回了 <code>42</code>。感谢 <a href=https://tc39.github.io/ecma262/#sec-promise-resolve><code>promiseResolve</code></a> 带来的魔法，现在 <code>promise</code> 指向了同一个 Promise <code>v</code>，所以这个步骤什么也不需要做。然后引擎继续像以前一样，创建 <code>throwaway</code> Promise，安排 <a href=https://tc39.github.io/ecma262/#sec-promisereactionjob><code>PromiseReactionJob</code></a> 在 microtask 队列的下一个 tick 上恢复异步函数，暂停执行该函数，然后返回给调用者。<figure><img alt="" height=548 src=/_img/fast-async/await-new-step-2.svg width=648 loading=lazy></figure><p>最终当所有 JavaScript 执行完成时，引擎开始运行 microtask，因此它执行 <a href=https://tc39.github.io/ecma262/#sec-promisereactionjob><code>PromiseReactionJob</code></a>。这个过程将 <code>promise</code> 传播到 <code>throwaway</code>，并恢复异步函数的执行，为 <code>await</code> 得到 <code>42</code>。<figure><img alt="" height=383 src=/_img/fast-async/await-overhead-removed.svg width=956 loading=lazy><figcaption>节省了执行 <code>await</code> 的开销</figcaption></figure><p>如果传递给 <code>await</code> 的值已经是一个 Promise，那么这种优化避免了再次创建 Promise 包装器，在这种情况下，我们从<strong>最少三个</strong> microtick 到<strong>只有一个</strong> microtick。这种行为类似于 Node.js 8 所做的，但是现在它不再是一个 bug - 它现在是一个正在标准化的优化！<p>虽然 <code>throwaway</code> 只是在 V8 引擎内部使用，但引擎必须创造这种 Promise。事实证明，<code>throwaway</code> Promise 只是为了满足 <code>performPromiseThen</code> 规范中内部操作的 API 约束。<figure><img alt="" height=198 src=/_img/fast-async/await-optimized.svg width=937 loading=lazy></figure><p>最近在 ECMAScript 规范的<a href=https://github.com/tc39/ecma262/issues/694>编辑性更改</a>中解决了这个问题。引擎不再需要为 <code>await</code> 创造 <code>throwaway</code> Promise - 在绝大部分时间<sup class=footnote-ref><a href=#fn2 id=fnref2>[2]</a></sup>。<figure><img alt="" height=356 src=/_img/fast-async/node-10-vs-node-12.svg width=940 loading=lazy><figcaption><code>await</code> 优化之前和之后的比较</figcaption></figure><p>同 Node.js 10 的 <code>await</code> 对比，在 Node.js 12 中做了更进一步的优化，下图显示了此更改对性能的影响：<figure><img alt="" height=371 src=/_img/fast-async/benchmark-optimization.svg width=600 loading=lazy></figure><p><strong><code>async</code>/<code>await</code> 现在优于手写的 Promise 代码</strong>。这里的关键点是，我们通过修补规范，大大减少了异步函数的开销 - 不仅在 V8 中，而且在所有 JavaScript 引擎中。<p><strong>更新</strong>: 在 V8 v7.2 和 Chrome 72 中，<code>--harmony-await-optimization</code> 已经默认开启。<a href=https://github.com/tc39/ecma262/pull/1250>此补丁</a>也已经合并到了 ECMAScript 规范中。<h2 id=improved-developer-experience>改善开发者体验 <a href=#improved-developer-experience class=bookmark>#</a></h2><p>除了性能之外，JavaScript 开发者还关心诊断和修复 bug 的能力，这在处理异步代码时通常会更加困难。<a href=https://developers.google.com/web/tools/chrome-devtools>Chrome DevTools</a> 支持异步堆栈跟踪，即堆栈跟踪不仅包括堆栈的当前同步部分，还包括异步部分：<figure><img alt="" height=369 src=/_img/fast-async/devtools.png width=877 loading=lazy srcset="/_img/fast-async/devtools@2x.png 2x"></figure><p>这是本地开发过程中非常有用的功能。但是，一旦部署了应用程序，这种方法并没有真正帮助您。在线上调试期间，您只会在日志文件中看到 <code>Error#stack</code> 输出，并且不会告诉您有关异步部分的任何信息。<p>我们最近一直在研究<a href=https://bit.ly/v8-zero-cost-async-stack-traces>零成本的异步堆栈跟踪</a>，它为异步函数调用提供了更丰富的 <code>Error#stack</code> 属性。“零成本”听起来令人兴奋，不是吗？当 Chrome DevTools 特性带来重大开销时，如何才能实现零成本？考虑这个 <code>foo</code> 异步调用 <code>bar</code> 的例子，而且 <code>bar</code> 在 <code>await</code> 的 Promise 之后抛出异常：<pre class=language-js><code class=language-js><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">await</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'BEEP BEEP'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span>stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 Node.js 8 或 Node.js 10 中运行此代码会产生以下输出：<pre class=language-text><code class=language-text><span class=highlight-line>$ node index.js</span><br><span class=highlight-line>Error: BEEP BEEP</span><br><mark class="highlight-line highlight-line-active">    at bar (index.js:8:9)</mark><br><span class=highlight-line>    at process._tickCallback (internal/process/next_tick.js:68:7)</span><br><span class=highlight-line>    at Function.Module.runMain (internal/modules/cjs/loader.js:745:11)</span><br><span class=highlight-line>    at startup (internal/bootstrap/node.js:266:19)</span><br><span class=highlight-line>    at bootstrapNodeJSCore (internal/bootstrap/node.js:595:3)</span></code></pre><p>请注意，虽然调用 <code>foo()</code> 导致错误，但 <code>foo</code> 根本不是堆栈跟踪的一部分。这使得 JavaScript 开发者执行事后调试变得棘手，无论您的代码是部署在 Web 应用程序中还是部署在云容器内部。<p>这里有趣的是，引擎知道 <code>bar</code> 调用完成时它继续执行的位置：在 <code>foo</code> 函数的 <code>await</code> 之后。巧合的是，这也是函数 <code>foo</code> 暂停的地方。引擎可以使用此信息来重建异步堆栈跟踪的部分，即 <code>await</code> 现场。通过此更改，输出变为：<pre class=language-text><code class=language-text><span class=highlight-line>$ node --async-stack-traces index.js</span><br><span class=highlight-line>Error: BEEP BEEP</span><br><mark class="highlight-line highlight-line-active">    at bar (index.js:8:9)</mark><br><span class=highlight-line>    at process._tickCallback (internal/process/next_tick.js:68:7)</span><br><span class=highlight-line>    at Function.Module.runMain (internal/modules/cjs/loader.js:745:11)</span><br><span class=highlight-line>    at startup (internal/bootstrap/node.js:266:19)</span><br><span class=highlight-line>    at bootstrapNodeJSCore (internal/bootstrap/node.js:595:3)</span><br><mark class="highlight-line highlight-line-active">    at async foo (index.js:2:3)</mark></code></pre><p>在堆栈跟踪中，最顶层的函数首先出现，然后是同步堆栈跟踪的其余部分，然后是 <code>bar</code> 函数的异步调用 <code>foo</code>。此更改在 V8 中使用 <code>--async-stack-traces</code> 标志开启。<p><strong>更新</strong>: 在 V8 v7.3 种，<code>--async-stack-traces</code> 默认开启。<p>但是，如果将此与上面 Chrome DevTools 中的异步堆栈跟踪进行比较，您会注意到 <code>foo</code> 堆栈跟踪的异步部分中缺少实际的调用现场。如前所述，这种方法利用了一个事实，<code>await</code> 即恢复和暂停位置是相同的 - 但对于常规 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then><code>Promise#then()</code></a> 或 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch><code>Promise#catch()</code></a> 调用，情况并非如此。有关更多背景信息，请参阅 Mathias Bynens 对<a href=https://mathiasbynens.be/notes/async-stack-traces>why <code>await</code> beats <code>Promise#then()</code></a> 的解释。<h2 id=conclusion>结论 <a href=#conclusion class=bookmark>#</a></h2><p>由于两个重要的优化，我们使异步函数更快：<ul><li>删除两个额外的 microtick，和<li>去除了 <code>throwaway</code> promise。</ul><p>最重要的是，我们通过<a href=https://bit.ly/v8-zero-cost-async-stack-traces>零成本异步堆栈跟踪</a>改进了开发体验，这些可以使用在异步函数的 <code>await</code> 表达式和异步函数中使用 <code>Promise.all()</code>。<p>我们还为 JavaScript 开发者提供了一些很好的性能建议：<ul><li>使用 <code>async</code> 函数和 <code>await</code> 替代手写的 Promise 代码，以及<li>坚持 JavaScript 引擎提供的原生 Promise 实现，以避免在 <code>await</code> 中使用额外的两个 microtick。</ul><hr class=footnotes-sep><section class=footnotes><ol class=footnotes-list><li class=footnote-item id=fn1><p>感谢 <a href=https://twitter.com/matteocollina>Matteo Collina</a> 为此提交的 <a href=https://github.com/mcollina/make-promises-safe/blob/master/README.md#the-unhandledrejection-problem>issue</a>. <a href=#fnref1 class=footnote-backref>↩︎</a><li class=footnote-item id=fn2><p>如果在 Node.js 中使用 <a href=https://nodejs.org/api/async_hooks.html><code>async_hooks</code></a>，V8 仍然需要创建 <code>throwaway</code>，因为 <code>before</code> 和 <code>after</code> 钩子需要在 <code>throwaway</code> 的 promise <em>上下文中</em>运行。 <a href=#fnref2 class=footnote-backref>↩︎</a></ol></section></div><footer><div><picture><source srcset="/_img/avatars/maya-armyanova.avif, /_img/avatars/maya-armyanova@2x.avif 2x" type=image/avif><img alt="" height=96 src=/_img/avatars/maya-armyanova.jpg width=96 loading=lazy srcset="/_img/avatars/maya-armyanova@2x.jpg 2x"></picture><picture><source srcset="/_img/avatars/benedikt-meurer.avif, /_img/avatars/benedikt-meurer@2x.avif 2x" type=image/avif><img alt="" height=96 src=/_img/avatars/benedikt-meurer.jpg width=96 loading=lazy srcset="/_img/avatars/benedikt-meurer@2x.jpg 2x"></picture><p>作者：Maya Lekova (<a href=https://twitter.com/Zmayski>@MayaLekova</a>), always-awaiting anticipator, and Benedikt Meurer (<a href=https://twitter.com/bmeurer>@bmeurer</a>), professional performance promiser.</div></footer><footer><div><img alt="" height=96 src=/_img/avatars/justjavac.jpg width=96 srcset="/_img/avatars/justjavac@2x.jpg 2x" lazyload=on><p>译者：迷渡 (<a href=https://github.com/justjavac>@justjavac</a>)，V8.js.cn 站长.</div></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/fast-async>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/fast-async.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>