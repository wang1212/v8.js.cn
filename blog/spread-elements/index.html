<!doctype html><html lang=zh-CN><meta charset=utf-8><title>加速 [...spread] 运算 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="V8 v7.2 显著地提升了 Array.from(array) 的性能，从而加速了在数组、字符串、Set、Map 上使用 [...spread] 的效率" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>加速 <code>[...spread]</code> 运算</h1><p class=meta>发布时间 <time datetime="2018-12-04 16:57:21" itemprop=datePublished title="2018-12-04 16:57:21">2018-12-04</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a> <a href=/blog/tags/benchmarks/ class=tag>benchmarks</a></header><div itemprop=articleBody><p>Hai Dong 在 V8 团队实习，在这三个月实习期间，他致力于提升 <code>[...array]</code>、<code>[...string]</code>、<code>[...set]</code>、<code>[...map.keys()]</code> 和 <code>[...map.values()]</code>（当展开的元素位于数组字面量的起始位置）。他甚至让 <code>Array.from(iterable)</code> 的速度变得更快。这篇文章解释了他所做工作的一些细节，这些变更会在 V8 7.2 版本发布。<h2 id=spread-elements>元素展开 <a href=#spread-elements class=bookmark>#</a></h2><p>元素展开是由 <code>...iterable</code> 形式的数组字面量组成。作为一种从可迭代对象创建数组的新方式，该特性在 ES2015(ES6) 中提出。比如，数组字面量 <code>[1, ...arr, 4, ...b]</code> 会创建一个新数组，该数组第一个元素是 <code>1</code>，然后是 <code>arr</code> 的各个元素，其次是 <code>4</code>，最后是 <code>b</code> 的各个元素：<pre class=language-js><code class=language-js><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// → [1, 2, 3, 4, 5, 6, 7]</span></code></pre><p>另一个例子，任何字符串都可以展开为包含其所有字符（Unicode 码位）的数组：<pre class=language-js><code class=language-js><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'こんにちは'</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>str<span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// → ['こ', 'ん', 'に', 'ち', 'は']</span></code></pre><p>同样，<code>Set</code> 也可以展开为数组，里面包含了该集合的所有元素，按照迭代顺序排列：<pre class=language-js><code class=language-js><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'V8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'TurboFan'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// → ['V8', 'TurboFan']</span></code></pre><p>总而言之，数组字面量中的元素展开语法 <code>...x</code> 假定 <code>x</code> 提供一个迭代器（通过 <code>x[Symbol.iterator()]</code> 访问。然后通过该迭代器获取元素插入到结果数组。<p>将数组展开到一个新的数组，但是前后不能添加其他元素，即 <code>[...arr]</code>，这种简单的使用情景被认为是 ES2015 中一种简洁、直接的浅拷贝 <code>arr</code> 的方法。不幸的是，在 V8 中，这一操作的性能远低于 ES5 中的其它写法。Hai 的目标就是改变这一现状。<h2 id=why-is-(or-were!)-spread-elements-slow%3F>为什么元素展开（以前）这么慢？ <a href=#why-is-(or-were!)-spread-elements-slow%3F class=bookmark>#</a></h2><p>有许多浅拷贝数组 <code>arr</code> 的方法。例如，你可以使用 <code>arr.slice()</code>，或者 <code>arr.concat()</code>，或者 <code>[...arr]</code>。或者，你可以自己写一个 <code>clone</code> 函数，通过标准的 <code>for</code> 循环进行浅拷贝：<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// 预分配恰当的 `result` 数组空间，避免动态增长数组</span><br>  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>理想情况下，无论你选择哪一种方式，都应该具有相近的性能。不幸的是，如果你选择了 <code>[...arr]</code>，在 V8 中它将会比 <code>clone</code> 函数慢。其原因在于 V8 将 <code>[...arr]</code> 转译为类似这样的代码：<pre class=language-js><code class=language-js><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> iterator <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> next <span class="token operator">=</span> iterator<span class="token punctuation">.</span>next<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> iteratorResult <span class="token operator">=</span> <span class="token function">next</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>iterator<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>iteratorResult<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><br>    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>iteratorResult<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>这段代码比 <code>clone</code> 慢，原有如下：<ol><li>它需要在一开始通过读取和检查 <code>Symbol.interator</code> 属性来创建一个 <code>iterator</code>。<li>它需要在每次循环都创建和查询 <code>iteratorResult</code> 对象。<li>它在每次循环迭代的过程中，通过调用 <code>push</code> 来增大 <code>result</code> 数组，导致空间的不断重新分配。</ol><p>我们之所以这样实现，是因为正如之前所提到的，元素展开操作不仅可以被用于数组，还可以用于任何<strong>可迭代</strong>对象，而且必须遵循<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols>迭代规范</a>。不过，V8 应该很聪明地意识到被展开的对象是不是一个数组，从而在更底层提取元素，因此：<ol><li>避免创建迭代器对象<li>避免创建迭代器结果对象<li>避免反复增长并重分配结果数组（我们已经提前知道元素的个数）</ol><p>针对快速数组，我们使用 <a href=/blog/csa>CSA</a> 来实现这一简单的想法，例如拥有最常见的六种<a href=/blog/elements-kinds>元素类型</a>的数组。这一<a href=/blog/real-world-performance>真实世界情景</a>的优化，适用于在数组字面量开头使用对象展开操作，例如 <code>[...foo]</code>。如下图所示，新的 Fast-Path 在展开长度为 100,000 的数组时获得了 3 倍的性能提升，比手写的 <code>clone</code> 循环快了 25%。<figure><img alt="" height=243 src=/_img/spread-elements/spread-fast-array.png srcset="/_img/spread-elements/spread-fast-array@2x.png 2x" width=268 loading=lazy><figcaption>为快速数组进行元素展开操作的性能提升</figcaption></figure><div class=note><p>**注意：**虽然没有在此显示，但是 Fast-Path 同样也适用于展开操作后面由其它元素时（例如 <code>[...arr, 1, 2, 3]</code>，但如果前面有其他元素则无效（例如 <code>[1, 2, 3, ...arr]</code>）。</div><h2 id=tread-carefully-down-that-Fast-Path>仔细检查 Fast-Path <a href=#tread-carefully-down-that-Fast-Path class=bookmark>#</a></h2><p>该方法是令人激动的速度提升，但是我们必须仔细检查 Fast-Path 是否正确：JavaScript 允许程序员以多种方法修改对象（甚至数组）的迭代行为。由于元素展开使用迭代规范，当原始迭代机制被修改时，我们将不使用 Fast-Path ，以此来确保修改后的迭代行为依然符合规范。例如以下情景：<h3 id=own-symbol.iterator-property>自身的 <code>Symbol.iterator</code> 属性 <a href=#own-symbol.iterator-property class=bookmark>#</a></h3><p>一般而已，数组 <code>arr</code> 不会拥有它自己的 <a href=https://tc39.github.io/ecma262/#sec-symbol.iterator><code>Symbol.iterator</code></a> 属性，所以当我们查找该 symbol 时会在数组的原型上找到。下面的例子中，通过直接在 <code>arr</code> 上定义 <code>Symbol.iterator</code> 绕过了原型。在做这样的修改之后，在 <code>arr</code> 上查找 <code>Symbol.iterator</code> 会得到一个空迭代器，所以展开 <code>arr</code> 不会获得元素，展开的数组字面量是一个空数组。<pre class=language-js><code class=language-js><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token function function-variable">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// → []</span></code></pre><h3 id=modified-%25arrayiteratorprototype%25>修改 <code>%ArrayIteratorPrototype%</code> <a href=#modified-%25arrayiteratorprototype%25 class=bookmark>#</a></h3><p><code>next</code> 方法也可以直接通过 <a href=https://tc39.github.io/ecma262/#sec-%25arrayiteratorprototype%25-object><code>%ArrayIteratorPrototype%</code></a> 来修改，这是数组迭代器的原型（会影响所有数组）。<pre class=language-js><code class=language-js>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function function-variable">next</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token punctuation">{</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// → []</span></code></pre><h2 id=dealing-with-holey-arrays>处理_稀疏_数组 <a href=#dealing-with-holey-arrays class=bookmark>#</a></h2><p>另外需要注意的是复制稀疏数组，例如 <code>['a', , 'c']</code> 这种缺失部分元素的数组。展开这样的数组时，根据迭代规范，展开这样的数组不会保留空洞，而是用相应索引处的数组原型中的值填充它们。默认情况下数组的原型中没有元素，意味着空洞将会被 <code>undefined</code> 填充。例如，<code>[...['a', , 'c']]</code> 将会获得 <code>['a', undefined, 'c']</code>。<p>我们的 Fast-Path 在这种情况下可以很聪明地处理空洞。它不会盲目地复制输入数组的存储空间，而是会观察这些空洞并把它们小心的转换成 <code>undefined</code> 值。下图展示了展开 100,000 个元素但只有 600 个整数其它均是空洞的数组的性能。展开这样一个充满空洞的稀疏数组比 <code>clone</code> 函数快 4 倍。（它们过去的性能大致相同，但在图中未显示）。<p>注意，虽然图中包含了 <code>slice</code> 方法的结果，但是与它比较是不公平的，因为 <code>slice</code> 对稀疏数组拥有不同的语义，它会保留所有的空洞，所以少做了很多工作。<figure><img alt="" height=250 src=/_img/spread-elements/spread-holey-smi-array.png srcset="/_img/spread-elements/spread-holey-smi-array@2x.png 2x" width=284 loading=lazy><figcaption>对稀疏整型数组进行元素展开的性能 (<a href=/blog/elements-kinds><code>HOLEY_SMI_ELEMENTS</code></a>)</figcaption></figure><p>我们的 Fast-Path 必须把空洞填充为 <code>undefined</code>，这个操作并没有听起来这么简单：他可能需要把整个数组转换成另一种元素类型。下图展示了这种情景。初始化和前文一样，不同的是这次的 600 个数组元素是未拆封的 double 类型，数组的元素类型是 <code>HOLEY_DOUBLE_ELEMENTS</code>。因为该元素类型无法承载类似 <code>undefined</code> 的标记值，展开这样的数组需要执行代价高昂的元素类型转换操作，这就是为什么 <code>[...a]</code> 的分数比上一张图低许多。不过，还是比 <code>clone(a)</code> 要快许多。<figure><img alt="" height=242 src=/_img/spread-elements/spread-holey-double-array.png srcset="/_img/spread-elements/spread-holey-double-array@2x.png 2x" width=282 loading=lazy><figcaption>对稀疏双精度数组进行元素展开的性能 (<a href=/blog/elements-kinds><code>HOLEY_DOUBLE_ELEMENTS</code></a>)</figcaption></figure><h2 id=spreading-strings%2C-sets%2C-and-maps>展开字符串、<code>Set</code> 和 <code>Map</code> <a href=#spreading-strings%2C-sets%2C-and-maps class=bookmark>#</a></h2><p>跳过迭代器对象并避免增长结果数组的想法同样适用于其他标准数据类型。实际上，我们为原始字符串，Set 和 Map 实现了类似的 Fast-Path ，每当存在修改迭代行为时都要小心地绕过它们。<p>关于 Set， Fast-Path 不仅支持直接展开 Set（<code>[...set]</code>），还支持展开它的键迭代器（<code>[...set.keys()]</code>）和它的值迭代器（<code>[...set.values()]</code>）。在我们的微基准测试中，这些操作现在比以前快了 18 倍。<p>对 Map 的 Fast-Path 也是类似的，但是并不支持直接展开 Map（[...map]），因为我们认为这是一个不常用的操作。由于某些原因， Fast-Path 也不支持 <code>.entries()</code> 迭代器。在我们的微基准测试中，这些操作现在比以前快了大约 14 倍。<p>对字符串进行元素展开操作（<code>[...string]</code>），我们测得了大约 5 倍的性能提升，在下图中以紫色和绿色折现表示。注意，这甚至比在下图中以蓝色和粉色显示的 TurboFan 优化的 for-of 循环还要快。（TurboFan 可以分析字符串迭代并为其生成优化后的代码）。在每种情况下都有两个图标，因为微基准测试在两个不同的字符串表示法上操作（单字节字符串和双字节字符串）。<figure><img alt="" height=248 src=/_img/spread-elements/spread-string.png srcset="/_img/spread-elements/spread-string@2x.png 2x" width=356 loading=lazy><figcaption>对字符串进行元素展开操作</figcaption></figure><figure><img alt="" height=248 src=/_img/spread-elements/spread-set.png srcset="/_img/spread-elements/spread-set@2x.png 2x" width=313 loading=lazy><figcaption>对含有 10 万个整数的 Set 进行元素展开（品红色，大概快 18 倍），并且和 <code>for</code>-<code>of</code> 循环进行对比（红色）</figcaption></figure><h2 id=improving-array.from-performance>提升 <code>Array.from</code> 的性能 <a href=#improving-array.from-performance class=bookmark>#</a></h2><p>幸运的是，元素展开的 Fast-Path 同样可以用于 <code>Array.from</code>，只要传入 <code>Array.from</code> 的是一个可迭代对象并且不包含映射函数。（例如 <code>Array.from([1, 2, 3])</code>）。之所以可以使用，因为 <code>Array.from</code> 的表现与展开操作一致。这显著地提升了性能，下图展示了 100 个双精度数的数组的性能。<figure><img alt="" height=242 src=/_img/spread-elements/array-from-array-of-doubles.png srcset="/_img/spread-elements/array-from-array-of-doubles@2x.png 2x" width=284 loading=lazy><figcaption>当 <code>array</code> 包含 100 个双精度数时，<code>Array.from(array)</code> 的性能提升</figcaption></figure><h2 id=conclusion>结论 <a href=#conclusion class=bookmark>#</a></h2><p>V8 v7.2 / Chrome 72 大幅提升了元素展开的性能，当他们在数组字面量的最前使用，例如 <code>[...x]</code> 或者 <code>[...x, 1, 2]</code>。这个提升可用于数组、原始字符串、Map 的键、Map 的值，以及 <code>Array.from(x)</code>。</div><footer><div><p>作者：Hai Dang & Georg Neis.</div><a href=https://twitter.com/v8js/status/1070344545685118976 class=retweet>Retweet this article!</a></footer><footer><div><img alt="" height=96 src=/_img/avatars/justjavac.jpg srcset="/_img/avatars/justjavac@2x.jpg 2x" width=96 lazyload=on><p>译者：迷渡 (<a href=https://github.com/justjavac>@justjavac</a>)，V8.js.cn 站长.</div></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/spread-elements>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/spread-elements.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>