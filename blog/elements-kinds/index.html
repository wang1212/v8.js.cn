<!doctype html><html lang=zh-CN><meta charset=utf-8><title>V8 中的元素种类及性能优化 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="This technical deep-dive explains how V8 optimizes operations on arrays behind the scenes, and what that means for JavaScript developers." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>V8 中的元素种类及性能优化</h1><p class=meta>发布时间 <time datetime="2017-09-12 13:33:37" itemprop=datePublished title="2017-09-12 13:33:37">2017-09-12</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a> <a href=/blog/tags/presentations/ class=tag>presentations</a></header><div itemprop=articleBody><div class=note><p>注: 如果你正在阅读下面的文章，那么你肯定对这个视频也感兴趣！</div><figure><div class="video video-16:9"><iframe height=360 loading=lazy src=https://www.youtube.com/embed/m9cTaYI95Zc width=640></iframe></div></figure><p>JavaScript 对象可以具有与它们相关联的任意属性。对象属性的名称可以包含任何字符。JavaScript 引擎可以进行优化的一个有趣的例子是当属性名是纯数字时，一个特例就是<a href=https://tc39.es/ecma262/#array-index>数组索引的属性</a>。<p>在 V8 中，如果属性名是数字（最常见的形式是 <code>Array</code> 构造函数生成的对象）会被特殊处理。尽管在许多情况下，这些数字索引属性的行为与其他属性一样，V8 选择将它们与非数字属性分开存储以进行优化。在引擎内部，V8 甚至给这些属性一个特殊的名称：<strong>元素</strong>。对象具有映射到值的[属性]](/blog/fast-properties)，而数组具有映射到元素的索引。<p>尽管这些内部结构从未直接暴露给 JavaScript 开发人员，但它们解释了为什么某些代码模式比其他代码模式更快。<h2 id=common-elements-kinds>常见的元素种类 <a href=#common-elements-kinds class=bookmark>#</a></h2><p>运行 JavaScript 代码时，V8 会跟踪每个数组所包含的元素。这些信息可以帮助 V8 优化数组元素的操作。例如，当您在数组上调用 <code>reduce</code>，<code>map</code> 或 <code>forEach</code> 时，V8 可以根据数组包含哪些元素来优化这些操作。<p>拿这个数组举例：<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>它包含什么样的元素？如果你使用 <code>typeof</code> 操作符，它会告诉你数组包含 <code>number</code>。在语言层面，这就是你所得到的：JavaScript 不区分整数，浮点数和双精度 - 它们只是数字。然而，在引擎级别，我们可以做出更精确的区分。这个数组的元素是 <code>PACKED_SMI_ELEMENTS</code>。在 V8<br>中，术语 Smi 是指用于存储小整数的特定格式。（后面我们会在 <code>PACKED</code> 部分中说明。）<p>稍后在这个数组中添加一个浮点数将其转换为更通用的元素类型：<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// 元素类型: PACKED_SMI_ELEMENTS</span><br>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4.56</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// 元素类型: PACKED_DOUBLE_ELEMENTS</span></code></pre><p>向数组添加字符串再次改变其元素类型。<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// 元素类型: PACKED_SMI_ELEMENTS</span><br>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4.56</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// 元素类型: PACKED_DOUBLE_ELEMENTS</span><br>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// 元素类型: PACKED_ELEMENTS</span></code></pre><p>到目前为止，我们已经看到三种不同的元素，具有以下基本类型：<ul><li>小整数，又称 Smi（<b>Sm</b>all <b>i</b>ntegers）。<li>双精度浮点数，浮点数和不能表示为 Smi 的整数。<li>常规元素，不能表示为 Smi 或双精度的值。</ul><p>请注意，双精度浮点数是 Smi 的更为一般的变体，而常规元素是双精度浮点数之上的另一个概括。可以表示为 Smi 的数字集合是可以表示为<br>double 的数字的子集。<p>这里重要的一点是，元素种类转换只能从一个方向进行：从特定的（例如 <code>PACKED_SMI_ELEMENTS</code>）到更一般的（例如 <code>PACKED_ELEMENTS</code>）。例如，一旦数组被标记为 <code>PACKED_ELEMENTS</code>，它就不能回到 <code>PACKED_DOUBLE_ELEMENTS</code>。<p>到目前为止，我们已经学到了以下内容：<ul><li>V8 为每个数组分配一个元素种类。<li>数组的元素种类并没有被捆绑在一起 - 它可以在运行时改变。在前面的例子中，我们从 <code>PACKED_SMI_ELEMENTS</code> 过渡到 <code>PACKED_ELEMENTS</code>。<li>元素种类转换只能从特定种类转变为更普遍的种类。</ul><h2 id=packed-vs.-holey-kinds>密集数组 PACKED 和稀疏数组 HOLEY <a href=#packed-vs.-holey-kinds class=bookmark>#</a></h2><p>到目前为止，我们只处理密集或打包（PACKED）数组。在数组中创建稀疏数组将元素降级到其 HOLEY 变体：<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4.56</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// 元素类型: PACKED_ELEMENTS</span><br>array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 5</span><br>array<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// array[5] until array[8] are now holes</span><br><span class="token comment">// 元素类型: HOLEY_ELEMENTS</span></code></pre><p>V8 之所以做这个区别是因为 <code>PACKED</code> 数组的操作比在 <code>HOLEY</code> 数组上的操作更利于进行优化。对于 <code>PACKED</code> 数组，大多数操作可以有效执行。相比之下， <code>HOLEY</code> 数组的操作需要对原型链进行额外的检查和昂贵的查找。<p>到目前为止，我们看到的每个基本元素（即 Smis，double 和常规元素）有两种：<code>PACKED</code> 和 <code>HOLEY</code>。我们不仅可以从 <code>PACKED_SMI_ELEMENTS</code> 转变为 <code>PACKED_DOUBLE_ELEMENTS</code> 我们也可以从任何 <code>PACKED</code> 形式转变成 <code>HOLEY</code> 形式。<p>回顾一下：<ul><li>最常见的元素种类 <code>PACKED</code> 和 <code>HOLEY</code>。<li><code>PACKED</code> 数组的操作比在 <code>HOLEY</code> 数组上的操作更为有效。<li>元素种类可从过渡 <code>PACKED</code> 转变为 <code>HOLEY</code>。</ul><h2 id=the-elements-kind-lattice>元素种类的格 <a href=#the-elements-kind-lattice class=bookmark>#</a></h2><p>V8 将这个变换系统实现为<a href=https://en.wikipedia.org/wiki/Lattice_%28order%29>格 lattice</a>(数学概念)。这是一个简化的可视化，仅显示最常见的元素种类：<figure><img alt="" height=540 src=/_img/elements-kinds/lattice.svg width=960 loading=lazy></figure><p>只能通过格子向下过渡。一旦将单精度浮点数添加到 Smi 数组中，即使稍后用 Smi 覆盖浮点数，它也会被标记为 DOUBLE。类似地，一旦在数组中创建了一个洞，它将被永久标记为有洞 HOLEY，即使稍后填充它也是如此。<p>V8 目前有 <a href="https://cs.chromium.org/chromium/src/v8/src/elements-kind.h?l=14&rcl=ec37390b2ba2b4051f46f153a8cc179ed4656f5d">21 种不同的元素种类</a>，每种元素都有自己的一组可能的优化。<p>一般来说，更具体的元素种类可以进行更细粒度的优化。元素类型的在格子中越是向下，该对象的操作越慢。为了获得最佳性能，请避免不必要的不具体类型 - 坚持使用符合您情况的最具体的类型。<h2 id=performance-tips>性能提示 <a href=#performance-tips class=bookmark>#</a></h2><p>在大多数情况下，元素种类的跟踪操作都隐藏在引擎下面，您不需要担心。但是，为了从系统中获得最大的收益，您可以采取以下几方面。再次重申:更具体的元素种类可以进行更细粒度的优化。元素类型的在格子中越是向下，该对象的操作越慢。为了获得最佳性能，请避免不必要的不具体类型 - 坚持使用符合您情况的最具体的类型。<h3 id=%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E6%B4%9E(hole)-%23avoid-creating-holes>避免创建洞(hole) #avoid-creating-holes <a href=#%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E6%B4%9E(hole)-%23avoid-creating-holes class=bookmark>#</a></h3><p>假设我们正在尝试创建一个数组，例如：<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// 此时，数组是稀疏的，所以它被标记为 `HOLEY_SMI_ELEMENTS`</span><br><span class="token comment">// i.e. 给出当前信息的最具体的可能性。</span><br>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><br><span class="token comment">// 接着，这是一个字符串，而不是一个小整数...所以过渡到`HOLEY_ELEMENTS`。</span><br>array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span><br>array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'c'</span><span class="token punctuation">;</span><br><span class="token comment">// 这时，数组中的所有三个位置都被填充，所以数组被打包（即不再稀疏）。</span><br><span class="token comment">// 但是，我们无法转换为更具体的类型，例如 “PACKED_ELEMENTS”。</span><br><span class="token comment">// 元素类保留为“HOLEY_ELEMENTS”。</span></code></pre><p>一旦数组被标记为有洞，它永远是有洞的 - 即使它被打包了！从那时起，数组上的任何操作都可能变慢。如果您计划在数组上执行大量操作，并且希望对这些操作进行优化，请避免在数组中创建空洞。V8 可以更有效地处理密集数组。<p>创建数组的一种更好的方法是使用字面量：<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// elements kind: PACKED_ELEMENTS</span></code></pre><p>如果您提前不知道元素的所有值，那么可以创建一个空数组，然后再 <code>push</code> 值。<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// …</span><br>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>someValue<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// …</span><br>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>someOtherValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种方法确保数组不会被转换为 holey elements。因此，V8 可以更有效地优化数组上的任何操作。<h3 id=avoid-reading-beyond-the-length-of-the-array>避免读取超出数组的长度 <a href=#avoid-reading-beyond-the-length-of-the-array class=bookmark>#</a></h3><p>当读数超过数组的长度时，例如读取 <code>array[42]</code> 时，会发生类似的情况 <code>array.length === 5</code>。在这种情况下，数组索引 <code>42</code> 超出范围，该属性不存在于数组本身上，因此 JavaScript 引擎必须执行相同的昂贵的原型链查找。<p>不要这样写你的循环：<pre class=language-js><code class=language-js><span class="token comment">// Don’t do this!</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> item<span class="token punctuation">;</span> <span class="token punctuation">(</span>item <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token function">doSomething</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>该代码读取数组中的所有元素，然后再次读取。直到它找到一个元素为 <code>undefined</code> 或 <code>null</code> 时停止。（jQuery 在几个地方使用这种模式。）<p>相反，将你的循环写成老式的方式，只需要一直迭代到最后一个元素。<pre class=language-js><code class=language-js><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> item <span class="token operator">=</span> items<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token function">doSomething</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>当你循环的集合是可迭代的（数组和 <code>NodeList</code>），还有更好的选择：只需要使用 <code>for-of</code>。<pre class=language-js><code class=language-js><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token function">doSomething</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>对于数组，您可以使用内置的 <code>forEach</code>：<pre class=language-js><code class=language-js>items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token function">doSomething</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如今，两者的性能 <code>for-of</code> 和 <code>forEach</code> 可以和旧式的 <code>for</code> 循环相提并论。<p>避免读数超出数组的长度！这样做和数组中的洞一样糟糕。在这种情况下，V8 的边界检查失败，检查属性是否存在失败，然后我们需要查找原型链。<h3 id=avoid-elements-kind-transitions>避免元素种类转换 <a href=#avoid-elements-kind-transitions class=bookmark>#</a></h3><p>一般来说，如果您需要在数组上执行大量操作，请尝试坚持尽可能具体的元素类型，以便 V8 可以尽可能优化这些操作。<p>这比看起来更难。例如，只需给数组添加一个 <code>-0</code>，一个小整数的数组即可将其转换为 <code>PACKED_DOUBLE_ELEMENTS</code>。<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// PACKED_SMI_ELEMENTS</span><br>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// PACKED_DOUBLE_ELEMENTS</span></code></pre><p>因此，此数组上的任何操作都将以与 Smi 完全不同的方式进行优化。<p>避免 <code>-0</code>，除非你需要在代码中明确区分 <code>-0</code> 和 <code>+0</code>。（你可能并不需要）<p>同样还有 <code>NaN</code> 和 <code>Infinity</code>。它们被表示为双精度，因此添加一个 <code>NaN</code> 或 <code>Infinity</code> 会将 <code>SMI_ELEMENTS</code> 转换为<br><code>DOUBLE_ELEMENTS</code>。<pre class=language-js><code class=language-js><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// PACKED_SMI_ELEMENTS</span><br>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// PACKED_DOUBLE_ELEMENTS</span></code></pre><p>如果您计划对整数数组执行大量操作，在初始化的时候请考虑规范化 <code>-0</code>，并且防止 <code>NaN</code> 以及 <code>Infinity</code>。这样数组就会保持 <code>PACKED_SMI_ELEMENTS</code>。<p>事实上，如果你对数组进行数学运算，可以考虑使用 <code>TypedArray</code>。每个数组都有专门的元素类型。<h3 id=prefer-arrays-over-array-like-objects>类数组对象 vs 数组 <a href=#prefer-arrays-over-array-like-objects class=bookmark>#</a></h3><p>JavaScript 中的某些对象 - 特别是在 DOM 中 - 虽然它们不是真正的数组，但是他们看起来像数组。可以自己创建类数组的对象：<pre class=language-js><code class=language-js><span class="token keyword">const</span> arrayLike <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>arrayLike<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><br>arrayLike<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span><br>arrayLike<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'c'</span><span class="token punctuation">;</span><br>arrayLike<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><p>This object has a <code>length</code> and supports indexed element access (just like an array!) but it lacks array methods such as <code>forEach</code> on its prototype. It’s still possible to call array generics on it, though:<pre class=language-js><code class=language-js><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string template-punctuation">`</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> index <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> value <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string template-punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// This logs '0: a', then '1: b', and finally '2: c'.</span></code></pre><p>这个代码工作原理如下，在类数组对象上调用数组内置的 <code>Array.prototype.forEach</code>。但是，这比在真正的数组中调用 <code>forEach</code> 慢，引擎数组的 <code>forEach</code> 在 V8 中是高度优化的。如果你打算在这个对象上多次使用数组内置函数，可以考虑先把它变成一个真正的数组：<pre class=language-js><code class=language-js><span class="token keyword">const</span> actualArray <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>actualArray<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string template-punctuation">`</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> index <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> value <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string template-punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// This logs '0: a', then '1: b', and finally '2: c'.</span></code></pre><p>为了后续的优化，进行一次性转换的成本是值得的，特别是如果您计划在数组上执行大量操作。<p>例如，<code>arguments</code> 对象是类数组的对象。可以在其上调用数组内置函数，但是这样的操作将不会被完全优化，因为这些优化只针对真正的数组。<pre class=language-js><code class=language-js><span class="token keyword">const</span> <span class="token function function-variable">logArgs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string template-punctuation">`</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> index <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> value <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string template-punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token function">logArgs</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// This logs '0: a', then '1: b', and finally '2: c'.</span></code></pre><p>ES2015 的 rest 参数在这里很有帮助。它们产生真正的数组，可以优雅的代替类似数组的对象 <code>arguments</code>。<pre class=language-js><code class=language-js><span class="token keyword">const</span> <span class="token function function-variable">logArgs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  args<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string template-punctuation">`</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> index <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> value <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string template-punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token function">logArgs</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// This logs '0: a', then '1: b', and finally '2: c'.</span></code></pre><p>如今，没有理由直接使用对象 <code>arguments</code>。<p>通常，尽可能避免使用数组类对象，应该使用真正的数组。<h3 id=avoid-polymorphism>避免多态 <a href=#avoid-polymorphism class=bookmark>#</a></h3><p>如果您的代码需要处理包含多种不同元素类型的数组，则可能会比单个元素类型数组要慢，因为你的代码要对不同类型的数组元素进行多态操作。<p>考虑以下示例，其中使用了各种元素种类调用。（请注意，这不是本机 <code>Array.prototype.forEach</code>，它具有自己的一些优化，这些优化不同于本文中讨论的元素种类优化。）<pre class=language-js><code class=language-js><span class="token keyword">const</span> <span class="token function function-variable">each</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> item <span class="token operator">=</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token function">callback</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token function function-variable">doSomething</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> doSomething<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// `each` is called with `PACKED_ELEMENTS`. V8 uses an inline cache</span><br><span class="token comment">// (or “IC”) to remember that `each` is called with this particular</span><br><span class="token comment">// elements kind. V8 is optimistic and assumes that the</span><br><span class="token comment">// `array.length` and `array[index]` accesses inside the `each`</span><br><span class="token comment">// function are monomorphic (i.e. only ever receive a single kind</span><br><span class="token comment">// of elements) until proven otherwise. For every future call to</span><br><span class="token comment">// `each`, V8 checks if the elements kind is `PACKED_ELEMENTS`. If</span><br><span class="token comment">// so, V8 can re-use the previously-generated code. If not, more work</span><br><span class="token comment">// is needed.</span><br><br><span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">,</span> <span class="token number">3.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> doSomething<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// `each` is called with `PACKED_DOUBLE_ELEMENTS`. Because V8 has</span><br><span class="token comment">// now seen different elements kinds passed to `each` in its IC, the</span><br><span class="token comment">// `array.length` and `array[index]` accesses inside the `each`</span><br><span class="token comment">// function get marked as polymorphic. V8 now needs an additional</span><br><span class="token comment">// check every time `each` gets called: one for `PACKED_ELEMENTS`</span><br><span class="token comment">// (like before), a new one for `PACKED_DOUBLE_ELEMENTS`, and one for</span><br><span class="token comment">// any other elements kinds (like before). This incurs a performance</span><br><span class="token comment">// hit.</span><br><br><span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> doSomething<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// `each` is called with `PACKED_SMI_ELEMENTS`. This triggers another</span><br><span class="token comment">// degree of polymorphism. There are now three different elements</span><br><span class="token comment">// kinds in the IC for `each`. For every `each` call from now on, yet</span><br><span class="token comment">// another elements kind check is needed to re-use the generated code</span><br><span class="token comment">// for `PACKED_SMI_ELEMENTS`. This comes at a performance cost.</span></code></pre><p>内置方法（如 <code>Array.prototype.forEach</code>）可以更有效地处理这种多态性，因此在性能敏感的情况下考虑使用它们而不是用户库函数。<p>V8 中单态与多态的另一个例子涉及对象形状（object shape），也称为对象的隐藏类。要了解更多，请查看 <a href=https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html>Vyacheslav 的文章</a>。<h2 id=debugging>调试元素种类 <a href=#debugging class=bookmark>#</a></h2><p>找出一个给定的对象的“元素种类”，可以使用一个调试版本 <code>d8</code>（可以通过<a href=/docs/build>“从源代码构建”</a>的调试版本，或者使用 <a href=https://github.com/GoogleChromeLabs/jsvu><code>jsvu</code></a> 安装预编译版本），并运行：<pre class=language-bash><code class=language-bash>out/x64.debug/d8 --allow-natives-syntax</code></pre><p>这将打开 <code>d8</code> REPL 中的<a href="https://cs.chromium.org/chromium/src/v8/src/runtime/runtime.h?l=20&rcl=05720af2b09a18be5c41bbf224a58f3f0618f6be">特殊函数</a>，如 <code>%DebugPrint(object)</code>。输出中的“元素”字段显示您传递给它的任何对象的“元素种类”。<pre class=language-js><code class=language-js>d8<span class="token operator">></span> <span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token function">DebugPrint</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><br>DebugPrint<span class="token operator">:</span> <span class="token number">0x1fbbad30fd71</span><span class="token operator">:</span> <span class="token punctuation">[</span>JSArray<span class="token punctuation">]</span><br> <span class="token operator">-</span> map <span class="token operator">=</span> <span class="token number">0x10a6f8a038b1</span> <span class="token punctuation">[</span>FastProperties<span class="token punctuation">]</span><br> <span class="token operator">-</span> prototype <span class="token operator">=</span> <span class="token number">0x1212bb687ec1</span><br> <span class="token operator">-</span> elements <span class="token operator">=</span> <span class="token number">0x1fbbad30fd19</span> <span class="token operator">&lt;</span>FixedArray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token constant">PACKED_SMI_ELEMENTS</span> <span class="token punctuation">(</span><span class="token constant">COW</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br> <span class="token operator">-</span> length <span class="token operator">=</span> <span class="token number">3</span><br> <span class="token operator">-</span> properties <span class="token operator">=</span> <span class="token number">0x219eb0702241</span> <span class="token operator">&lt;</span>FixedArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">{</span><br>    #length<span class="token operator">:</span> <span class="token number">0x219eb0764ac9</span> <span class="token operator">&lt;</span>AccessorInfo<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">const</span> accessor descriptor<span class="token punctuation">)</span><br> <span class="token punctuation">}</span><br> <span class="token operator">-</span> elements<span class="token operator">=</span> <span class="token number">0x1fbbad30fd19</span> <span class="token operator">&lt;</span>FixedArray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">{</span><br>           <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span><br>           <span class="token number">1</span><span class="token operator">:</span> <span class="token number">2</span><br>           <span class="token number">2</span><span class="token operator">:</span> <span class="token number">3</span><br> <span class="token punctuation">}</span><br><span class="token punctuation">[</span>…<span class="token punctuation">]</span></code></pre><p>请注意，“COW” 表示<a href=https://en.wikipedia.org/wiki/Copy-on-write>写时复制</a>，这是另一个内部优化。现在不要担心 - 这是另一个博文的主题！<p>调试版本中可用的另一个有用的标志是 <code>--trace-elements-transitions</code>。启用它让 V8 在任何元素发生类型转换时通知您。<pre class=language-bash><code class=language-bash>$ <span class="token function">cat</span> my-script.js<br>const array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4.56</span><span class="token punctuation">;</span><br><br>$ out/x64.debug/d8 --trace-elements-transitions my-script.js<br>elements transition <span class="token punctuation">[</span>PACKED_SMI_ELEMENTS -<span class="token operator">></span> PACKED_DOUBLE_ELEMENTS<span class="token punctuation">]</span> <span class="token keyword">in</span> ~+34 at x.js:2 <span class="token keyword">for</span> 0x1df87228c911 <span class="token operator">&lt;</span>JSArray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> from 0x1df87228c889 <span class="token operator">&lt;</span>FixedArray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> to 0x1df87228c941 <span class="token operator">&lt;</span>FixedDoubleArray<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token operator">></span></code></pre></div><footer><div><picture><source srcset="/_img/avatars/mathias-bynens.avif, /_img/avatars/mathias-bynens@2x.avif 2x" type=image/avif><img alt="" height=96 src=/_img/avatars/mathias-bynens.jpg width=96 loading=lazy srcset="/_img/avatars/mathias-bynens@2x.jpg 2x"></picture><p>作者：Mathias Bynens (<a href=https://twitter.com/mathias>@mathias</a>).</div><a href=https://twitter.com/v8js/status/907608362191376384 class=retweet>Retweet this article!</a></footer><footer><div><img alt="" height=96 src=/_img/avatars/justjavac.jpg width=96 srcset="/_img/avatars/justjavac@2x.jpg 2x" lazyload=on><p>译者：迷渡 (<a href=https://github.com/justjavac>@justjavac</a>)，V8.js.cn 站长.</div></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/elements-kinds>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/elements-kinds.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>