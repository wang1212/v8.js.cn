<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Super fast super property access · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Faster super property access in V8 v9.0" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Super fast <code>super</code> property access</h1><p class=meta>发布时间 <time datetime="2021-02-18 00:00:00" itemprop=datePublished title="2021-02-18 00:00:00">2021-02-18</time> · 标签： <a href=/blog/tags/javascript/ class=tag>JavaScript</a></header><div itemprop=articleBody><p>The <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super><code>super</code> keyword</a> can be used for accessing properties and functions on an object’s parent.<p>Previously, accessing a super property (like <code>super.x</code>) was implemented via a runtime call. Starting from V8 v9.0, we reuse the <a href=https://mathiasbynens.be/notes/shapes-ics>inline cache (IC) system</a> in non-optimized code and generate the proper optimized code for super property access, without having to jump to the runtime.<p>As you can see from the graphs below, super property access used to be an order of magnitude slower than normal property access because of the runtime call. Now we’re much closer to being on par.<figure><img alt="" height=371 loading=lazy src=/_img/fast-super/super-opt.svg width=600><figcaption>Compare super property access to regular property access, optimized</figcaption></figure><figure><img alt="" height=371 loading=lazy src=/_img/fast-super/super-no-opt.svg width=600><figcaption>Compare super property access to regular property access, unoptimized</figcaption></figure><p>Super property access is difficult to benchmark, since it must happen inside a function. We can’t benchmark individual property accesses, but only bigger chunks of work. Thus the function call overhead is included in the measurement. The above graphs somewhat underestimate the difference between super property access and normal property access, but they’re accurate enough for demonstrating the difference between the old and new super property access.<p>In the unoptimized (interpreted) mode, super property access will always be slower than normal property access, since we need to do more loads (reading the home object from the context and reading the <code>__proto__</code> from the home object). In the optimized code, we already embed the home object as a constant whenever possible. This could be further improved by embedding its <code>__proto__</code> as a constant too.<h3 id=prototypal-inheritance-and-super>Prototypal inheritance and <code>super</code> <a href=#prototypal-inheritance-and-super class=bookmark>#</a></h3><p>Let’s start from the basics - what does super property access even mean?<pre class=language-javascript><code class=language-javascript><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><br><span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><br><br><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><br>  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>b<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Now <code>A</code> is the super class of <code>B</code> and <code>b.m()</code> returns <code>100</code> as you’d expect.<figure><img alt="" height=147 loading=lazy src=/_img/fast-super/inheritance-1.svg width=100><figcaption>Class inheritance diagram</figcaption></figure><p>The reality of <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain>JavaScript’s prototypal inheritance</a> is more complicated:<figure><img alt="" height=284 loading=lazy src=/_img/fast-super/inheritance-2.svg width=435><figcaption>Prototypal inheritance diagram</figcaption></figure><p>We need to distinguish carefully between the <code>__proto__</code> and <code>prototype</code> properties - they don’t mean the same thing! To make it more confusing, the object <code>b.__proto__</code> is often referred to as "<code>b</code>’s prototype".<p><code>b.__proto__</code> is the object from which <code>b</code> inherits properties. <code>B.prototype</code> is the object which will be the <code>__proto__</code> of objects created with <code>new B()</code>, that is <code>b.__proto__ === B.prototype</code>.<p>In turn, <code>B.prototype</code> has its own <code>__proto__</code> property that equals to <code>A.prototype</code>. Together, this forms what’s called a prototype chain:<pre><code>b ->
 b.__proto__ === B.prototype ->
  B.prototype.__proto__ === A.prototype ->
   A.prototype.__proto__ === Object.prototype ->
    Object.prototype.__proto__ === null
</code></pre><p>Through this chain, <code>b</code> can access all properties defined in any of those objects. The method <code>m</code> is a property of <code>B.prototype</code> — <code>B.prototype.m</code> — and this is why <code>b.m()</code> works.<p>Now we can define <code>super.x</code> inside <code>m</code> as a property lookup where we start looking for the property <code>x</code> in the <em>home object’s</em> <code>__proto__</code> and walk up the prototype chain until we find it.<p>The home object is the object where the method is defined - in this case the home object for <code>m</code> is <code>B.prototype</code>. Its <code>__proto__</code> is <code>A.prototype</code>, so that’s where we start looking for the property <code>x</code>. We’ll call <code>A.prototype</code> the <em>lookup start object</em>. In this case we find the property <code>x</code> immediately in the lookup start object, but in general it might also be somewhere further up the prototype chain.<p>If <code>B.prototype</code> had a property called <code>x</code>, we’d ignore it, since we start looking for it above it in the prototype chain. Also, in this case super property lookup doesn’t depend on the <em>receiver</em> - the object that is the <code>this</code> value when calling the method.<pre class=language-javascript><code class=language-javascript><span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>some_other_object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// still returns 100</span></code></pre><p>If the property has a getter though, the receiver will be passed to the getter as the <code>this</code> value.<p>To summarize: in a super property access, <code>super.x</code>, the lookup start object is the <code>__proto__</code> of the home object and the receiver is the receiver of the method where the super property access occurs.<p>In a normal property access, <code>o.x</code>, we start looking for the property <code>x</code> in <code>o</code> and walk up the prototype chain. We’ll also use <code>o</code> as the receiver if <code>x</code> happens to have a getter - the lookup start object and the receiver are the same object (<code>o</code>).<p><em>Super property access is just like regular property access where the lookup start object and the receiver are different.</em><h3 id=implementing-faster-super>Implementing faster <code>super</code> <a href=#implementing-faster-super class=bookmark>#</a></h3><p>The above realization is also the key for implementing fast super property access. V8 is already engineered to make property access fast - now we generalized it for the case where the receiver and the lookup start object differ.<p>V8’s data-driven inline cache system is the core part for implementing fast property access. You can read about it in <a href=https://mathiasbynens.be/notes/shapes-ics>the high-level introduction</a> linked above, or the more detailed descriptions of <a href=https://v8.dev/blog/fast-properties>V8’s object representation</a> and <a href="https://docs.google.com/document/d/1mEhMn7dbaJv68lTAvzJRCQpImQoO6NZa61qRimVeA-k/edit?usp=sharing">how V8’s data-driven inline cache system is implemented</a>.<p>To speed up <code>super</code>, we’ve added a new <a href=https://v8.dev/docs/ignition>Ignition</a> bytecode, <code>LdaNamedPropertyFromSuper</code>, which enables us to plug into the IC system in the interpreted mode and also generate optimized code for super property access.<p>With the new byte code, we can add a new IC, <code>LoadSuperIC</code>, for speeding up super property loads. Similar to <code>LoadIC</code> which handles normal property loads, <code>LoadSuperIC</code> keeps track of the shapes of the lookup start objects it has seen and remembers how to load properties from objects which have one of those shapes.<p><code>LoadSuperIC</code> reuses the existing IC machinery for property loads, just with a different lookup start object. As the IC layer already distinguished between the lookup start object and the receiver, the implementation should’ve been easy. But as the lookup start object and the receiver were always the same, there were bugs where we’d use the lookup start object even though we meant the receiver, and vice versa. Those bugs have been fixed and we now properly support cases where the lookup start object and the receiver differ.<p>Optimized code for super property access is generated by the <code>JSNativeContextSpecialization</code> phase of the <a href=https://v8.dev/docs/turbofan>TurboFan</a> compiler. The implementation generalizes the existing property lookup machinery (<a href="https://source.chromium.org/chromium/chromium/src/+/master:v8/src/compiler/js-native-context-specialization.cc;l=1130"><code>JSNativeContextSpecialization::ReduceNamedAccess</code></a>) to handle the case where the receiver and the lookup start object differ.<p>The optimized code got even more optimal when we moved the home object out of the <code>JSFunction</code> where it was stored. It’s now stored in the class context, which makes TurboFan embed it into the optimized code as a constant whenever possible.<h2 id=other-usages-of-super>Other usages of <code>super</code> <a href=#other-usages-of-super class=bookmark>#</a></h2><p><code>super</code> inside object literal methods works just like inside class methods, and is optimized similarly.<pre class=language-javascript><code class=language-javascript><span class="token keyword">const</span> myproto <span class="token operator">=</span> <span class="token punctuation">{</span><br>  __proto__<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">'x'</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> __proto__<span class="token operator">:</span> myproto <span class="token punctuation">}</span><span class="token punctuation">;</span><br>o<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 100</span></code></pre><p>There are of course corner cases which we didn’t optimize for. For example, writing super properties (<code>super.x = ...</code>) is not optimized. In addition, using mixins turns the access site megamorphic, leading into slower super property access:<pre class=language-javascript><code class=language-javascript><span class="token keyword">function</span> <span class="token function">createMixin</span><span class="token punctuation">(</span><span class="token parameter">base</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">class</span> <span class="token class-name">Mixin</span> <span class="token keyword">extends</span> <span class="token class-name">base</span> <span class="token punctuation">{</span><br>    <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br>    <span class="token comment">//                ^ this access site is megamorphic</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> Mixin<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><br>  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> myClass <span class="token operator">=</span> <span class="token function">createMixin</span><span class="token punctuation">(</span><br>  <span class="token function">createMixin</span><span class="token punctuation">(</span><br>    <span class="token function">createMixin</span><span class="token punctuation">(</span><br>      <span class="token function">createMixin</span><span class="token punctuation">(</span><br>        <span class="token function">createMixin</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><br>      <span class="token punctuation">)</span><br>    <span class="token punctuation">)</span><br>  <span class="token punctuation">)</span><br><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">myClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>There’s still work to be done to ensure all object-oriented patterns are as speedy as they can be - stay tuned for further optimizations!</div><footer><div><picture><source srcset="/_img/avatars/marja-holtta.avif, /_img/avatars/marja-holtta@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/marja-holtta.jpg width=96 srcset="/_img/avatars/marja-holtta@2x.jpg 2x"></picture><p>作者：<a href=https://twitter.com/marjakh>Marja Hölttä</a>, super optimizer.</div><a href=https://twitter.com/v8js/status/1362465295848333316 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/fast-super>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/fast-super.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>