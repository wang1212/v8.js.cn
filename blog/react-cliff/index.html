<!doctype html><html lang=zh-CN><meta charset=utf-8><title>The story of a V8 performance cliff in React · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="This article describes how V8 chooses optimal in-memory representations for various JavaScript values, and how that impacts the shape machinery — all of which helps explain a recent V8 performance cliff in React core." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>The story of a V8 performance cliff in React</h1><p class=meta>发布时间 <time datetime="2019-08-28 16:45:00" itemprop=datePublished title="2019-08-28 16:45:00">2019-08-28</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a> <a href=/blog/tags/presentations/ class=tag>presentations</a></header><div itemprop=articleBody><p><a href=https://mathiasbynens.be/notes/shapes-ics>Previously</a>, we discussed how JavaScript engines optimize object and array access through the use of Shapes and Inline Caches, and we’ve explored <a href=https://mathiasbynens.be/notes/prototypes>how engines speed up prototype property access</a> in particular. This article describes how V8 chooses optimal in-memory representations for various JavaScript values, and how that impacts the shape machinery — all of which helps explain <a href=https://github.com/facebook/react/issues/14365>a recent V8 performance cliff in React core</a>.<div class=note><p><strong>Note:</strong> If you prefer watching a presentation over reading articles, then enjoy the video below! If not, skip the video and read on.</div><figure><div class="video video-16:9"><iframe allowfullscreen height=360 loading=lazy src=https://www.youtube.com/embed/0I0d8LkDqyc width=640></iframe></div><figcaption><a href="https://www.youtube.com/watch?v=0I0d8LkDqyc">“JavaScript engine fundamentals: the good, the bad, and the ugly”</a> as presented by Mathias Bynens and Benedikt Meurer at AgentConf 2019.</figcaption></figure><h2 id=javascript-types>JavaScript types <a href=#javascript-types class=bookmark>#</a></h2><p>Every JavaScript value has exactly one of (currently) eight different types: <code>Number</code>, <code>String</code>, <code>Symbol</code>, <code>BigInt</code>, <code>Boolean</code>, <code>Undefined</code>, <code>Null</code>, and <code>Object</code>.<figure><img alt="" height=497 loading=lazy src=/_img/react-cliff/01-javascript-types.svg width=913></figure><p>With one notable exception, these types are observable in JavaScript through the <code>typeof</code> operator:<pre class=language-js><code class=language-js><span class="token keyword">typeof</span> <span class="token number">42</span><span class="token punctuation">;</span><br><span class="token comment">// → 'number'</span><br><span class="token keyword">typeof</span> <span class="token string">'foo'</span><span class="token punctuation">;</span><br><span class="token comment">// → 'string'</span><br><span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → 'symbol'</span><br><span class="token keyword">typeof</span> <span class="token number">42n</span><span class="token punctuation">;</span><br><span class="token comment">// → 'bigint'</span><br><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br><span class="token comment">// → 'boolean'</span><br><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span><br><span class="token comment">// → 'undefined'</span><br><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br><span class="token comment">// → 'object' 🤔</span><br><span class="token keyword">typeof</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token comment">// → 'object'</span></code></pre><p><code>typeof null</code> returns <code>'object'</code>, and not <code>'null'</code>, despite <code>Null</code> being a type of its own. To understand why, consider that the set of all JavaScript types is divided into two groups:<ul><li><em>objects</em> (i.e. the <code>Object</code> type)<li><em>primitives</em> (i.e. any non-object value)</ul><p>As such, <code>null</code> means “no object value”, whereas <code>undefined</code> means “no value”.<figure><img alt="" height=384 loading=lazy src=/_img/react-cliff/02-primitives-objects.svg width=960></figure><p>Following this line of thought, Brendan Eich designed JavaScript to make <code>typeof</code> return <code>'object'</code> for all values on the right-hand side, i.e. all objects and <code>null</code> values, in the spirit of Java. That’s why <code>typeof null === 'object'</code> despite the spec having a separate <code>Null</code> type.<figure><img alt="" height=384 loading=lazy src=/_img/react-cliff/03-primitives-objects-typeof.svg width=960></figure><h2 id=value-representation>Value representation <a href=#value-representation class=bookmark>#</a></h2><p>JavaScript engines must be able to represent arbitrary JavaScript values in memory. However, it’s important to note that the JavaScript type of a value is separate from how JavaScript engines represent that value in memory.<p>The value <code>42</code>, for example, has type <code>number</code> in JavaScript.<pre class=language-js><code class=language-js><span class="token keyword">typeof</span> <span class="token number">42</span><span class="token punctuation">;</span><br><span class="token comment">// → 'number'</span></code></pre><p>There are several ways to represent an integer number like <code>42</code> in memory:<div class=table-wrapper><table><thead><tr><th>representation<th>bits<tbody><tr><td>two’s complement 8-bit<td><code>0010 1010</code><tr><td>two’s complement 32-bit<td><code>0000 0000 0000 0000 0000 0000 0010 1010</code><tr><td>packed binary-coded decimal (BCD)<td><code>0100 0010</code><tr><td>32-bit IEEE-754 floating-point<td><code>0100 0010 0010 1000 0000 0000 0000 0000</code><tr><td>64-bit IEEE-754 floating-point<td><code>0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code></table></div><p>ECMAScript standardizes numbers as 64-bit floating-point values, also known as <em>double precision floating-point</em> or <em>Float64</em>. However, that doesn’t mean that JavaScript engines store numbers in Float64 representation all the time — doing so would be terribly inefficient! Engines can choose other internal representations, as long as the observable behavior matches Float64 exactly.<p>Most numbers in real-world JavaScript applications happen to be <a href=https://tc39.es/ecma262/#array-index>valid ECMAScript array indices</a>, i.e. integer values in the range from 0 to 2³²−2.<pre class=language-js><code class=language-js>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Smallest possible array index.</span><br>array<span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>array<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Greatest possible array index.</span></code></pre><p>JavaScript engines can choose an optimal in-memory representation for such numbers to optimize code that accesses array elements by index. For the processor to do the memory access operation, the array index must be available in <a href=https://en.wikipedia.org/wiki/Two%27s_complement>two’s complement</a>. Representing array indices as Float64 instead would be wasteful, as the engine would then have to convert back and forth between Float64 and two’s complement every time someone accesses an array element.<p>The 32-bit two’s complement representation is not just useful for array operations. In general, <strong>processors execute integer operations much faster than floating-point operations</strong>. That’s why in the next example, the first loop is easily twice as fast compared to the second loop.<pre class=language-js><code class=language-js><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// fast 🚀</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000.1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// slow 🐌</span><br><span class="token punctuation">}</span></code></pre><p>The same goes for operations as well. The performance of the modulo operator in the next piece of code depends on whether you’re dealing with integers or not.<pre class=language-js><code class=language-js><span class="token keyword">const</span> remainder <span class="token operator">=</span> value <span class="token operator">%</span> divisor<span class="token punctuation">;</span><br><span class="token comment">// Fast 🚀 if `value` and `divisor` are represented as integers,</span><br><span class="token comment">// slow 🐌 otherwise.</span></code></pre><p>If both operands are represented as integers, the CPU can compute the result very efficiently. V8 has additional fast-paths for the cases where the <code>divisor</code> is a power of two. For values represented as floats, the computation is much more complex and takes a lot longer.<p>Because integer operations generally execute much faster than floating-point operations, It would seem that engines could just always use two’s complement for all integers and all results of integer operations. Unfortunately, that would be a violation of the ECMAScript specification! ECMAScript standardizes on Float64, and so <strong>certain integer operations actually produce floats</strong>. It’s important that JS engines produce the correct results in such cases.<pre class=language-js><code class=language-js><span class="token comment">// Float64 has a safe integer range of 53 bits. Beyond that range,</span><br><span class="token comment">// you must lose precision.</span><br><span class="token number">2</span><span class="token operator">**</span><span class="token number">53</span> <span class="token operator">===</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">53</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><br><span class="token comment">// → true</span><br><br><span class="token comment">// Float64 supports negative zeros, so -1 * 0 must be -0, but</span><br><span class="token comment">// there’s no way to represent negative zero in two’s complement.</span><br><span class="token operator">-</span><span class="token number">1</span><span class="token operator">*</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">;</span><br><span class="token comment">// → true</span><br><br><span class="token comment">// Float64 has infinities which can be produced through division</span><br><span class="token comment">// by zero.</span><br><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token number">Infinity</span><span class="token punctuation">;</span><br><span class="token comment">// → true</span><br><span class="token operator">-</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">;</span><br><span class="token comment">// → true</span><br><br><span class="token comment">// Float64 also has NaNs.</span><br><span class="token number">0</span><span class="token operator">/</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token number">NaN</span><span class="token punctuation">;</span></code></pre><p>Even though the values on the left-hand side are integers, all the values on the right are floats. This is why none of the above operations can be performed correctly using 32-bit two’s complement. JavaScript engines have to take special care to make sure that integer operations fall back appropriately to produce the fancy Float64 results.<p>For small integers in the 31-bit signed integer range, V8 uses a special representation called <code>Smi</code>. Anything that is not a <code>Smi</code> is represented as a <code>HeapObject</code>, which is the address of some entity in memory. For numbers, we use a special kind of <code>HeapObject</code>, the so-called <code>HeapNumber</code>, to represent numbers that aren’t inside the <code>Smi</code> range.<pre class=language-js><code class=language-js> <span class="token operator">-</span><span class="token number">Infinity</span> <span class="token comment">// HeapNumber</span><br><span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// HeapNumber</span><br>  <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token comment">// Smi</span><br>       <span class="token operator">-</span><span class="token number">42</span> <span class="token comment">// Smi</span><br>        <span class="token operator">-</span><span class="token number">0</span> <span class="token comment">// HeapNumber</span><br>         <span class="token number">0</span> <span class="token comment">// Smi</span><br>       <span class="token number">4.2</span> <span class="token comment">// HeapNumber</span><br>        <span class="token number">42</span> <span class="token comment">// Smi</span><br>   <span class="token number">2</span><span class="token operator">**</span><span class="token number">30</span><span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// Smi</span><br>     <span class="token number">2</span><span class="token operator">**</span><span class="token number">30</span> <span class="token comment">// HeapNumber</span><br>  <span class="token number">Infinity</span> <span class="token comment">// HeapNumber</span><br>       <span class="token number">NaN</span> <span class="token comment">// HeapNumber</span></code></pre><p>As the above example shows, some JavaScript numbers are represented as <code>Smi</code>s, and others are represented as <code>HeapNumber</code>s. V8 is specifically optimized for <code>Smi</code>s, because small integers are so common in real-world JavaScript programs. <code>Smi</code>s don’t need to be allocated as dedicated entities in memory, and enable fast integer operations in general.<p>The important take-away here is that <strong>even values with the same JavaScript type can be represented in completely different ways</strong> behind the scenes, as an optimization.<h3 id=smi-heapnumber-mutableheapnumber><code>Smi</code> vs. <code>HeapNumber</code> vs. <code>MutableHeapNumber</code> <a href=#smi-heapnumber-mutableheapnumber class=bookmark>#</a></h3><p>Here’s how that works under the hood. Let’s say you have the following object:<pre class=language-js><code class=language-js><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><br>  x<span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">,</span>  <span class="token comment">// Smi</span><br>  y<span class="token operator">:</span> <span class="token number">4.2</span><span class="token punctuation">,</span> <span class="token comment">// HeapNumber</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>The value <code>42</code> for <code>x</code> can be encoded as <code>Smi</code>, so it can be stored inside of the object itself. The value <code>4.2</code> on the other hand needs a separate entity to hold the value, and the object points to that entity.<figure><img alt="" height=287 loading=lazy src=/_img/react-cliff/04-smi-vs-heapnumber.svg width=960></figure><p>Now, let’s say we run the following JavaScript snippet:<pre class=language-js><code class=language-js>o<span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span><br><span class="token comment">// → o.x is now 52</span><br>o<span class="token punctuation">.</span>y <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token comment">// → o.y is now 5.2</span></code></pre><p>In this case, the value of <code>x</code> can be updated in-place, since the new value <code>52</code> also fits the <code>Smi</code> range.<figure><img alt="" height=301 loading=lazy src=/_img/react-cliff/05-update-smi.svg width=960></figure><p>However, the new value of <code>y=5.2</code> does not fit into a <code>Smi</code> and is also different from the previous value <code>4.2</code>, so V8 has to allocate a new <code>HeapNumber</code> entity for the assignment to <code>y</code>.<figure><img alt="" height=375 loading=lazy src=/_img/react-cliff/06-update-heapnumber.svg width=960></figure><p><code>HeapNumber</code>s are not mutable, which enables certain optimizations. For example, if we assign <code>y</code>s value to <code>x</code>:<pre class=language-js><code class=language-js>o<span class="token punctuation">.</span>x <span class="token operator">=</span> o<span class="token punctuation">.</span>y<span class="token punctuation">;</span><br><span class="token comment">// → o.x is now 5.2</span></code></pre><p>…we can now just link to the same <code>HeapNumber</code> instead of allocating a new one for the same value.<figure><img alt="" height=411 loading=lazy src=/_img/react-cliff/07-heapnumbers.svg width=960></figure><p>One downside to <code>HeapNumber</code>s being immutable is that it would be slow to update fields with values outside the <code>Smi</code> range often, like in the following example:<pre class=language-js><code class=language-js><span class="token comment">// Create a `HeapNumber` instance.</span><br><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0.1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// Create an additional `HeapNumber` instance.</span><br>  o<span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The first line would create a <code>HeapNumber</code> instance with the initial value <code>0.1</code>. The loop body changes this value to <code>1.1</code>, <code>2.1</code>, <code>3.1</code>, <code>4.1</code>, and finally <code>5.1</code>, creating a total of six <code>HeapNumber</code> instances along the way, five of which are garbage once the loop finishes.<figure><img alt="" height=432 loading=lazy src=/_img/react-cliff/08-garbage-heapnumbers.svg width=960></figure><p>To avoid this problem, V8 provides a way to update non-<code>Smi</code> number fields in-place as well, as an optimization. When a numeric field holds values outside the <code>Smi</code> range, V8 marks that field as a <code>Double</code> field on the shape, and allocates a so-called <code>MutableHeapNumber</code> that holds the actual value encoded as Float64.<figure><img alt="" height=518 loading=lazy src=/_img/react-cliff/09-mutableheapnumber.svg width=960></figure><p>When your field’s value changes, V8 no longer needs to allocate a new <code>HeapNumber</code>, but instead can just update the <code>MutableHeapNumber</code> in-place.<figure><img alt="" height=500 loading=lazy src=/_img/react-cliff/10-update-mutableheapnumber.svg width=960></figure><p>However, there’s a catch to this approach as well. Since the value of a <code>MutableHeapNumber</code> can change, it’s important that these are not passed around.<figure><img alt="" height=513 loading=lazy src=/_img/react-cliff/11-mutableheapnumber-to-heapnumber.svg width=960></figure><p>For example, if you assign <code>o.x</code> to some other variable <code>y</code>, you wouldn’t want the value of <code>y</code> to change the next time <code>o.x</code> changes — that would be a violation of the JavaScript spec! So when <code>o.x</code> is accessed, the number must be <em>re-boxed</em> into a regular <code>HeapNumber</code> before assigning it to <code>y</code>.<p>For floats, V8 performs all the above-mentioned “boxing” magic behind the scenes. But for small integers it would be wasteful to go with the <code>MutableHeapNumber</code> approach, since <code>Smi</code> is a more efficient representation.<pre class=language-js><code class=language-js><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token comment">// → no “boxing” for `x` in object</span><br><br>object<span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token comment">// → update the value of `x` inside object</span></code></pre><p>To avoid the inefficiency, all we have to do for small integers is mark the field on the shape as <code>Smi</code> representation, and simply update the number value in place as long as it fits the small integer range.<figure><img alt="" height=424 loading=lazy src=/_img/react-cliff/12-smi-no-boxing.svg width=960></figure><h2 id=shape-deprecations-and-migrations>Shape deprecations and migrations <a href=#shape-deprecations-and-migrations class=bookmark>#</a></h2><p>So what if a field initially contains a <code>Smi</code>, but later holds a number outside the small integer range? Like in this case, with two objects both using the same shape where <code>x</code> is represented as <code>Smi</code> initially:<pre class=language-js><code class=language-js><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token comment">// → objects have `x` as `Smi` field now</span><br><br>b<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0.2</span><span class="token punctuation">;</span><br><span class="token comment">// → `b.x` is now represented as a `Double`</span><br><br>y <span class="token operator">=</span> a<span class="token punctuation">.</span>x<span class="token punctuation">;</span></code></pre><p>This starts out with two objects pointing to the same shape, where <code>x</code> is marked as <code>Smi</code> representation:<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/13-shape.svg width=960></figure><p>When <code>b.x</code> changes to <code>Double</code> representation, V8 allocates a new shape where <code>x</code> is assigned <code>Double</code> representation, and which points back to the empty shape. V8 also allocates a <code>MutableHeapNumber</code> to hold the new value <code>0.2</code> for the <code>x</code> property. Then we update the object <code>b</code> to point to this new shape, and change the slot in the object to point to the previously allocated <code>MutableHeapNumber</code> at offset 0. And finally, we mark the old shape as deprecated and unlink it from the transition tree. This is done by having a new transition for <code>'x'</code> from the empty shape to the newly-created shape.<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/14-shape-transition.svg width=960></figure><p>We cannot completely remove the old shape at this point, since it is still used by <code>a</code>, and it would be way too expensive to traverse the memory to find all objects pointing to the old shape and update them eagerly. Instead V8 does this lazily: any property access or assignment to <code>a</code> migrates it to the new shape first. The idea is to eventually make the deprecated shape unreachable and to have the garbage collector remove it.<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/15-shape-deprecation.svg width=960></figure><p>A trickier case occurs if the field that changes representation is <em>not</em> the last one in the chain:<pre class=language-js><code class=language-js><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><br>  x<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span><br>  y<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><br>  z<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>o<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span></code></pre><p>In that case V8 needs to find the so-called <em>split shape</em>, which is the last shape in the chain before the relevant property gets introduced. Here we’re changing <code>y</code>, so we need to find the last shape that doesn't have <code>y</code>, which in our example is the shape that introduced <code>x</code>.<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/16-split-shape.svg width=960></figure><p>Starting from the split shape, we create a new transition chain for <code>y</code> which replays all the previous transitions, but with <code>'y'</code> being marked as <code>Double</code> representation. And we use this new transition chain for <code>y</code>, marking the old subtree as deprecated. In the last step we migrate the instance <code>o</code> to the new shape, using a <code>MutableHeapNumber</code> to hold the value of <code>y</code> now. This way, new objects do not take the old path, and once all references to the old shape are gone, the deprecated shape part of the tree disappears.<h2 id=extensibility-and-integrity-level-transitions>Extensibility and integrity-level transitions <a href=#extensibility-and-integrity-level-transitions class=bookmark>#</a></h2><p><code>Object.preventExtensions()</code> prevents new properties from ever being added to an object. If you try, it throws an exception. (If you’re not in strict mode, it doesn’t throw but it silently does nothing.)<pre class=language-js><code class=language-js><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span><br>object<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><br><span class="token comment">// TypeError: Cannot add property y;</span><br><span class="token comment">//            object is not extensible</span></code></pre><p><code>Object.seal</code> does the same as <code>Object.preventExtensions</code>, but it also marks all properties as non-configurable, meaning you can’t delete them, or change their enumerability, configurability, or writability.<pre class=language-js><code class=language-js><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>Object<span class="token punctuation">.</span><span class="token function">seal</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span><br>object<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><br><span class="token comment">// TypeError: Cannot add property y;</span><br><span class="token comment">//            object is not extensible</span><br><span class="token keyword">delete</span> object<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br><span class="token comment">// TypeError: Cannot delete property x</span></code></pre><p><code>Object.freeze</code> does the same as <code>Object.seal</code>, but it also prevents the values of existing properties from being changed by marking them non-writable.<pre class=language-js><code class=language-js><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span><br>object<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><br><span class="token comment">// TypeError: Cannot add property y;</span><br><span class="token comment">//            object is not extensible</span><br><span class="token keyword">delete</span> object<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br><span class="token comment">// TypeError: Cannot delete property x</span><br>object<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><br><span class="token comment">// TypeError: Cannot assign to read-only property x</span></code></pre><p>Let’s consider this concrete example, with two objects which both have a single property <code>x</code>, and where we then prevent any further extensions to the second object.<pre class=language-js><code class=language-js><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>It starts out like we already know, transitioning from the empty shape to a new shape that holds the property <code>'x'</code> (represented as <code>Smi</code>). When we prevent extensions to <code>b</code>, we perform a special transition to a new shape which is marked as non-extensible. This special transition doesn’t introduce any new property — it’s really just a marker.<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/17-shape-nonextensible.svg width=960></figure><p>Note how we can’t just update the shape with <code>x</code> in-place, since that is needed by the other object <code>a</code>, which is still extensible.<h2 id=react>The React performance issue <a href=#react class=bookmark>#</a></h2><p>Let’s put it all together and use what we learned to understand <a href=https://github.com/facebook/react/issues/14365>the recent React issue #14365</a>. When the React team profiled a real-world application, they spotted an odd V8 performance cliff that affected React’s core. Here’s a simplified repro for the bug:<pre class=language-js><code class=language-js><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><br>o<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0.2</span><span class="token punctuation">;</span></code></pre><p>We have an object with two fields that have <code>Smi</code> representation. We prevent any further extensions to the object, and eventually force the second field to <code>Double</code> representation.<p>As we learned before, this creates roughly the following setup:<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/18-repro-shape-setup.svg width=960></figure><p>Both properties are marked as <code>Smi</code> representation, and the final transition is the extensibility transition to mark the shape as non-extensible.<p>Now we need to change <code>y</code> to <code>Double</code> representation, which means we need to again start by finding the split shape. In this case, it’s the shape that introduced <code>x</code>. But now V8 got confused, since the split shape was extensible while the current shape was marked as non-extensible. And V8 didn’t really know how to replay the transitions properly in this case. So V8 essentially just gave up trying to make sense of this, and instead created a separate shape that is not connected to the existing shape tree and not shared with any other objects. Think of it as an <em>orphaned shape</em>:<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/19-orphaned-shape.svg width=960></figure><p>You can imagine it’s pretty bad if this happens to lots of objects, since that renders the whole shape system useless.<p>In the case of React, here’s what happened: each <code>FiberNode</code> has a couple of fields that are supposed to hold timestamps when profiling is turned on.<pre class=language-js><code class=language-js><span class="token keyword">class</span> <span class="token class-name">FiberNode</span> <span class="token punctuation">{</span><br>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>actualStartTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>    Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FiberNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FiberNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>These fields (such as <code>actualStartTime</code>) are initialized with <code>0</code> or <code>-1</code>, and thus start out with <code>Smi</code> representation. But later, actual floating-point timestamps from <a href=https://w3c.github.io/hr-time/#dom-performance-now><code>performance.now()</code></a> are stored in these fields, causing them to go to <code>Double</code> representation, since they don’t fit into a <code>Smi</code>. On top of that, React also prevents extensions to <code>FiberNode</code> instances.<p>Initially the simplified example above looked like this:<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/20-fibernode-shape.svg width=960></figure><p>There are two instances sharing a shape tree, all working as intended. But then, as you store the real timestamp, V8 gets confused finding the split shape:<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/21-orphan-islands.svg width=960></figure><p>V8 assigns a new orphaned shape to <code>node1</code>, and the same thing happens to <code>node2</code> some time later, resulting in two <em>orphan islands</em>, each with their own disjoint shapes. Many real-world React apps don’t just have two, but rather tens of thousands of these <code>FiberNode</code>s. As you can imagine, this situation was not particularly great for V8’s performance.<p>Luckily, <a href=https://chromium-review.googlesource.com/c/v8/v8/+/1442640/ >we’ve fixed this performance cliff</a> in <a href=/blog/v8-release-74>V8 v7.4</a>, and we’re <a href=https://bit.ly/v8-in-place-field-representation-changes>looking into making field representation changes cheaper</a> to remove any remaining performance cliffs. With the fix, V8 now does the right thing:<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/22-fix.svg width=960></figure><p>The two <code>FiberNode</code> instances point to the non-extensible shape where <code>'actualStartTime'</code> is a <code>Smi</code> field. When the first assignment to <code>node1.actualStartTime</code> happens, a new transition chain is created and the previous chain is marked as deprecated:<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/23-fix-fibernode-shape-1.svg width=960></figure><p>Note how the extensibility transition is now properly replayed in the new chain.<figure><img alt="" height=540 loading=lazy src=/_img/react-cliff/24-fix-fibernode-shape-2.svg width=960></figure><p>After the assignment to <code>node2.actualStartTime</code>, both nodes refer to the new shape, and the deprecated part of the transition tree can be cleaned up by the garbage collector.<div class=note><p><strong>Note:</strong> You might think all this shape deprecation/migration is complex, and you’d be right. In fact, we have a suspicion that on real-world websites it causes more issues (in terms of performance, memory use, and complexity) than it helps, particularly since with <a href="https://bugs.chromium.org/p/v8/issues/detail?id=7703">pointer compression</a> we’ll no longer be able to use it to store double-valued fields in-line in the object. So, we’re hoping to <a href="https://bugs.chromium.org/p/v8/issues/detail?id=9606">remove V8’s shape deprecation mechanism entirely</a>. You could say it’s <em>*puts on sunglasses*</em> being deprecated. <em>YEEEAAAHHH…</em></div><p>The React team <a href=https://github.com/facebook/react/pull/14383>mitigated the problem on their end</a> by making sure that all the time and duration fields on <code>FiberNode</code>s start out with <code>Double</code> representation:<pre class=language-js><code class=language-js><span class="token keyword">class</span> <span class="token class-name">FiberNode</span> <span class="token punctuation">{</span><br>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Force `Double` representation from the start.</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>actualStartTime <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token number">NaN</span><span class="token punctuation">;</span><br>    <span class="token comment">// Later, you can still initialize to the value you want:</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>actualStartTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>    Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FiberNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FiberNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Instead of <code>Number.NaN</code>, any floating-point value that doesn’t fit the <code>Smi</code> range could be used. Examples include <code>0.000001</code>, <code>Number.MIN_VALUE</code>, <code>-0</code>, and <code>Infinity</code>.<p>It’s worth pointing out that the concrete React bug was V8-specific and that in general, developers shouldn’t optimize for a specific version of a JavaScript engine. Still, it’s nice to have a handle when things don't work.<p>Keep in mind that the JavaScript engine performs some magic under the hood, and you can help it by not mixing types if possible. For example, don’t initialize your numeric fields with <code>null</code>, as that disables all the benefits from the field representation tracking, and it makes your code more readable:<pre class=language-js><code class=language-js><span class="token comment">// Don’t do this!</span><br><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><br>  x <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br>  y <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>p<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span><br>p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">402</span><span class="token punctuation">;</span></code></pre><p>In other words, <strong>write readable code, and performance will follow!</strong><h2 id=takeaways>Take-aways <a href=#takeaways class=bookmark>#</a></h2><p>We’ve covered the following in this deep-dive:<ul><li>JavaScript distinguishes between “primitives” and “objects”, and <code>typeof</code> is a liar.<li>Even values with the same JavaScript type can have different representations behind the scenes.<li>V8 tries to find the optimal representation for every property in your JavaScript programs.<li>We’ve discussed how V8 deals with shape deprecations and migrations, including extensibility transitions.</ul><p>Based on this knowledge, we identified some practical JavaScript coding tips that can help boost performance:<ul><li>Always initialize your objects in the same way, so that shapes can be effective.<li>Choose sensible initial values for your fields to help JavaScript engines with representation selection.</ul></div><footer><div><picture><source srcset="/_img/avatars/benedikt-meurer.avif, /_img/avatars/benedikt-meurer@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/benedikt-meurer.jpg width=96 srcset="/_img/avatars/benedikt-meurer@2x.jpg 2x"></picture><picture><source srcset="/_img/avatars/mathias-bynens.avif, /_img/avatars/mathias-bynens@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/mathias-bynens.jpg width=96 srcset="/_img/avatars/mathias-bynens@2x.jpg 2x"></picture><p>作者：Benedikt Meurer (<a href=https://twitter.com/bmeurer>@bmeurer</a>) and Mathias Bynens (<a href=https://twitter.com/mathias>@mathias</a>).</div><a href=https://twitter.com/v8js/status/1166723359696130049 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/react-cliff>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/react-cliff.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>