<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Taming architecture complexity in V8 — the CodeStubAssembler · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="V8 has its own abstraction on top of assembly code: the CodeStubAssembler. The CSA allows V8 to quickly and reliably optimize JS features at a low level, all while supporting multiple platforms." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Taming architecture complexity in V8 — the CodeStubAssembler</h1><p class=meta>发布时间 <time datetime="2017-11-16 13:33:37" itemprop=datePublished title="2017-11-16 13:33:37">2017-11-16</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a></header><div itemprop=articleBody><p>In this post we’d like to introduce the CodeStubAssembler (CSA), a component in V8 that has been a very useful tool in achieving some <a href=/blog/optimizing-proxies>big</a> <a href=https://twitter.com/v8js/status/918119002437750784>performance</a> <a href=https://twitter.com/_gsathya/status/900188695721984000>wins</a> over the last several V8 releases. The CSA also significantly improved the V8 team’s ability to quickly optimize JavaScript features at a low-level with a high degree of reliability, which improved the team’s development velocity.<h2 id=a-brief-history-of-builtins-and-hand-written-assembly-in-v8>A brief history of builtins and hand-written assembly in V8 <a href=#a-brief-history-of-builtins-and-hand-written-assembly-in-v8 class=bookmark>#</a></h2><p>To understand the CSA’s role in V8, it’s important to understand a little bit of the context and history that led to its development.<p>V8 squeezes performance out of JavaScript using a combination of techniques. For JavaScript code that runs a long time, V8’s <a href=/docs/turbofan>TurboFan</a> optimizing compiler does a great job of speeding up the entire spectrum of ES2015+ functionality for peak performance. However, V8 also needs to execute short-running JavaScript efficiently for good baseline performance. This is especially the case for the so-called <strong>builtin functions</strong> on the pre-defined objects that are available to all JavaScript programs as defined by the <a href=https://tc39.es/ecma262/ >ECMAScript specification</a>.<p>Historically, many of these builtin functions were <a href=https://en.wikipedia.org/wiki/Self-hosting>self-hosted</a>, that is, they were authored by a V8 developer in JavaScript—albeit a special V8-internal dialect. To achieve good performance, these self-hosted builtins rely on the same mechanisms V8 uses to optimize user-supplied JavaScript. As with user-supplied code, the self-hosted builtins require a warm-up phase in which type feedback is gathered and they need to be compiled by the optimizing compiler.<p>Although this technique provides good builtin performance in some situations, it’s possible to do better. The exact semantics of the pre-defined functions on the <code>Array.prototype</code> are <a href=https://tc39.es/ecma262/#sec-properties-of-the-array-prototype-object>specified in exquisite detail</a> in the spec. For important and common special cases, V8’s implementers know in advance exactly how these builtin functions should work by understanding the specification, and they use this knowledge to carefully craft custom, hand-tuned versions up front. These <em>optimized builtins</em> handle common cases without warm-up or the need to invoke the optimizing compiler, since by construction baseline performance is already optimal upon first invocation.<p>To squeeze the best performance out of hand-written built-in JavaScript functions (and from other fast-path V8 code that are also somewhat confusingly called builtins), V8 developers traditionally wrote optimized builtins in assembly language. By using assembly, the hand-written builtin functions were especially fast by, among other things, avoiding expensive calls to V8’s C++ code via trampolines and by taking advantage of V8’s custom register-based <a href=https://en.wikipedia.org/wiki/Application_binary_interface>ABI</a> that it uses internally to call JavaScript functions.<p>Because of the advantages of hand-written assembly, V8 accumulated literally tens of thousands of lines of hand-written assembly code for builtins over the years… <em>per platform</em>. All of these hand-written assembly builtins were great for improving performance, but new language features are always being standardized, and maintaining and extending this hand-written assembly was laborious and error-prone.<h2 id=enter-the-codestubassembler>Enter the CodeStubAssembler <a href=#enter-the-codestubassembler class=bookmark>#</a></h2><p>V8 developers wrestled with a dilemma for many years: is it possible to create builtins that have the advantage of hand-written assembly without also being fragile and difficult to maintain?<p>With the advent of TurboFan the answer to this question is finally “yes”. TurboFan’s backend uses a cross-platform <a href=https://en.wikipedia.org/wiki/Intermediate_representation>intermediate representation</a> (IR) for low-level machine operations. This low-level machine IR is input to an instruction selector, register allocator, instruction scheduler and code generator that produce very good code on all platforms. The backend also knows about many of the tricks that are used in V8’s hand-written assembly builtins—e.g. how to use and call a custom register-based ABI, how to support machine-level tail calls, and how to elide the construction of stack frames in leaf functions. That knowledge makes the TurboFan backend especially well-suited for generating fast code that integrates well with the rest of V8.<p>This combination of functionality made a robust and maintainable alternative to hand-written assembly builtins feasible for the first time. The team built a new V8 component—dubbed the CodeStubAssembler or CSA—that defines a portable assembly language built on top of TurboFan’s backend. The CSA adds an API to generate TurboFan machine-level IR directly without having to write and parse JavaScript or apply TurboFan’s JavaScript-specific optimizations. Although this fast-path to code generation is something that only V8 developers can use to speed up the V8 engine internally, this efficient path for generating optimized assembly code in a cross-platform way directly benefits all developers’ JavaScript code in the builtins constructed with the CSA, including the performance-critical bytecode handlers for V8’s interpreter, <a href=/docs/ignition>Ignition</a>.<figure><img alt="" height=643 loading=lazy src=/_img/csa/csa.svg width=543><figcaption>The CSA and JavaScript compilation pipelines</figcaption></figure><p>The CSA interface includes operations that are very low-level and familiar to anybody who has ever written assembly code. For example, it includes functionality like “load this object pointer from a given address” and “multiply these two 32-bit numbers”. The CSA has type verification at the IR level to catch many correctness bugs at compile time rather than runtime. For example, it can ensure that a V8 developer doesn’t accidentally use an object pointer that is loaded from memory as the input for a 32-bit multiplication. This kind of type verification is simply not possible with hand-written assembly stubs.<h2 id=a-csa-test-drive>A CSA test-drive <a href=#a-csa-test-drive class=bookmark>#</a></h2><p>To get a better idea of what the CSA offers, let’s go through a quick example. We’ll add a new internal builtin to V8 that returns the string length from an object if it is a String. If the input object is not a String, the builtin will return <code>undefined</code>.<p>First, we add a line to the <code>BUILTIN_LIST_BASE</code> macro in V8’s <a href=https://cs.chromium.org/chromium/src/v8/src/builtins/builtins-definitions.h><code>builtin-definitions.h</code></a> file that declares the new builtin called <code>GetStringLength</code> and specifies that it has a single input parameter that is identified with the constant <code>kInputObject</code>:<pre class=language-cpp><code class=language-cpp><span class="token function">TFS</span><span class="token punctuation">(</span>GetStringLength<span class="token punctuation">,</span> kInputObject<span class="token punctuation">)</span></code></pre><p>The <code>TFS</code> macro declares the builtin as a <strong>T</strong>urbo<strong>F</strong>an builtin using standard Code<strong>S</strong>tub linkage, which simply means that it uses the CSA to generate its code and expects parameters to be passed via registers.<p>We can then define the contents of the builtin in <a href=https://cs.chromium.org/chromium/src/v8/src/builtins/builtins-string-gen.cc><code>builtins-string-gen.cc</code></a>:<pre class=language-cpp><code class=language-cpp><span class="token function">TF_BUILTIN</span><span class="token punctuation">(</span>GetStringLength<span class="token punctuation">,</span> CodeStubAssembler<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  Label <span class="token function">not_string</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Fetch the incoming object using the constant we defined for</span><br>  <span class="token comment">// the first parameter.</span><br>  Node<span class="token operator">*</span> <span class="token keyword">const</span> maybe_string <span class="token operator">=</span> <span class="token function">Parameter</span><span class="token punctuation">(</span>Descriptor<span class="token operator">::</span>kInputObject<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Check to see if input is a Smi (a special representation</span><br>  <span class="token comment">// of small numbers). This needs to be done before the IsString</span><br>  <span class="token comment">// check below, since IsString assumes its argument is an</span><br>  <span class="token comment">// object pointer and not a Smi. If the argument is indeed a</span><br>  <span class="token comment">// Smi, jump to the label |not_string|.</span><br>  <span class="token function">GotoIf</span><span class="token punctuation">(</span><span class="token function">TaggedIsSmi</span><span class="token punctuation">(</span>maybe_string<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&</span>not_string<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Check to see if the input object is a string. If not, jump to</span><br>  <span class="token comment">// the label |not_string|.</span><br>  <span class="token function">GotoIfNot</span><span class="token punctuation">(</span><span class="token function">IsString</span><span class="token punctuation">(</span>maybe_string<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&</span>not_string<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Load the length of the string (having ended up in this code</span><br>  <span class="token comment">// path because we verified it was string above) and return it</span><br>  <span class="token comment">// using a CSA "macro" LoadStringLength.</span><br>  <span class="token function">Return</span><span class="token punctuation">(</span><span class="token function">LoadStringLength</span><span class="token punctuation">(</span>maybe_string<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Define the location of label that is the target of the failed</span><br>  <span class="token comment">// IsString check above.</span><br>  <span class="token function">BIND</span><span class="token punctuation">(</span><span class="token operator">&</span>not_string<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Input object isn't a string. Return the JavaScript undefined</span><br>  <span class="token comment">// constant.</span><br>  <span class="token function">Return</span><span class="token punctuation">(</span><span class="token function">UndefinedConstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Note that in the example above, there are two types of instructions used. There are <em>primitive</em> CSA instructions that translate directly into one or two assembly instructions like <code>GotoIf</code> and <code>Return</code>. There are a fixed set of pre-defined CSA primitive instructions roughly corresponding to the most commonly used assembly instructions you would find on one of V8’s supported chip architectures. Others instructions in the example are <em>macro</em> instructions, like <code>LoadStringLength</code>, <code>TaggedIsSmi</code>, and <code>IsString</code>, that are convenience functions to output one or more primitive or macro instructions inline. Macro instructions are used to encapsulate commonly used V8 implementation idioms for easy reuse. They can be arbitrarily long and new macro instructions can be easily defined by V8 developers whenever needed.<p>After compiling V8 with the above changes, we can run <code>mksnapshot</code>, the tool that compiles builtins to prepare them for V8’s snapshot, with the <code>--print-code</code> command-line option. This options prints the generated assembly code for each builtin. If we <code>grep</code> for <code>GetStringLength</code> in the output, we get the following result on x64 (the code output is cleaned up a bit to make it more readable):<pre class=language-asm><code class=language-asm>  test <span class="token register variable">al</span>,<span class="token number">0x1</span><br>  jz not_string<br>  movq <span class="token register variable">rbx</span>,<span class="token operator">[</span><span class="token register variable">rax</span><span class="token operator">-</span><span class="token number">0x1</span><span class="token operator">]</span><br>  cmpb <span class="token operator">[</span><span class="token register variable">rbx</span><span class="token operator">+</span><span class="token number">0xb</span><span class="token operator">]</span>,<span class="token number">0x80</span><br>  jnc not_string<br>  movq <span class="token register variable">rax</span>,<span class="token operator">[</span><span class="token register variable">rax</span><span class="token operator">+</span><span class="token number">0xf</span><span class="token operator">]</span><br>  retl<br><span class="token function label">not_string:</span><br>  movq <span class="token register variable">rax</span>,<span class="token operator">[</span><span class="token register variable">r13</span><span class="token operator">-</span><span class="token number">0x60</span><span class="token operator">]</span><br>  retl</code></pre><p>On 32-bit ARM platforms, the following code is generated by <code>mksnapshot</code>:<pre class=language-asm><code class=language-asm>  tst <span class="token register variable">r0</span>, <span class="token number">#1</span><br>  beq <span class="token operator">+</span><span class="token number">28</span> <span class="token operator">-</span><span class="token operator">></span> not_string<br>  ldr <span class="token register variable">r1</span>, <span class="token operator">[</span><span class="token register variable">r0</span>, <span class="token number">#-1</span><span class="token operator">]</span><br>  ldrb <span class="token register variable">r1</span>, <span class="token operator">[</span><span class="token register variable">r1</span>, <span class="token number">#+7</span><span class="token operator">]</span><br>  cmp <span class="token register variable">r1</span>, <span class="token number">#128</span><br>  bge <span class="token operator">+</span><span class="token number">12</span> <span class="token operator">-</span><span class="token operator">></span> not_string<br>  ldr <span class="token register variable">r0</span>, <span class="token operator">[</span><span class="token register variable">r0</span>, <span class="token number">#+7</span><span class="token operator">]</span><br>  <span class="token register variable">bx</span> <span class="token register variable">lr</span><br><span class="token function label">not_string:</span><br>  ldr <span class="token register variable">r0</span>, <span class="token operator">[</span><span class="token register variable">r10</span>, <span class="token number">#+16</span><span class="token operator">]</span><br>  <span class="token register variable">bx</span> <span class="token register variable">lr</span></code></pre><p>Even though our new builtin uses a non-standard (at least non-C++) calling convention, it’s possible to write test cases for it. The following code can be added to <a href=https://cs.chromium.org/chromium/src/v8/test/cctest/compiler/test-run-stubs.cc><code>test-run-stubs.cc</code></a> to test the builtin on all platforms:<pre class=language-cpp><code class=language-cpp><span class="token function">TEST</span><span class="token punctuation">(</span>GetStringLength<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  HandleAndZoneScope scope<span class="token punctuation">;</span><br>  Isolate<span class="token operator">*</span> isolate <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">main_isolate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  Heap<span class="token operator">*</span> heap <span class="token operator">=</span> isolate<span class="token operator">-></span><span class="token function">heap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  Zone<span class="token operator">*</span> zone <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">main_zone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Test the case where input is a string</span><br>  StubTester <span class="token function">tester</span><span class="token punctuation">(</span>isolate<span class="token punctuation">,</span> zone<span class="token punctuation">,</span> Builtins<span class="token operator">::</span>kGetStringLength<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  Handle<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">input_string</span><span class="token punctuation">(</span><br>      isolate<span class="token operator">-></span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><br>        <span class="token function">NewStringFromAsciiChecked</span><span class="token punctuation">(</span><span class="token string">"Oktoberfest"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  Handle<span class="token operator">&lt;</span>Object<span class="token operator">></span> result1 <span class="token operator">=</span> tester<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span>input_string<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token function">CHECK_EQ</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token class-name">Handle</span><span class="token operator">&lt;</span>Smi<span class="token operator">></span><span class="token operator">::</span><span class="token function">cast</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token comment">// Test the case where input is not a string (e.g. undefined)</span><br>  Handle<span class="token operator">&lt;</span>Object<span class="token operator">></span> result2 <span class="token operator">=</span><br>      tester<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span>factory<span class="token operator">-></span><span class="token function">undefined_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token function">CHECK</span><span class="token punctuation">(</span>result2<span class="token operator">-></span><span class="token function">IsUndefined</span><span class="token punctuation">(</span>isolate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>For more details about using the CSA for different kinds of builtins and for further examples, see <a href=/docs/csa-builtins>this wiki page</a>.<h2 id=a-v8-developer-velocity-multiplier>A V8 developer velocity multiplier <a href=#a-v8-developer-velocity-multiplier class=bookmark>#</a></h2><p>The CSA is more than just an universal assembly language that targets multiple platforms. It enables much quicker turnaround when implementing new features compared to hand-writing code for each architecture as we used to do. It does this by providing all of the benefits of hand-written assembly while protecting developers against its most treacherous pitfalls:<ul><li>With the CSA, developers can write builtin code with a cross-platform set of low-level primitives that translate directly to assembly instructions. The CSA’s instruction selector ensures that this code is optimal on all of the platforms that V8 targets without requiring V8 developers to be experts in each of those platform’s assembly languages.<li>The CSA’s interface has optional types to ensure that the values manipulated by the low-level generated assembly are of the type that the code author expects.<li>Register allocation between assembly instructions is done by the CSA automatically rather than explicitly by hand, including building stack frames and spilling values to the stack if a builtin uses more registers than available or makes call. This eliminates a whole class of subtle, hard-to-find bugs that plagued hand-written assembly builtins. By making the generated code less fragile the CSA drastically reduces the time required to write correct low-level builtins.<li>The CSA understands ABI calling conventions—both standard C++ and internal V8 register-based ones—making it possible to easily interoperate between CSA-generated code and other parts of V8.<li>Since CSA code is C++, it’s easy to encapsulate common code generation patterns in macros that can be easily reused in many builtins.<li>Because V8 uses the CSA to generate the bytecode handlers for Ignition, it is very easy to inline the functionality of CSA-based builtins directly into the handlers to improve the interpreter’s performance.<li>V8’s testing framework supports testing CSA functionality and CSA-generated builtins from C++ without having to write assembly adapters.</ul><p>All in all, the CSA has been a game changer for V8 development. It has significantly improved the team’s ability to optimize V8. That means we are able to optimize more of the JavaScript language faster for V8’s embedders.</div><footer><div><p>作者：<a href=https://twitter.com/expatdanno>Daniel Clifford</a>, CodeStubAssembler assembler.</div><a href=https://twitter.com/v8js/status/931184976481177600 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/csa>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/csa.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>