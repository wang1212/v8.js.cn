<!doctype html><html lang=zh-CN><meta charset=utf-8><title>There’s Math.random(), and then there’s Math.random() · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="V8’s Math.random implementation now uses an algorithm called xorshift128+, improving the randomness compared to the old MWC1616 implementation." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>There’s <code>Math.random()</code>, and then there’s <code>Math.random()</code></h1><p class=meta>发布时间 <time datetime="2015-12-17 13:33:37" itemprop=datePublished title="2015-12-17 13:33:37">2015-12-17</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a> <a href=/blog/tags/internals/ class=tag>internals</a></header><div itemprop=articleBody><blockquote><p><code>Math.random()</code> returns a <code>Number</code> value with positive sign, greater than or equal to <code>0</code> but less than <code>1</code>, chosen randomly or pseudo-randomly with approximately uniform distribution over that range, using an implementation-dependent algorithm or strategy. This function takes no arguments.</blockquote><p>— <em><a href=http://tc39.es/ecma262/#sec-math.random>ES 2015, section 20.2.2.27</a></em><p><code>Math.random()</code> is the most well-known and frequently-used source of randomness in Javascript. In V8 and most other Javascript engines, it is implemented using a <a href=https://en.wikipedia.org/wiki/Pseudorandom_number_generator>pseudo-random number generator</a> (PRNG). As with all PRNGs, the random number is derived from an internal state, which is altered by a fixed algorithm for every new random number. So for a given initial state, the sequence of random numbers is deterministic. Since the bit size n of the internal state is limited, the numbers that a PRNG generates will eventually repeat themselves. The upper bound for the period length of this <a href=https://en.wikipedia.org/wiki/Cyclic_permutation>permutation cycle</a> is 2<sup>n</sup>.<p>There are many different PRNG algorithms; among the most well-known ones are <a href=https://en.wikipedia.org/wiki/Mersenne_Twister>Mersenne-Twister</a> and <a href=https://en.wikipedia.org/wiki/Linear_congruential_generator>LCG</a>. Each has its particular characteristics, advantages, and drawbacks. Ideally, it would use as little memory as possible for the initial state, be quick to perform, have a large period length, and offer a high quality random distribution. While memory usage, performance, and period length can easily be measured or calculated, the quality is harder to determine. There is a lot of math behind statistical tests to check the quality of random numbers. The de-facto standard PRNG test suite, <a href=http://simul.iro.umontreal.ca/testu01/tu01.html>TestU01</a>, implements many of these tests.<p>Until <a href=https://github.com/v8/v8/blob/ceade6cf239e0773213d53d55c36b19231c820b5/src/js/math.js#L143>recently</a> (up to version 4.9.40), V8’s choice of PRNG was MWC1616 (multiply with carry, combining two 16-bit parts). It uses 64 bits of internal state and looks roughly like this:<pre class=language-cpp><code class=language-cpp><span class="token keyword">uint32_t</span> state0 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token keyword">uint32_t</span> state1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><br><span class="token keyword">uint32_t</span> <span class="token function">mwc1616</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  state0 <span class="token operator">=</span> <span class="token number">18030</span> <span class="token operator">*</span> <span class="token punctuation">(</span>state0 <span class="token operator">&</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>state0 <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  state1 <span class="token operator">=</span> <span class="token number">30903</span> <span class="token operator">*</span> <span class="token punctuation">(</span>state1 <span class="token operator">&</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>state1 <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> state0 <span class="token operator">&lt;&lt;</span> <span class="token number">16</span> <span class="token operator">+</span> <span class="token punctuation">(</span>state1 <span class="token operator">&</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The 32-bit value is then turned into a floating point number between 0 and 1 in agreement with the specification.<p>MWC1616 uses little memory and is pretty fast to compute, but unfortunately offers sub-par quality:<ul><li>The number of random values it can generate is limited to 2<sup>32</sup> as opposed to the 2<sup>52</sup> numbers between 0 and 1 that double precision floating point can represent.<li>The more significant upper half of the result is almost entirely dependent on the value of state0. The period length would be at most 2<sup>32</sup>, but instead of few large permutation cycles, there are many short ones. With a badly chosen initial state, the cycle length could be less than 40 million.<li>It fails many statistical tests in the TestU01 suite.</ul><p>This has been <a href=https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d>pointed out</a> to us, and having understood the problem and after some research, we decided to reimplement <code>Math.random</code> based on an algorithm called <a href=http://vigna.di.unimi.it/ftp/papers/xorshiftplus.pdf>xorshift128+</a>. It uses 128 bits of internal state, has a period length of 2<sup>128</sup> - 1, and passes all tests from the TestU01 suite.<pre class=language-cpp><code class=language-cpp><span class="token keyword">uint64_t</span> state0 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token keyword">uint64_t</span> state1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><br><span class="token keyword">uint64_t</span> <span class="token function">xorshift128plus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">uint64_t</span> s1 <span class="token operator">=</span> state0<span class="token punctuation">;</span><br>  <span class="token keyword">uint64_t</span> s0 <span class="token operator">=</span> state1<span class="token punctuation">;</span><br>  state0 <span class="token operator">=</span> s0<span class="token punctuation">;</span><br>  s1 <span class="token operator">^=</span> s1 <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span><br>  s1 <span class="token operator">^=</span> s1 <span class="token operator">>></span> <span class="token number">17</span><span class="token punctuation">;</span><br>  s1 <span class="token operator">^=</span> s0<span class="token punctuation">;</span><br>  s1 <span class="token operator">^=</span> s0 <span class="token operator">>></span> <span class="token number">26</span><span class="token punctuation">;</span><br>  state1 <span class="token operator">=</span> s1<span class="token punctuation">;</span><br>  <span class="token keyword">return</span> state0 <span class="token operator">+</span> state1<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The new implementation <a href=https://github.com/v8/v8/blob/085fed0fb5c3b0136827b5d7c190b4bd1c23a23e/src/base/utils/random-number-generator.h#L102>landed in V8 v4.9.41.0</a> within a few days of us becoming aware of the issue. It will become available with Chrome 49. Both <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=322529#c99">Firefox</a> and <a href="https://bugs.webkit.org/show_bug.cgi?id=151641">Safari</a> switched to xorshift128+ as well.<p>Make no mistake however: even though xorshift128+ is a huge improvement over MWC1616, it still is not <a href=https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator>cryptographically secure</a>. For use cases such as hashing, signature generation, and encryption/decryption, ordinary PRNGs are unsuitable. The Web Cryptography API introduces <a href=https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues><code>window.crypto.getRandomValues</code></a>, a method that returns cryptographically secure random values, at a performance cost.<p>Please keep in mind, if you find areas of improvement in V8 and Chrome, even ones that — like this one — do not directly affect spec compliance, stability, or security, please file <a href="https://bugs.chromium.org/p/v8/issues/entry?template=Defect%20report%20from%20user">an issue on our bug tracker</a>.</div><footer><div><picture><source srcset="/_img/avatars/yang-guo.avif, /_img/avatars/yang-guo@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/yang-guo.jpg srcset="/_img/avatars/yang-guo@2x.jpg 2x" width=96></picture><p>作者：Yang Guo (<a href=https://twitter.com/hashseed>@hashseed</a>), software engineer and dice designer.</div></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/math-random>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/math-random.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>