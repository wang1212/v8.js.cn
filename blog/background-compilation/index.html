<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Background compilation · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Starting with Chrome 66, V8 compiles JavaScript source code on a background thread, reducing the amount of time spent compiling on the main thread by between 5% to 20% on typical websites." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Background compilation</h1><p class=meta>发布时间 <time datetime="2018-03-26 13:33:37" itemprop=datePublished title="2018-03-26 13:33:37">2018-03-26</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a></header><div itemprop=articleBody><p>TL;DR: Starting with Chrome 66, V8 compiles JavaScript source code on a background thread, reducing the amount of time spent compiling on the main thread by between 5% to 20% on typical websites.<h2 id=background>Background <a href=#background class=bookmark>#</a></h2><p>Since version 41, Chrome has supported <a href=https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html>parsing of JavaScript source files on a background thread</a> via V8’s <a href="https://cs.chromium.org/chromium/src/v8/include/v8.h?q=StreamedSource&sq=package:chromium&l=1389"><code>StreamedSource</code></a> API. This enables V8 to start parsing JavaScript source code as soon as Chrome has downloaded the first chunk of the file from the network, and to continue parsing in parallel while Chrome streams the file over the network. This can provide considerable loading time improvements since V8 can be almost finished parsing the JavaScript by the time the file has finished downloading.<p>However, due to limitations in V8’s original baseline compiler, V8 still needed to go back to the main thread to finalize parsing and compile the script into JIT machine code that would execute the script’s code. With the switch to our new <a href=/blog/launching-ignition-and-turbofan>Ignition + TurboFan pipeline</a>, we are now able to move bytecode compilation to the background thread as well, thereby freeing up Chrome’s main-thread to deliver a smoother, more responsive web browsing experience.<h2 id=building-a-background-thread-bytecode-compiler>Building a background thread bytecode compiler <a href=#building-a-background-thread-bytecode-compiler class=bookmark>#</a></h2><p>V8’s Ignition bytecode compiler takes the <a href=https://en.wikipedia.org/wiki/Abstract_syntax_tree>abstract syntax tree (AST)</a> produced by the parser as input and produces a stream of bytecode (<code>BytecodeArray</code>) along with associated meta-data which enables the Ignition interpreter to execute the JavaScript source.<figure><img alt="" height=509 loading=lazy src=/_img/background-compilation/bytecode.svg width=1145></figure><p>Ignition’s bytecode compiler was built with multi-threading in mind, however a number of changes were required throughout the compilation pipeline to enable background compilation. One of the main changes was to prevent the compilation pipeline from accessing objects in V8’s JavaScript heap while running on the background thread. Objects in V8’s heap are not thread-safe, since Javascript is single-threaded, and might be modified by the main-thread or V8’s garbage collector during background compilation.<p>There were two main stages of the compilation pipeline which accessed objects on V8’s heap: AST internalization, and bytecode finalization. AST internalization is a process by which literal objects (strings, numbers, object-literal boilerplate, etc.) identified in the AST are allocated on the V8 heap, such that they can be used directly by the generated bytecode when the script is executed. This process traditionally happened immediately after the parser built the AST. As such, there were a number of steps later in the compilation pipeline that relied on the literal objects having been allocated. To enable background compilation we moved AST internalization later in the compilation pipeline, after the bytecode had been compiled. This required modifications to the later stages of the pipeline to access the <em>raw</em> literal values embedded in the AST instead of internalized on-heap values.<p>Bytecode finalization involves building the final <code>BytecodeArray</code> object, used to execute the function, alongside associated metadata — for example, a <code>ConstantPoolArray</code> which stores constants referred to by the bytecode, and a <code>SourcePositionTable</code> which maps the JavaScript source line and column numbers to bytecode offset. Since JavaScript is a dynamic language, these objects all need to live in the JavaScript heap to enable them to be garbage-collected if the JavaScript function associated with the bytecode is collected. Previously some of these metadata objects would be allocated and modified during bytecode compilation, which involved accessing the JavaScript heap. In order to enable background compilation, Ignition’s bytecode generator was refactored to keep track of the details of this metadata and defer allocating them on the JavaScript heap until the very final stages of compilation.<p>With these changes, almost all of the script’s compilation can be moved to a background thread, with only the short AST internalization and bytecode finalization steps happening on the main thread just before script execution.<figure><img alt="" height=296 loading=lazy src=/_img/background-compilation/threads.svg width=1185></figure><p>Currently, only top-level script code and immediately invoked function expressions (IIFEs) are compiled on a background thread — inner functions are still compiled lazily (when first executed) on the main thread. We are hoping to extend background compilation to more situations in the future. However, even with these restrictions, background compilation leaves the main thread free for longer, enabling it to do other work such as reacting to user-interaction, rendering animations or otherwise producing a smoother more responsive experience.<h2 id=results>Results <a href=#results class=bookmark>#</a></h2><p>We evaluated the performance of background compilation using our <a href=/blog/real-world-performance>real-world benchmarking framework</a> across a set of popular webpages.<figure><img alt="" height=440 loading=lazy src=/_img/background-compilation/desktop.svg width=712></figure><figure><img alt="" height=442 loading=lazy src=/_img/background-compilation/mobile.svg width=548></figure><p>The proportion of compilation that can happen on a background thread varies depending on the proportion of bytecode compiled during top-level streaming-script compilation verses being lazy compiled as inner functions are invoked (which must still occur on the main thread). As such, the proportion of time saved on the main thread varies, with most pages seeing between 5% to 20% reduction in main-thread compilation time.<h2 id=next-steps>Next steps <a href=#next-steps class=bookmark>#</a></h2><p>What’s better than compiling a script on a background thread? Not having to compile the script at all! Alongside background compilation we have also been working on improving V8’s <a href=/blog/code-caching>code-caching system</a> to expand the amount of code cached by V8, thereby speeding up page loading for sites you visit often. We hope to bring you updates on this front soon. Stay tuned!</div><footer><div><picture><source srcset="/_img/avatars/ross-mcilroy.avif, /_img/avatars/ross-mcilroy@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/ross-mcilroy.jpg width=96 srcset="/_img/avatars/ross-mcilroy@2x.jpg 2x"></picture><p>作者：<a href=https://twitter.com/rossmcilroy>Ross McIlroy</a>, main thread defender.</div><a href=https://twitter.com/v8js/status/978319362837958657 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/background-compilation>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/background-compilation.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>