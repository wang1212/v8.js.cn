<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Optimizing hash tables: hiding the hash code · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Several JavaScript data structures such as Map, Set, WeakSet, and WeakMap use hash tables under the hood. This article explains how V8 v6.3 improves hash table performance." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Optimizing hash tables: hiding the hash code</h1><p class=meta>发布时间 <time datetime="2018-01-29 13:33:37" itemprop=datePublished title="2018-01-29 13:33:37">2018-01-29</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a></header><div itemprop=articleBody><p>ECMAScript 2015 introduced several new data structures such as Map, Set, WeakSet, and WeakMap, all of which use hash tables under the hood. This post details the <a href="https://bugs.chromium.org/p/v8/issues/detail?id=6404">recent improvements</a> in how <a href=/blog/v8-release-63>V8 v6.3+</a> stores the keys in hash tables.<h2 id=hash-code>Hash code <a href=#hash-code class=bookmark>#</a></h2><p>A <a href=https://en.wikipedia.org/wiki/Hash_function><em>hash function</em></a> is used to map a given key to a location in the hash table. A <em>hash code</em> is the result of running this hash function over a given key.<p>In V8, the hash code is just a random number, independent of the object value. Therefore, we can’t recompute it, meaning we must store it.<p>For JavaScript objects that were used as keys, previously, the hash code was stored as a private symbol on the object. A private symbol in V8 is similar to a <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol><code>Symbol</code></a>, except that it’s not enumerable and doesn’t leak to userspace JavaScript.<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">GetObjectHash</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> hash <span class="token operator">=</span> key<span class="token punctuation">[</span>hashCodeSymbol<span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">IS_UNDEFINED</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    hash <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">MathRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0x40000000</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> hash <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    key<span class="token punctuation">[</span>hashCodeSymbol<span class="token punctuation">]</span> <span class="token operator">=</span> hash<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> hash<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>This worked well because we didn’t have to reserve memory for a hash code field until the object was added to a hash table, at which point a new private symbol was stored on the object.<p>V8 could also optimize the hash code symbol lookup just like any other property lookup using the IC system, providing very fast lookups for the hash code. This works well for <a href=https://en.wikipedia.org/wiki/Inline_caching#Monomorphic_inline_caching>monomorphic IC lookups</a>, when the keys have the same <a href=/ >hidden class</a>. However, most real-world code doesn’t follow this pattern, and often keys have different hidden classes, leading to slow <a href=https://en.wikipedia.org/wiki/Inline_caching#Megamorphic_inline_caching>megamorphic IC lookups</a> of the hash code.<p>Another problem with the private symbol approach was that it triggered a <a href=/#fast-property-access>hidden class transition</a> in the key on storing the hash code. This resulted in poor polymorphic code not just for the hash code lookup but also for other property lookups on the key and <a href=https://floitsch.blogspot.com/2012/03/optimizing-for-v8-inlining.html>deoptimization</a> from optimized code.<h2 id=javascript-object-backing-stores>JavaScript object backing stores <a href=#javascript-object-backing-stores class=bookmark>#</a></h2><p>A JavaScript object (<code>JSObject</code>) in V8 uses two words (apart from its header): one word for storing a pointer to the elements backing store, and another word for storing a pointer to the properties backing store.<p>The elements backing store is used for storing properties that look like <a href=https://tc39.es/ecma262/#sec-array-index>array indices</a>, whereas the properties backing store is used for storing properties whose keys are strings or symbols. See this <a href=/blog/fast-properties>V8 blog post</a> by Camillo Bruni for more information about these backing stores.<pre class=language-js><code class=language-js><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>      <span class="token comment">// ← stored in elements</span><br>x<span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>  <span class="token comment">// ← stored in properties</span></code></pre><h2 id=hiding-the-hash-code>Hiding the hash code <a href=#hiding-the-hash-code class=bookmark>#</a></h2><p>The easiest solution to storing the hash code would be to extend the size of a JavaScript object by one word and store the hash code directly on the object. However, this would waste memory for objects that aren’t added to a hash table. Instead, we could try to store the hash code in the elements store or properties store.<p>The elements backing store is an array containing its length and all the elements. There’s not much to be done here, as storing the hashcode in a reserved slot (like the 0th index) would still waste memory when we don’t use the object as a key in a hash table.<p>Let’s look at the properties backing store. There are two kinds of data structures used as a properties backing store: arrays and dictionaries.<p>Unlike the array used in the elements backing store which does not have an upper limit, the array used in the properties backing store has an upper limit of 1022 values. V8 transitions to using a dictionary on exceeding this limit for performance reasons. (I’m slightly simplifying this — V8 can also use a dictionary in other cases, but there is a fixed upper limit on the number of values that can be stored in the array.)<p>So, there are three possible states for the properties backing store:<ol><li>empty (no properties)<li>array (can store up to 1022 values)<li>dictionary</ol><p>Let’s discuss each of these.<h3 id=the-properties-backing-store-is-empty>The properties backing store is empty <a href=#the-properties-backing-store-is-empty class=bookmark>#</a></h3><p>For the empty case, we can directly store the hash code in this offset on the <code>JSObject</code>.<figure><img alt="" height=160 loading=lazy src=/_img/hash-code/properties-backing-store-empty.png width=323></figure><h3 id=the-properties-backing-store-is-an-array>The properties backing store is an array <a href=#the-properties-backing-store-is-an-array class=bookmark>#</a></h3><p>V8 represents integers less than 2<sup>31</sup> (on 32-bit systems) unboxed, as <a href=https://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations>Smi</a>s. In a Smi, the least significant bit is a tag used to distinguish it from pointers, while the remaining 31 bits hold the actual integer value.<p>Normally, arrays store their length as a Smi. Since we know that the maximum capacity of this array is only 1022, we only need 10 bits to store the length. We can use the remaining 21 bits to store the hash code!<figure><img alt="" height=322 loading=lazy src=/_img/hash-code/properties-backing-store-array.png width=491></figure><h3 id=the-properties-backing-store-is-a-dictionary>The properties backing store is a dictionary <a href=#the-properties-backing-store-is-a-dictionary class=bookmark>#</a></h3><p>For the dictionary case, we increase the dictionary size by 1 word to store the hashcode in a dedicated slot at the beginning of the dictionary. We get away with potentially wasting a word of memory in this case, because the proportional increase in size isn’t as big as in the array case.<figure><img alt="" height=214 loading=lazy src=/_img/hash-code/properties-backing-store-dictionary.png width=446></figure><p>With these changes, the hash code lookup no longer has to go through the complex JavaScript property lookup machinery.<h2 id=performance-improvements>Performance improvements <a href=#performance-improvements class=bookmark>#</a></h2><p>The <a href=https://github.com/kpdecker/six-speed>SixSpeed</a> benchmark tracks the performance of Map and Set, and these changes resulted in a ~500% improvement.<figure><img alt="" height=386 loading=lazy src=/_img/hash-code/sixspeed.png width=1999></figure><p>This change caused a 5% improvement on the Basic benchmark in <a href=https://webkit.org/blog/7536/jsc-loves-es6/ >ARES6</a> as well.<figure><img alt="" height=505 loading=lazy src=/_img/hash-code/ares-6.png width=1999></figure><p>This also resulted in an 18% improvement in one of the benchmarks in the <a href=http://emberperf.eviltrout.com/ >Emberperf</a> benchmark suite that tests Ember.js.<figure><img alt="" height=609 loading=lazy src=/_img/hash-code/emberperf.jpg width=1987></figure></div><footer><div><picture><source srcset="/_img/avatars/sathya-gunasekaran.avif, /_img/avatars/sathya-gunasekaran@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/sathya-gunasekaran.jpg width=96 srcset="/_img/avatars/sathya-gunasekaran@2x.jpg 2x"></picture><p>作者：<a href=https://twitter.com/_gsathya>Sathya Gunasekaran</a>, keeper of hash codes.</div><a href=https://twitter.com/v8js/status/958046113390411776 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/hash-code>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/hash-code.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>