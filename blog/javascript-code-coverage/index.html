<!doctype html><html lang=zh-CN><meta charset=utf-8><title>JavaScript code coverage · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="V8 now has native support for JavaScript code coverage. Tools can now access V8’s coverage information without instrumenting the code!" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>JavaScript code coverage</h1><p class=meta>发布时间 <time datetime="2017-12-13 13:33:37" itemprop=datePublished title="2017-12-13 13:33:37">2017-12-13</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a></header><div itemprop=articleBody><p>Code coverage provides information about whether, and optionally how often certain parts of an application have been executed. It’s commonly used to determine how thoroughly a test suite exercises a particular codebase.<h2 id=why-is-it-useful%3F>Why is it useful? <a href=#why-is-it-useful%3F class=bookmark>#</a></h2><p>As a JavaScript developer, you may often find yourself in a situation in which code coverage could be useful. For instance:<ul><li>Interested in the quality of your test suite? Refactoring a large legacy project? Code coverage can show you exactly which parts of your codebase is covered.<li>Want to quickly know if a particular part of the codebase is reached? Instead of instrumenting with <code>console.log</code> for <code>printf</code>-style debugging or manually stepping through the code, code coverage can display live information about which parts of your applications have been executed.<li>Or maybe you’re optimizing for speed and would like to know which spots to focus on? Execution counts can point out hot functions and loops.</ul><h2 id=javascript-code-coverage-in-v8>JavaScript code coverage in V8 <a href=#javascript-code-coverage-in-v8 class=bookmark>#</a></h2><p>Earlier this year, we added native support for JavaScript code coverage to V8. The initial release in version 5.9 provided coverage at function granularity (showing which functions have been executed), which was later extended to support coverage at block granularity in v6.2 (likewise, but for individual expressions).<figure><img alt="" height=180 loading=lazy src=/_img/javascript-code-coverage/function-vs-block.png width=488><figcaption>Function granularity (left) and block granularity (right)</figcaption></figure><h3 id=for-javascript-developers>For JavaScript developers <a href=#for-javascript-developers class=bookmark>#</a></h3><p>There are currently two primary ways to access coverage information. For JavaScript developers, Chrome DevTools’ <a href=https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage>Coverage tab</a> exposes JS (and CSS) coverage ratios and highlights dead code in the Sources panel.<figure><img alt="" height=491 loading=lazy src=/_img/javascript-code-coverage/block-coverage.png width=604><figcaption>Block coverage in the DevTools Coverage pane. Covered lines are highlighted in green, uncovered in red.</figcaption></figure><p>Thanks to <a href=https://twitter.com/BenjaminCoe>Benjamin Coe</a>, there is also <a href=https://github.com/bcoe/c8>ongoing</a> work to integrate V8’s code coverage information into the popular <a href=https://istanbul.js.org/ >Istanbul.js</a> code coverage tool.<figure><img alt="" height=847 loading=lazy src=/_img/javascript-code-coverage/istanbul.png width=1600><figcaption>An Istanbul.js report based on V8 coverage data.</figcaption></figure><h3 id=for-embedders>For embedders <a href=#for-embedders class=bookmark>#</a></h3><p>Embedders and framework authors can hook directly into the Inspector API for more flexibility. V8 offers two different coverage modes:<ol><li><p><em>Best-effort coverage</em> collects coverage information with minimal impact on runtime performance, but might lose data on garbage-collected (GC) functions.<li><p><em>Precise coverage</em> ensures that no data is lost to the GC, and users can choose to receive execution counts instead of binary coverage information; but performance might be impacted by increased overhead (see the next section for more details). Precise coverage can be collected either at function or block granularity.</ol><p>The Inspector API for precise coverage is as follows:<ul><li><p><a href=https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-startPreciseCoverage><code>Profiler.startPreciseCoverage(callCount, detailed)</code></a> enables coverage collection, optionally with call counts (vs. binary coverage) and block granularity (vs. function granularity);<li><p><a href=https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-takePreciseCoverage><code>Profiler.takePreciseCoverage()</code></a> returns collected coverage information as a list of source ranges together with associated execution counts; and<li><p><a href=https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-stopPreciseCoverage><code>Profiler.stopPreciseCoverage()</code></a> disables collection and frees related data structures.</ul><p>A conversation through the Inspector protocol might look like this:<pre class=language-json><code class=language-json><span class="token comment">// The embedder directs V8 to begin collecting precise coverage.</span><br><span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token property">"method"</span><span class="token operator">:</span> <span class="token string">"Profiler.startPreciseCoverage"</span><span class="token punctuation">,</span><br>            <span class="token property">"params"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"callCount"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token property">"detailed"</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><br><span class="token comment">// Embedder requests coverage data (delta since last request).</span><br><span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token property">"method"</span><span class="token operator">:</span><span class="token string">"Profiler.takePreciseCoverage"</span> <span class="token punctuation">}</span><br><span class="token comment">// The reply contains collection of nested source ranges.</span><br><span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token property">"result"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"result"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><br>  <span class="token property">"functions"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token punctuation">{</span><br>      <span class="token property">"functionName"</span><span class="token operator">:</span> <span class="token string">"fib"</span><span class="token punctuation">,</span><br>      <span class="token property">"isBlockCoverage"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token comment">// Block granularity.</span><br>      <span class="token property">"ranges"</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token comment">// An array of nested ranges.</span><br>        <span class="token punctuation">{</span><br>          <span class="token property">"startOffset"</span><span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">,</span>  <span class="token comment">// Byte offset, inclusive.</span><br>          <span class="token property">"endOffset"</span><span class="token operator">:</span> <span class="token number">224</span><span class="token punctuation">,</span>   <span class="token comment">// Byte offset, exclusive.</span><br>          <span class="token property">"count"</span><span class="token operator">:</span> <span class="token number">1</span><br>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>          <span class="token property">"startOffset"</span><span class="token operator">:</span> <span class="token number">97</span><span class="token punctuation">,</span><br>          <span class="token property">"endOffset"</span><span class="token operator">:</span> <span class="token number">107</span><span class="token punctuation">,</span><br>          <span class="token property">"count"</span><span class="token operator">:</span> <span class="token number">0</span><br>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>          <span class="token property">"startOffset"</span><span class="token operator">:</span> <span class="token number">134</span><span class="token punctuation">,</span><br>          <span class="token property">"endOffset"</span><span class="token operator">:</span> <span class="token number">144</span><span class="token punctuation">,</span><br>          <span class="token property">"count"</span><span class="token operator">:</span> <span class="token number">0</span><br>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>          <span class="token property">"startOffset"</span><span class="token operator">:</span> <span class="token number">192</span><span class="token punctuation">,</span><br>          <span class="token property">"endOffset"</span><span class="token operator">:</span> <span class="token number">223</span><span class="token punctuation">,</span><br>          <span class="token property">"count"</span><span class="token operator">:</span> <span class="token number">0</span><br>        <span class="token punctuation">}</span><span class="token punctuation">,</span><br>      <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span><br>      <span class="token property">"scriptId"</span><span class="token operator">:</span> <span class="token string">"199"</span><span class="token punctuation">,</span><br>      <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"file:///coverage-fib.html"</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">]</span><br><span class="token punctuation">}</span><span class="token punctuation">}</span><br><br><span class="token comment">// Finally, the embedder directs V8 to end collection and</span><br><span class="token comment">// free related data structures.</span><br><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token property">"method"</span><span class="token operator">:</span><span class="token string">"Profiler.stopPreciseCoverage"</span><span class="token punctuation">}</span></code></pre><p>Similarly, best-effort coverage can be retrieved using <a href=https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-getBestEffortCoverage><code>Profiler.getBestEffortCoverage()</code></a>.<h2 id=behind-the-scenes>Behind the scenes <a href=#behind-the-scenes class=bookmark>#</a></h2><p>As stated in the previous section, V8 supports two main modes of code coverage: best-effort and precise coverage. Read on for an overview of their implementation.<h3 id=best-effort-coverage>Best-effort coverage <a href=#best-effort-coverage class=bookmark>#</a></h3><p>Both best-effort and precise coverage modes heavily reuse other V8 mechanisms, the first of which is called the <em>invocation counter</em>. Each time a function is called through V8’s <a href=/blog/ignition-interpreter>Ignition</a> interpreter, we <a href="https://cs.chromium.org/chromium/src/v8/src/builtins/x64/builtins-x64.cc?l=917&rcl=fc33dfbebfb1cb800d490af97bf1019e9d66be33">increment an invocation counter</a> on the function’s <a href=http://slides.com/ripsawridge/deck>feedback vector</a>. As the function later becomes hot and tiers up through the optimizing compiler, this counter is used to help guide inlining decisions about which functions to inline; and now, we also rely on it to report code coverage.<p>The second reused mechanism determines the source range of functions. When reporting code coverage, invocation counts need to be tied to an associated range within the source file. For example, in the example below, we not only need to report that function <code>f</code> has been executed exactly once, but also that <code>f</code>’s source range begins at line 1 and ends in line 3.<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Again we got lucky and were able to reuse existing information within V8. Functions already knew their start- and end positions within source code due to <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString><code>Function.prototype.toString</code></a>, which needs to know the function’s location within the source file to extract the appropriate substring.<p>When collecting best-effort coverage, these two mechanisms are simply tied together: first we find all live function by traversing the entire heap. For each seen function we report the invocation count (stored on the feedback vector, which we can reach from the function) and source range (conveniently stored on the function itself).<p>Note that since invocation counts are maintained regardless of whether coverage is enabled, best-effort coverage does not introduce any runtime overhead. It also does not use dedicated data structures and thus neither needs to be explicitly enabled or disabled.<p>So why is this mode called best-effort, what are its limitations? Functions that go out of scope may be freed by the garbage collector. This means that associated invocation counts are lost, and in fact we completely forget that these functions ever existed. Ergo ‘best-effort’: even though we try our best, the collected coverage information may be incomplete.<h3 id=precise-coverage-(function-granularity)>Precise coverage (function granularity) <a href=#precise-coverage-(function-granularity) class=bookmark>#</a></h3><p>In contrast to the best-effort mode, precise coverage guarantees that the provided coverage information is complete. To achieve this, we add all feedback vectors to V8’s root set of references once precise coverage is enabled, preventing their collection by the GC. While this ensures no information is lost, it increases memory consumption by keeping objects alive artificially.<p>The precise coverage mode can also provide execution counts. This adds another wrinkle to the precise coverage implementation. Recall that the invocation counter is incremented each time a function is called through V8’s interpreter, and that functions can tier up and be optimized once they become hot. But optimized functions no longer increment their invocation counter, and thus the optimizing compiler must be disabled for their reported execution count to remain accurate.<h3 id=precise-coverage-(block-granularity)>Precise coverage (block granularity) <a href=#precise-coverage-(block-granularity) class=bookmark>#</a></h3><p>Block-granularity coverage must report coverage that is correct down to the level of individual expressions. For example, in the following piece of code, block coverage could detect that the <code>else</code> branch of the conditional expression <code>: c</code> is never executed, while function granularity coverage would only know that the function <code>f</code> (in its entirety) is covered.<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> a <span class="token operator">?</span> b <span class="token operator">:</span> c<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>You may recall from the previous sections that we already had function invocation counts and source ranges readily available within V8. Unfortunately, this was not the case for block coverage and we had to implement new mechanisms to collect both execution counts and their corresponding source ranges.<p>The first aspect is source ranges: assuming we have an execution count for a particular block, how can we map them to a section of the source code? For this, we need to collect relevant positions while parsing the source files. Prior to block coverage, V8 already did this to some extent. One example is the collection of function ranges due to <code>Function.prototype.toString</code> as described above. Another is that source positions are used to construct the backtrace for Error objects. But neither of these is sufficient to support block coverage; the former is only available for functions, while the latter only stores positions (e.g. the position of the <code>if</code> token for <code>if</code>-<code>else</code> statements), not source ranges.<p>We therefore had to extend the parser to collect source ranges. To demonstrate, consider an <code>if</code>-<code>else</code> statement:<pre class=language-js><code class=language-js><span class="token keyword">if</span> <span class="token punctuation">(</span>cond<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">/* Then branch. */</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>  <span class="token comment">/* Else branch. */</span><br><span class="token punctuation">}</span></code></pre><p>When block coverage is enabled, we <a href="https://cs.chromium.org/chromium/src/v8/src/parsing/parser-base.h?l=5199&rcl=cd23cae9edc134ecfe16a4868266dcf5ec432cbf">collect</a> the source range of the <code>then</code> and <code>else</code> branches and associate them with the parsed <code>IfStatement</code> AST node. The same is done for other relevant language constructs.<p>After collecting source range collection during parsing, the second aspect is tracking execution counts at runtime. This is done by <a href="https://cs.chromium.org/chromium/src/v8/src/interpreter/control-flow-builders.cc?l=207&rcl=cd23cae9edc134ecfe16a4868266dcf5ec432cbf">inserting</a> a new dedicated <code>IncBlockCounter</code> bytecode at strategic positions within the generated bytecode array. At runtime, the <code>IncBlockCounter</code> bytecode handler simply <a href="https://cs.chromium.org/chromium/src/v8/src/runtime/runtime-debug.cc?l=2012&rcl=cd23cae9edc134ecfe16a4868266dcf5ec432cbf">increments</a> the appropriate counter (reachable through the function object).<p>In the above example of an <code>if</code>-<code>else</code> statement, such bytecodes would be inserted at three spots: immediately prior to the body of the <code>then</code> branch, prior to the body of the <code>else</code> branch, and immediately after the <code>if</code>-<code>else</code> statement (such continuation counters are needed due to possibility of non-local control within a branch).<p>Finally, reporting block-granularity coverage works similarly to function-granularity reporting. But in addition to invocations counts (from the feedback vector), we now also report the collection of <em>interesting</em> source ranges together with their block counts (stored on an auxiliary data structure that hangs off the function).<p>If you’d like to learn more about the technical details behind code coverage in V8, see the <a href=https://goo.gl/WibgXw>coverage</a> and <a href=https://goo.gl/hSJhXn>block coverage</a> design documents.<h2 id=conclusion>Conclusion <a href=#conclusion class=bookmark>#</a></h2><p>We hope you’ve enjoyed this brief introduction to V8’s native code coverage support. Please give it a try and don’t hesitate to let us know what works for you, and what doesn’t. Say hello on Twitter (<a href=https://twitter.com/schuay>@schuay</a> and <a href=https://twitter.com/hashseed>@hashseed</a>) or file a bug at <a href=https://crbug.com/v8/new>crbug.com/v8/new</a>.<p>Coverage support in V8 has been a team effort, and thanks are in order to everyone that has contributed: Benjamin Coe, Jakob Gruber, Yang Guo, Marja Hölttä, Andrey Kosyakov, Alexey Kozyatinksiy, Ross McIlroy, Ali Sheikh, Michael Starzinger. Thank you!</div><footer><div><picture><source srcset="/_img/avatars/jakob-gruber.avif, /_img/avatars/jakob-gruber@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/jakob-gruber.jpg width=96 srcset="/_img/avatars/jakob-gruber@2x.jpg 2x"></picture><p>作者：Jakob Gruber (<a href=https://twitter.com/schuay>@schuay</a>).</div><a href=https://twitter.com/v8js/status/940879905079873536 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/javascript-code-coverage>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/javascript-code-coverage.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>