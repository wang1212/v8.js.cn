<!doctype html><html lang=zh-CN><meta charset=utf-8><title>V8 release v7.8 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="V8 v7.8 features streaming compilation on preload, WebAssembly C API, faster object destructuring and RegExp matching, and improved startup times." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>V8 release v7.8</h1><p class=meta>发布时间 <time datetime="2019-09-27 00:00:00" itemprop=datePublished title="2019-09-27 00:00:00">2019-09-27</time> · 标签： <a href=/blog/tags/release/ class=tag>release</a></header><div itemprop=articleBody><p>Every six weeks, we create a new branch of V8 as part of our <a href=/docs/release-process>release process</a>. Each version is branched from V8’s Git master immediately before a Chrome Beta milestone. Today we’re pleased to announce our newest branch, <a href=https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/7.8>V8 version 7.8</a>, which is in beta until its release in coordination with Chrome 78 Stable in several weeks. V8 v7.8 is filled with all sorts of developer-facing goodies. This post provides a preview of some of the highlights in anticipation of the release.<h2 id=performance>JavaScript performance (size & speed) <a href=#performance class=bookmark>#</a></h2><h3 id=script-streaming-on-preload>Script streaming on preload <a href=#script-streaming-on-preload class=bookmark>#</a></h3><p>You might remember <a href=/blog/v8-release-75#script-streaming-directly-from-network>our script streaming work from V8 v7.5</a>, where we improved our background compilation to read data directly from the network. In Chrome 78, we are enabling script streaming during preload.<p>Previously, script streaming started when a <code>&lt;script></code> tag was encountered during HTML parsing, and the parsing would either pause until compilation finished (for normal scripts) or the script would execute once it finished compiling (for async scripts). This means that for normal, synchronous scripts like this:<pre class=language-html><code class=language-html><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><br>...</code></pre><p>…the pipeline would previously look roughly like this:<figure><img alt="" height=130 loading=lazy src=/_img/v8-release-78/script-streaming-0.svg width=458></figure><p>Since synchronous scripts can use <code>document.write()</code>, we have to pause parsing the HTML when we see the <code>&lt;script></code> tag. Since compilation starts when the <code>&lt;script></code> tag is encountered, there’s a big gap between parsing the HTML and actually running the script, during which we can’t continue loading the page.<p>However, we <em>also</em> encounter the <code>&lt;script></code> tag in an earlier stage, where we scan the HTML looking for resources to preload, so the pipeline was really more like this:<figure><img alt="" height=130 loading=lazy src=/_img/v8-release-78/script-streaming-1.svg width=600></figure><p>It’s a reasonably safe assumption that if we preload a JavaScript file, we’ll want to execute it eventually. So, since Chrome 76, we’ve been experimenting with preload streaming, where loading the script also starts compiling it.<figure><img alt="" height=130 loading=lazy src=/_img/v8-release-78/script-streaming-2.svg width=495></figure><p>Even better, since we can start compiling before the script finishes loading, the pipeline with preload streaming actually looks more like this:<figure><img alt="" height=217 loading=lazy src=/_img/v8-release-78/script-streaming-3.svg width=480></figure><p>This means that in some cases we can reduce perceptible compilation time (the gap between <code>&lt;script></code>-tag-seen and script-starting-to-execute) down to zero. In our experiments, this perceptible compilation time dropped, on average, by 5–20%.<p>The best news is that thanks to our experimentation infrastructure, we’ve been able to not only enable this by default in Chrome 78, but also turn it on it for users of Chrome 76 onwards.<h3 id=faster-object-destructuring>Faster object destructuring <a href=#faster-object-destructuring class=bookmark>#</a></h3><p>Object destructuring of the form…<pre class=language-js><code class=language-js><span class="token keyword">const</span> <span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span> <span class="token operator">=</span> object<span class="token punctuation">;</span></code></pre><p>…is almost equivalent to the desugared form...<pre class=language-js><code class=language-js><span class="token keyword">const</span> x <span class="token operator">=</span> object<span class="token punctuation">.</span>x<span class="token punctuation">;</span><br><span class="token keyword">const</span> y <span class="token operator">=</span> object<span class="token punctuation">.</span>y<span class="token punctuation">;</span></code></pre><p>…except that it also needs to throw a special error for <code>object</code> being <code>undefined</code> or <code>null</code>...<pre><code>$ v8 -e 'const object = undefined; const {x, y} = object;'
unnamed:1: TypeError: Cannot destructure property `x` of 'undefined' or 'null'.
const object = undefined; const {x, y} = object;
                                 ^
</code></pre><p>…rather than the normal error you’d get when trying to dereference undefined:<pre><code>$ v8 -e 'const object = undefined; object.x'
unnamed:1: TypeError: Cannot read property 'x' of undefined
const object = undefined; object.x
                                 ^
</code></pre><p>This extra check made destructuring slower than simple variable assignment, as <a href=https://twitter.com/mkubilayk/status/1166360933087752197>reported to us via Twitter</a>.<p>As of V8 v7.8, object destructuring is <strong>as fast</strong> as the equivalent desugared variable assignment (in fact, we generate the same bytecode for both). Now, instead of explicit <code>undefined</code>/<code>null</code> checks, we rely on an exception being thrown when loading <code>object.x</code>, and we intercept the exception if it’s the result of destructuring.<h3 id=lazy-source-positions>Lazy source positions <a href=#lazy-source-positions class=bookmark>#</a></h3><p>When compiling bytecode from JavaScript, source position tables are generated that tie bytecode sequences to character positions within the source code. However, this information is only used when symbolizing exceptions or performing developer tasks such as debugging and profiling and so this is largely wasted memory.<p>To avoid this, we now compile bytecode without collecting source positions (assuming no debugger or profiler is attached). The source positions are only collected when a stack trace is actually generated, for instance when calling <code>Error.stack</code> or printing an exception’s stack trace to the console. This does have some cost, as generating source positions requires the function to be reparsed and compiled, however most websites don’t symbolize stack traces in production and therefore don’t see any observable performance impact. In our lab testing we saw between 1-2.5% reductions in V8’s memory usage.<figure><img alt="" height=432 loading=lazy src=/_img/v8-release-78/memory-savings.svg width=699><figcaption>Memory savings from lazy source positions on an AndroidGo device</figcaption></figure><h3 id=faster-regexp-match-failures>Faster RegExp match failures <a href=#faster-regexp-match-failures class=bookmark>#</a></h3><p>Generally, a RegExp attempts to find a match by iterating forward through the input string and checking for a match starting from each position. Once that position gets close enough to the end of the string that no match is possible, V8 now (in most cases) stops trying to find possible beginnings of new matches, and instead quickly returns a failure. This optimization applies to both compiled and interpreted regular expressions, and yields a speedup on workloads where failure to find a match is common, and the minimum length of any successful match is relatively large compared to the average input string length.<p>On the UniPoker test in JetStream 2, which inspired this work, V8 v7.8 brings a 20% improvement to the average-of-all-iterations subscore.<h2 id=webassembly>WebAssembly <a href=#webassembly class=bookmark>#</a></h2><h3 id=webassembly-c%2Fc%2B%2B-api>WebAssembly C/C++ API <a href=#webassembly-c%2Fc%2B%2B-api class=bookmark>#</a></h3><p>As of v7.8, V8’s implementation of the <a href=https://github.com/WebAssembly/wasm-c-api>Wasm C/C++ API</a> graduates from experimental status to being officially supported. It allows you to use a special build of V8 as a WebAssembly execution engine in your C/C++ applications. No JavaScript involved! For more details and instructions, see <a href=https://docs.google.com/document/d/1oFPHyNb_eXg6NzrE6xJDNPdJrHMZvx0LqsD6wpbd9vY/edit>the documentation</a>.<h3 id=improved-startup-time>Improved startup time <a href=#improved-startup-time class=bookmark>#</a></h3><p>Calling a JavaScript function from WebAssembly or a WebAssembly function from JavaScript involves executing some wrapper code, responsible for translating the function's arguments from one representation to the other. Generating these wrappers can be quite expensive: in the <a href=https://s3.amazonaws.com/mozilla-games/ZenGarden/EpicZenGarden.html>Epic ZenGarden demo</a>, compiling wrappers takes about 20% of the module startup time (compilation + instantiation) on an 18-core Xeon machine.<p>For this release, we improved the situation by making better use of background threads on multi-core machines. We relied on recent efforts to <a href=/blog/v8-release-77#wasm-compilation>scale function compilation</a>, and integrated wrapper compilation into this new asynchronous pipeline. Wrapper compilation now accounts for about 8% of the Epic ZenGarden demo startup time on the same machine.<h2 id=v8-api>V8 API <a href=#v8-api class=bookmark>#</a></h2><p>Please use <code>git log branch-heads/7.7..branch-heads/7.8 include/v8.h</code> to get a list of the API changes.<p>Developers with an <a href=/docs/source-code#using-git>active V8 checkout</a> can use <code>git checkout -b 7.8 -t branch-heads/7.8</code> to experiment with the new features in V8 v7.8. Alternatively you can <a href=https://www.google.com/chrome/browser/beta.html>subscribe to Chrome’s Beta channel</a> and try the new features out yourself soon.</div><footer><div><picture><source srcset="/_img/avatars/ingvar-stepanyan.avif, /_img/avatars/ingvar-stepanyan@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/ingvar-stepanyan.jpg width=96 srcset="/_img/avatars/ingvar-stepanyan@2x.jpg 2x"></picture><p>作者：Ingvar Stepanyan (<a href=https://twitter.com/RReverser>@RReverser</a>), the lazy sourcerer.</div><a href=https://twitter.com/v8js/status/1177600702861971459 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/v8-release-78>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/v8-release-78.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>