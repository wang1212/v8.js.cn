<!doctype html><html lang=zh-CN><meta charset=utf-8><title>理解 ECMAScript 规范, 第1部分 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Tutorial on reading the ECMAScript specification" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>理解 ECMAScript 规范, 第1部分</h1><p class=meta>发布时间 <time datetime="2020-02-03 13:33:37" itemprop=datePublished title="2020-02-03 13:33:37">2020-02-03</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a> <a href=/blog/tags/understanding-ecmascript/ class=tag>Understanding ECMAScript</a></header><div itemprop=articleBody><p>在这篇文章里，我们取规范中一个简单的函数并尝试理解他的符号。让我们开始吧！<p><a href=/blog/tags/understanding-ecmascript>All episodes</a><h2 id=preface>前言 <a href=#preface class=bookmark>#</a></h2><p>即使你知道 JavaScript，读它的语言规范, <a href=https://tc39.es/ecma262/ >ECMAScript Language specification, or the ECMAScript spec for short</a>，也可能会令人生畏，至少我第一次读它的时候是这样想的。<p>让我们从一个具体的示例开始，通过阅读规范来理解它。以下代码演示了 <code>Object.prototype.hasOwnProperty</code> 的使用：<pre class=language-js><code class=language-js><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>o<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br>o<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre><p>在案例中，<code>o</code> 没有 <code>hasOwnProperty</code> 这个属性，所以我们沿着原型链寻找它。我们在 <code>o</code> 的原型链上找到它，也就是 <code>Object.prototype</code>。<p>为了描述 <code>Object.prototype.hasOwnProperty</code> 是如何工作的，规范使用类似伪代码的描述:<div class=ecmascript-algorithm><blockquote><p><strong><a href=https://tc39.es/ecma262#sec-object.prototype.hasownproperty><code>Object.prototype.hasOwnProperty(V)</code></a></strong><p>当使用参数 <code>V</code> 调用 <code>hasOwnProperty</code> 方法时，会采取以下步骤：<ol><li>Let <code>P</code> be <code>? ToPropertyKey(V)</code>.<li>Let <code>O</code> be <code>? ToObject(this value)</code>.<li>Return <code>? HasOwnProperty(O, P)</code>.</ol></blockquote></div><p>然后。。。<div class=ecmascript-algorithm><blockquote><p><strong><a href=https://tc39.es/ecma262#sec-hasownproperty><code>HasOwnProperty(O, P)</code></a></strong><p>抽象操作 <code>HasOwnProperty</code> 用于确定对象是否具有带有指定属性的自己的属性。返回一个布尔值。该操作使用参数 <code>O</code> 和 <code>P</code> 进行调用，其中 <code>O</code> 是对象，<code>P</code> 是属性。此抽象操作执行以下步骤：<ol><li>Assert: <code>Type(O)</code> is <code>Object</code>.<li>Assert: <code>IsPropertyKey(P)</code> is <code>true</code>.<li>Let <code>desc</code> be <code>? O.[[GetOwnProperty]](P)</code>.<li>If <code>desc</code> is <code>undefined</code>, return <code>false</code>.<li>Return <code>true</code>.</ol></blockquote></div><p>但是什么是 “抽象操作” ？<code>[[]]</code> 里有什么东西？为什么在函数前有一个问号？断言是什么意思？<p>让我们来看一看！<h2 id=language-and-specification-types>语言类型和规范类型 <a href=#language-and-specification-types class=bookmark>#</a></h2><p>让我们从看起来熟悉的东西开始。规范上使用 <code>undefined</code>，<code>true</code> 和 <code>false</code> 等值，我们已经从JavaScript中知道这些值。他们都是 <a href=https://tc39.es/ecma262/#sec-ecmascript-language-types><strong>语言值</strong></a>, 也是规范中定义的 <strong>语言类型</strong> 的值。<p>规范还在内部使用语言值，例如，内部数据类型可能包含一个字段，其可能值为 <code>true</code> 和 <code>false</code>。相反，JavaScript 引擎通常在内部不使用语言值。例如，如果 JavaScript 引擎是用 C++ 编写的，则通常会使用 C++ 的 <code>true</code> 和 <code>false</code>（而不是其 JavaScript 的 <code>true</code> 和 <code>false</code> 的内部表示形式）。<p>除语言类型外，规范还使用<a href=https://tc39.es/ecma262/#sec-ecmascript-specification-types><strong>规范类型</strong></a>，这些类型仅在规范中出现，但不在 JavaScript 语言中。JavaScript 引擎不需要（但可以自由）实现它们。在此博客文章中，我们将了解规范类型 Record（及其子类型 Completion Record）。<h2 id=abstract-operations>抽象操作 <a href=#abstract-operations class=bookmark>#</a></h2><p><a href=https://tc39.es/ecma262/#sec-abstract-operations><strong>抽象操作</strong></a> 是 ECMAScript 规范中定义的函数；定义它们是为了简洁地编写规范。JavaScript 引擎不必将其作为单独的函数实现在引擎内部。不能在 JavaScript 直接调用它们。<h2 id=internal-slots-and-methods>内部插槽和内部方法 <a href=#internal-slots-and-methods class=bookmark>#</a></h2><p><a href=https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots><strong>内部插槽</strong> and <strong>内部方法</strong></a> 使用 <code>[[ ]]</code> 中包含的名称.<p>内部插槽是 JavaScript 对象或规范类型的数据成员。它们用于存储对象的状态。内部方法是 JavaScript 对象的成员函数。<p>例如，每个JavaScript对象都有一个内部插槽 <code>[[Prototype]]</code> 和一个内部方法 <code>[[GetOwnProperty]]</code>.<p>我们无法从 JavaScript 中访问内部插槽和方法。例如，您无法访问 <code>o.[[Prototype]]</code> 或者调用 <code>o.[[GetOwnProperty]]()</code>。JavaScript 引擎可以实现它们以供内部使用，但不是必须的。<p>有时内部方法委托给相似名称的抽象操作，例如在普通对象的 <code>[[GetOwnProperty]]</code> 中：<div class=ecmascript-algorithm><blockquote><p><strong><a href=https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p><code>[[GetOwnProperty]](P)</code></a></strong><p>使用属性 <code>P</code> 调用 <code>O</code> 的 <code>[[GetOwnProperty]]</code> 的内部方法时，将执行以下步骤：<ol><li>Return <code>! OrdinaryGetOwnProperty(O, P)</code>.</ol></blockquote></div><p>（我们将在下一章中找出感叹号的含义）<p><code>OrdinaryGetOwnProperty</code> 不是内部方法，因为它未与任何对象关联；而是将对其进行操作的对象作为参数传递。<p>因为 <code>OrdinaryGetOwnProperty</code> 只对普通对象对象起作用，所以它被称为 “普通的”。ECMAScript 对象可以是 <strong>普通的</strong> 或者 <strong>奇异的</strong>。普通对象必须具有称为 <strong>基本内部方法</strong> 的一组方法的默认行为。如果某个对象偏离默认行为，则该对象是奇异的。<p>最著名的奇异对象是 <code>Array</code>，因为其 length 属性的行为方式不是默认的：设置 <code>length</code> 属性可以从 <code>Array</code> 中删除元素。<p>基本的内部方法在 <a href=https://tc39.es/ecma262/#table-5>这里</a> 列出。<h2 id=completion-records>Completion records <a href=#completion-records class=bookmark>#</a></h2><p>问号和感叹号是什么呢？要了解它们，我们需要查看 <a href=https://tc39.es/ecma262/#sec-completion-record-specification-type><strong>Completion Records</strong></a>！<p>Completion Record 是一种规范类型（仅出于规范目的而定义）。JavaScript 引擎不必具有相应的内部数据类型。<p>Completion Record 是一种 “记录” —— 一种具有一组固定的命名字段的数据类型。一个 Completion Record 包含三个字段：<div class=table-wrapper><table><thead><tr><th>名称<th>描述<tbody><tr><td><code>[[Type]]</code><td><code>normal</code>，<code>break</code>，<code>continue</code>，<code>return</code> 或 <code>throw</code> 之一。除了 <code>normal</code> 以外的其他类型都是 <strong>突然中止</strong>.<tr><td><code>[[Value]]</code><td>结束时产生的值，例如，函数的返回值或异常（如果引发了异常）。<tr><td><code>[[Target]]</code><td>用于定向控制转移（与本博客文章无关）</table></div><p>每个抽象操作都隐式返回一个 Completion Record。即使看起来抽象操作会返回一个简单的类型，例如Boolean，它也将被隐式包装为具有 <code>normal</code> 类型的 Completion Record (请参见 <a href=https://tc39.es/ecma262/#sec-implicit-completion-values>Implicit Completion Values</a>).<p>注1：规范在这方面并不完全一致；有些帮助函数返回裸值，并且其返回值按原样使用，而无需从 Completion Record 中提取值。从上下文中通常可以清楚地看出这一点。<p>注2：规范的编辑人员正在研究如何使 Completion Record 的处理更加明确.<p>如果算法引发异常，则意味着返回带有 <code>[[Type]]</code> <code>throw</code> 的 Completion Record，它的 <code>[[Value]]</code> 是一个异常对象的。我们暂且忽略 <code>break</code>，<code>continue</code> 和 <code>return</code> 类型。<p><a href=https://tc39.es/ecma262/#sec-returnifabrupt><code>ReturnIfAbrupt(argument)</code></a> 意味着采取以下步骤：<div class=ecmascript-algorithm><blockquote><ol><li>If <code>argument</code> is abrupt, return <code>argument</code><li>Set <code>argument</code> to <code>argument.[[Value]]</code>.</ol></blockquote></div><p>也就是说，我们检查 Completion Record；如果是突然终止的类型，我们会立即返回。否则，我们从完成记录中提取值。<p><code>ReturnIfAbrupt</code> 可能看起来像一个函数调用，但事实并非如此。它会导致返回 <code>ReturnIfAbrupt()</code> 的函数返回，而不是返回 <code>ReturnIfAbrupt</code> 函数本身的函数。它更像是C语言中的宏.<p><code>ReturnIfAbrupt</code> 可以这样使用：<div class=ecmascript-algorithm><blockquote><ol><li>Let <code>obj</code> be <code>Foo()</code>. (<code>obj</code> 是一个 Completion Record。)<li><code>ReturnIfAbrupt(obj)</code><li><code>Bar(obj)</code>. (如果程序能走到这，则 <code>obj</code> 是从 Completion Record 提取出的值。)</ol></blockquote></div><p><a href=https://tc39.es/ecma262/#sec-returnifabrupt-shorthands>问号</a> 的含义：<code>? Foo()</code> 等同于 <code>ReturnIfAbrupt(Foo())</code>.<p>同样，<code>Let val be ! Foo()</code> 等同于：<div class=ecmascript-algorithm><blockquote><ol><li>Let <code>val</code> be <code>Foo()</code>.<li>Assert: <code>val</code> is not an abrupt completion.<li>Set <code>val</code> to <code>val.[[Value]]</code>.</ol></blockquote></div><p>利用这些知识，我们可以像这样重写 <code>Object.prototype.hasOwnProperty</code>：<div class=ecmascript-algorithm><blockquote><p><strong><code>Object.prototype.hasOwnProperty(V)</code></strong><ol><li>Let <code>P</code> be <code>ToPropertyKey(V)</code>.<li>If <code>P</code> is an abrupt completion, return <code>P</code><li>Set <code>P</code> to <code>P.[[Value]]</code><li>Let <code>O</code> be <code>ToObject(this value)</code>.<li>If <code>O</code> is an abrupt completion, return <code>O</code><li>Set <code>O</code> to <code>O.[[Value]]</code><li>Let <code>temp</code> be <code>HasOwnProperty(O, P)</code>.<li>If <code>temp</code> is an abrupt completion, return <code>temp</code><li>Let <code>temp</code> be <code>temp.[[Value]]</code><li>Return <code>NormalCompletion(temp)</code></ol></blockquote></div><p>我们可以这样重写 <code>HasOwnProperty</code>：<div class=ecmascript-algorithm><blockquote><p><strong><code>HasOwnProperty(O, P)</code></strong><ol><li>Assert: <code>Type(O)</code> is <code>Object</code>.<li>Assert: <code>IsPropertyKey(P)</code> is <code>true</code>.<li>Let <code>desc</code> be <code>O.[[GetOwnProperty]](P)</code>.<li>If <code>desc</code> is an abrupt completion, return <code>desc</code><li>Set <code>desc</code> to <code>desc.[[Value]]</code><li>If <code>desc</code> is <code>undefined</code>, return <code>NormalCompletion(false)</code>.<li>Return <code>NormalCompletion(true)</code>.</ol></blockquote></div><p>我们也可以重写不带感叹号的的内部方法 <code>[[GetOwnProperty]]</code>：<div class=ecmascript-algorithm><blockquote><p><strong><code>O.[[GetOwnProperty]]</code></strong><ol><li>Let <code>temp</code> be <code>OrdinaryGetOwnProperty(O, P)</code>.<li>Assert: <code>temp</code> is not an abrupt completion.<li>Let <code>temp</code> be <code>temp.[[Value]]</code>.<li>Return <code>NormalCompletion(temp)</code>.</ol></blockquote></div><p>在这里，我们假设 <code>temp</code> 是一个全新的临时变量，不会与其他任何冲突。<p>我们还使用了以下知识：当 return 语句返回除 Completion Record 以外的其他内容时，它隐式包装在 <code>NormalCompletion</code> 中.<h3 id=side-track>换个话题：<code>Return ? Foo()</code> <a href=#side-track class=bookmark>#</a></h3><p>规范中使用 <code>Return ? Foo()</code> —— 为什么用问号<p><code>Return ? Foo()</code> 展开如下：<div class=ecmascript-algorithm><blockquote><ol><li>Let <code>temp</code> be <code>Foo()</code>.<li>If <code>temp</code> is an abrupt completion, return <code>temp</code>.<li>Set <code>temp</code> to <code>temp.[[Value]]</code>.<li>Return <code>NormalCompletion(temp)</code>.</ol></blockquote></div><h2 id=asserts>断言 <a href=#asserts class=bookmark>#</a></h2><p>与 <code>Return Foo()</code> 相同；无论是突然终止还是正常终止，其行为方式都相同。<p>规范中断言了算法的不变条件。为了清楚起见，添加了它们，但没有对实现添加任何要求 —— 实现中不必检查它们。<h2 id=moving-on>继续 <a href=#moving-on class=bookmark>#</a></h2><p>我们已经建立了阅读规范所需的知识，如 <code>Object.prototype.hasOwnProperty</code> 之类的简单方法和诸如 <code>HasOwnProperty</code> 之类的抽象操作。它们仍然会委托到其他抽象操作，但是基于此博客文章，我们应该能够弄清楚它们的作用。我们还将会遇到属性描述符，这是另一种规范类型。<figure><img alt="" height=306 src=/_img/understanding-ecmascript-part-1/call-graph.svg width=1082 loading=lazy><figcaption>Function call graph starting from <code>Object.prototype.hasOwnProperty</code></figcaption></figure><h2 id=usful-links>有用的链接 <a href=#usful-links class=bookmark>#</a></h2><p><a href=https://timothygu.me/es-howto/ >How to Read the ECMAScript Specification</a>: a tutorial which covers much of the material covered in this post, from a slightly different angle.</div><footer><div><picture><source srcset="/_img/avatars/marja-holtta.avif, /_img/avatars/marja-holtta@2x.avif 2x" type=image/avif><img alt="" height=96 src=/_img/avatars/marja-holtta.jpg width=96 loading=lazy srcset="/_img/avatars/marja-holtta@2x.jpg 2x"></picture><p>作者：<a href=https://twitter.com/marjakh>Marja Hölttä</a>, speculative specification spectator.</div><a href=https://twitter.com/v8js/status/1224363301146189824 class=retweet>Retweet this article!</a></footer><footer><div><img alt="" height=96 src=/_img/avatars/vincent-wang.jpg width=96 srcset="/_img/avatars/vincent-wang@2x.jpg 2x" lazyload=on><p>译者：Vincent Wang (<a href=https://github.com/Vincent0700>@Vincent0700</a>)。<br>Blog：<a href=https://vincentstudio.info>https://vincentstudio.info</a>.</div></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/understanding-ecmascript-part-1>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/understanding-ecmascript-part-1.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>