<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Understanding the ECMAScript spec, part 2 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Tutorial on reading the ECMAScript specification, part 2" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Understanding the ECMAScript spec, part 2</h1><p class=meta>发布时间 <time datetime="2020-03-02 00:00:00" itemprop=datePublished title="2020-03-02 00:00:00">2020-03-02</time> · 标签： <a href=/blog/tags/ecmascript/ class=tag>ECMAScript</a> <a href=/blog/tags/understanding-ecmascript/ class=tag>Understanding ECMAScript</a></header><div itemprop=articleBody><p>Let’s practice our awesome spec reading skills some more. If you haven’t had a look at the previous episode, now it’s a good time to do so!<p><a href=/blog/tags/understanding-ecmascript>All episodes</a><h2 id=ready-for-part-2%3F>Ready for part 2? <a href=#ready-for-part-2%3F class=bookmark>#</a></h2><p>A fun way to get to know the spec is to start with a JavaScript feature we know is there, and find out how it’s specified.<blockquote><p>Warning! This episode contains copy-pasted algorithms from the <a href=https://tc39.es/ecma262/ >ECMAScript spec</a> as of February 2020. They’ll eventually be out of date.</blockquote><p>We know that properties are looked up in the prototype chain: if an object doesn’t have the property we’re trying to read, we walk up the prototype chain until we find it (or find an object which no longer has a prototype).<p>For example:<pre class=language-js><code class=language-js><span class="token keyword">const</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">99</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>o2<span class="token punctuation">,</span> o1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>o2<span class="token punctuation">.</span>foo<span class="token punctuation">;</span><br><span class="token comment">// → 99</span></code></pre><h2 id=prototype-walk>Where’s the prototype walk defined? <a href=#prototype-walk class=bookmark>#</a></h2><p>Let’s try to find out where this behavior is defined. A good place to start is a list of <a href=https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots>Object Internal Methods</a>.<p>There’s both <code>[[GetOwnProperty]]</code> and <code>[[Get]]</code> — we’re interested in the version that isn’t restricted to <em>own</em> properties, so we’ll go with <code>[[Get]]</code>.<p>Unfortunately, the <a href=https://tc39.es/ecma262/#sec-property-descriptor-specification-type>Property Descriptor specification type</a> also has a field called <code>[[Get]]</code>, so while browsing the spec for <code>[[Get]]</code>, we need to carefully distinguish between the two independent usages.<p><code>[[Get]]</code> is an <strong>essential internal method</strong>. <strong>Ordinary objects</strong> implement the default behavior for essential internal methods. <strong>Exotic objects</strong> can define their own internal method <code>[[Get]]</code> which deviates from the default behavior. In this post, we focus on ordinary objects.<p>The default implementation for <code>[[Get]]</code> delegates to <code>OrdinaryGet</code>:<div class=ecmascript-algorithm><blockquote><p><strong><a href=https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver><code>[[Get]] ( P, Receiver )</code></a></strong><p>When the <code>[[Get]]</code> internal method of <code>O</code> is called with property key <code>P</code> and ECMAScript language value <code>Receiver</code>, the following steps are taken:<ol><li>Return <code>? OrdinaryGet(O, P, Receiver)</code>.</ol></blockquote><p>We’ll see shortly that <code>Receiver</code> is the value which is used as the <strong>this value</strong> when calling a getter function of an accessor property.<p><code>OrdinaryGet</code> is defined like this:<div class=ecmascript-algorithm><blockquote><p><strong><a href=https://tc39.es/ecma262/#sec-ordinaryget><code>OrdinaryGet ( O, P, Receiver )</code></a></strong><p>When the abstract operation <code>OrdinaryGet</code> is called with Object <code>O</code>, property key <code>P</code>, and ECMAScript language value <code>Receiver</code>, the following steps are taken:<ol><li>Assert: <code>IsPropertyKey(P)</code> is <code>true</code>.<li>Let <code>desc</code> be <code>? O.[[GetOwnProperty]](P)</code>.<li>If <code>desc</code> is <code>undefined</code>, then<ol><li>Let <code>parent</code> be <code>? O.[[GetPrototypeOf]]()</code>.<li>If <code>parent</code> is <code>null</code>, return <code>undefined</code>.<li>Return <code>? parent.[[Get]](P, Receiver)</code>.</ol><li>If <code>IsDataDescriptor(desc)</code> is <code>true</code>, return <code>desc.[[Value]]</code>.<li>Assert: <code>IsAccessorDescriptor(desc)</code> is <code>true</code>.<li>Let <code>getter</code> be <code>desc.[[Get]]</code>.<li>If <code>getter</code> is <code>undefined</code>, return <code>undefined</code>.<li>Return <code>? Call(getter, Receiver)</code>.</ol></blockquote><p>The prototype chain walk is inside step 3: if we don’t find the property as an own property, we call the prototype’s <code>[[Get]]</code> method which delegates to <code>OrdinaryGet</code> again. If we still don’t find the property, we call its prototype’s <code>[[Get]]</code> method, which delegates to <code>OrdinaryGet</code> again, and so on, until we either find the property or reach an object without a prototype.<p>Let’s look at how this algorithm works when we access <code>o2.foo</code>. First we invoke <code>OrdinaryGet</code> with <code>O</code> being <code>o2</code> and <code>P</code> being <code>"foo"</code>. <code>O.[[GetOwnProperty]]("foo")</code> returns <code>undefined</code>, since <code>o2</code> doesn’t have an own property called <code>"foo"</code>, so we take the if branch in step 3. In step 3.a, we set <code>parent</code> to the prototype of <code>o2</code> which is <code>o1</code>. <code>parent</code> is not <code>null</code>, so we don’t return in step 3.b. In step 3.c, we call the parent’s <code>[[Get]]</code> method with property key <code>"foo"</code>, and return whatever it returns.<p>The parent (<code>o1</code>) is an ordinary object, so its <code>[[Get]]</code> method invokes <code>OrdinaryGet</code> again, this time with <code>O</code> being <code>o1</code> and <code>P</code> being <code>"foo"</code>. <code>o1</code> has an own property called <code>"foo"</code>, so in step 2, <code>O.[[GetOwnProperty]]("foo")</code> returns the associated Property Descriptor and we store it in <code>desc</code>.<p><a href=https://tc39.es/ecma262/#sec-property-descriptor-specification-type>Property Descriptor</a> is a specification type. Data Property Descriptors store the value of the property directly in the <code>[[Value]]</code> field. Accessor Property Descriptors store the accessor functions in fields <code>[[Get]]</code> and/or <code>[[Set]]</code>. In this case, the Property Descriptor associated with <code>"foo"</code> is a data Property Descriptor.<p>The data Property Descriptor we stored in <code>desc</code> in step 2 is not <code>undefined</code>, so we don’t take the <code>if</code> branch in step 3. Next we execute step 4. The Property Descriptor is a data Property Descriptor, so we return its <code>[[Value]]</code> field, <code>99</code>, in step 4, and we’re done.<h2 id=receiver>What’s <code>Receiver</code> and where is it coming from? <a href=#receiver class=bookmark>#</a></h2><p>The <code>Receiver</code> parameter is only used in the case of accessor properties in step 8. It’s passed as the <strong>this value</strong> when calling the getter function of an accessor property.<p><code>OrdinaryGet</code> passes the original <code>Receiver</code> throughout the recursion, unchanged (step 3.c). Let’s find out where the <code>Receiver</code> is originally coming from!<p>Searching for places where <code>[[Get]]</code> is called we find an abstract operation <code>GetValue</code> which operates on References. Reference is a specification type, consisting of a base value, the referenced name, and a strict reference flag. In the case of <code>o2.foo</code>, the base value is the Object <code>o2</code>, the referenced name is the String <code>"foo"</code>, and the strict reference flag is <code>false</code>, since the example code is sloppy.<h3 id=side-track%3A-why-is-reference-not-a-record%3F>Side track: Why is Reference not a Record? <a href=#side-track%3A-why-is-reference-not-a-record%3F class=bookmark>#</a></h3><p>Side track: Reference is not a Record, even though it sounds like it could be. It contains three components, which could equally well be expressed as three named fields. Reference is not a Record only because of historical reasons.<h3 id=back-to-getvalue>Back to <code>GetValue</code> <a href=#back-to-getvalue class=bookmark>#</a></h3><p>Let’s look at how <code>GetValue</code> is defined:<div class=ecmascript-algorithm><blockquote><p><strong><a href=https://tc39.es/ecma262/#sec-getvalue><code>GetValue ( V )</code></a></strong><ol><li><code>ReturnIfAbrupt(V)</code>.<li>If <code>Type(V)</code> is not <code>Reference</code>, return <code>V</code>.<li>Let <code>base</code> be <code>GetBase(V)</code>.<li>If <code>IsUnresolvableReference(V)</code> is <code>true</code>, throw a <code>ReferenceError</code> exception.<li>If <code>IsPropertyReference(V)</code> is <code>true</code>, then<ol><li>If <code>HasPrimitiveBase(V)</code> is <code>true</code>, then<ol><li>Assert: In this case, <code>base</code> will never be <code>undefined</code> or <code>null</code>.<li>Set <code>base</code> to <code>! ToObject(base)</code>.</ol><li>Return <code>? base.[[Get]](GetReferencedName(V), GetThisValue(V))</code>.</ol><li>Else,<ol><li>Assert: <code>base</code> is an Environment Record.<li>Return <code>? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V))</code></ol></ol></blockquote><p>The Reference in our example is <code>o2.foo</code>, which is a property reference. So we take branch 5. We don’t take the branch in 5.a, since the base (<code>o2</code>) is not <a href=/blog/react-cliff#javascript-types>a primitive value</a> (a Number, String, Symbol, BigInt, Boolean, Undefined, or Null).<p>Then we call <code>[[Get]]</code> in step 5.b. The <code>Receiver</code> we pass is <code>GetThisValue(V)</code>. In this case, it’s just the base value of the Reference:<div class=ecmascript-algorithm><blockquote><p><strong><a href=https://tc39.es/ecma262/#sec-getthisvalue><code>GetThisValue( V )</code></a></strong><ol><li>Assert: <code>IsPropertyReference(V)</code> is <code>true</code>.<li>If <code>IsSuperReference(V)</code> is <code>true</code>, then<ol><li>Return the value of the <code>thisValue</code> component of the reference <code>V</code>.</ol><li>Return <code>GetBase(V)</code>.</ol></blockquote><p>For <code>o2.foo</code>, we don’t take the branch in step 2, since it’s not a Super Reference (such as <code>super.foo</code>), but we take step 3 and return the base value of the Reference which is <code>o2</code>.<p>Piecing everything together, we find out that we set the <code>Receiver</code> to be the base of the original Reference, and then we keep it unchanged during the prototype chain walk. Finally, if the property we find is an accessor property, we use the <code>Receiver</code> as the <strong>this value</strong> when calling it.<p>In particular, the <strong>this value</strong> inside a getter refers to the original object where we tried to get the property from, not the one where we found the property during the prototype chain walk.<p>Let’s try it out!<pre class=language-js><code class=language-js><span class="token keyword">const</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">get</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>o2<span class="token punctuation">,</span> o1<span class="token punctuation">)</span><span class="token punctuation">;</span><br>o2<span class="token punctuation">.</span>foo<span class="token punctuation">;</span><br><span class="token comment">// → 50</span></code></pre><p>In this example, we have an accessor property called <code>foo</code> and we define a getter for it. The getter returns <code>this.x</code>.<p>Then we access <code>o2.foo</code> - what does the getter return?<p>We found out that when we call the getter, the <strong>this value</strong> is the object where we originally tried to get the property from, not the object where we found it. In this case the <strong>this value</strong> is <code>o2</code>, not <code>o1</code>. We can verify that by checking whether the getter returns <code>o2.x</code> or <code>o1.x</code>, and indeed, it returns <code>o2.x</code>.<p>It works! We were able to predict the behavior of this code snippet based on what we read in the spec.<h2 id=property-access-get>Accessing properties — why does it invoke <code>[[Get]]</code>? <a href=#property-access-get class=bookmark>#</a></h2><p>Where does the spec say that the Object internal method <code>[[Get]]</code> will get invoked when accessing a property like <code>o2.foo</code>? Surely that has to be defined somewhere. Don’t take my word for it!<p>We found out that the Object internal method <code>[[Get]]</code> is called from the abstract operation <code>GetValue</code> which operates on References. But where is <code>GetValue</code> called from?<h3 id=memberexpression>Runtime semantics for <code>MemberExpression</code> <a href=#memberexpression class=bookmark>#</a></h3><p>The grammar rules of the spec define the syntax of the language. <a href=https://tc39.es/ecma262/#sec-runtime-semantics>Runtime semantics</a> define what the syntactic constructs “mean” (how to evaluate them at runtime).<p>If you’re not familiar with <a href=https://en.wikipedia.org/wiki/Context-free_grammar>context-free grammars</a>, it’s a good idea to have a look now!<p>We’ll take a deeper look into the grammar rules in a later episode, let’s keep it simple for now! In particular, we can ignore the subscripts (<code>Yield</code>, <code>Await</code> and so on) in the productions for this episode.<p>The following productions describe what a <a href=https://tc39.es/ecma262/#prod-MemberExpression><code>MemberExpression</code></a> looks like:<pre class=language-grammar><code class=language-grammar><span class="token production-name">MemberExpression</span> <span class="token literal">:</span><br>  <span class="token production-name">PrimaryExpression</span><br>  <span class="token production-name">MemberExpression</span> <span class="token literal">[</span> <span class="token production-name">Expression</span> <span class="token literal">]</span><br>  <span class="token production-name">MemberExpression</span> <span class="token literal">.</span> <span class="token production-name">IdentifierName</span><br>  <span class="token production-name">MemberExpression</span> <span class="token production-name">TemplateLiteral</span><br>  <span class="token production-name">SuperProperty</span><br>  <span class="token production-name">MetaProperty</span><br>  <span class="token literal">new</span> <span class="token production-name">MemberExpression</span> <span class="token production-name">Arguments</span></code></pre><p>Here we have 7 productions for <code>MemberExpression</code>. A <code>MemberExpression</code> can be just a <code>PrimaryExpression</code>. Alternatively, a <code>MemberExpression</code> can be constructed from another <code>MemberExpression</code> and <code>Expression</code> by piecing them together: <code>MemberExpression [ Expression ]</code>, for example <code>o2['foo']</code>. Or it can be <code>MemberExpression . IdentifierName</code>, for example <code>o2.foo</code> — this is the production relevant for our example.<p>Runtime semantics for the production <code>MemberExpression : MemberExpression . IdentifierName</code> define the set of steps to take when evaluating it:<div class=ecmascript-algorithm><blockquote><p><strong><a href=https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation>Runtime Semantics: Evaluation for <code>MemberExpression : MemberExpression . IdentifierName</code></a></strong><ol><li>Let <code>baseReference</code> be the result of evaluating <code>MemberExpression</code>.<li>Let <code>baseValue</code> be <code>? GetValue(baseReference)</code>.<li>If the code matched by this <code>MemberExpression</code> is strict mode code, let <code>strict</code> be <code>true</code>; else let <code>strict</code> be <code>false</code>.<li>Return <code>? EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict)</code>.</ol></blockquote><p>The algorithm delegates to the abstract operation <code>EvaluatePropertyAccessWithIdentifierKey</code>, so we need to read it too:<div class=ecmascript-algorithm><blockquote><p><strong><a href=https://tc39.es/ecma262/#sec-evaluate-property-access-with-identifier-key><code>EvaluatePropertyAccessWithIdentifierKey( baseValue, identifierName, strict )</code></a></strong><p>The abstract operation <code>EvaluatePropertyAccessWithIdentifierKey</code> takes as arguments a value <code>baseValue</code>, a Parse Node <code>identifierName</code>, and a Boolean argument <code>strict</code>. It performs the following steps:<ol><li>Assert: <code>identifierName</code> is an <code>IdentifierName</code><li>Let <code>bv</code> be <code>? RequireObjectCoercible(baseValue)</code>.<li>Let <code>propertyNameString</code> be <code>StringValue</code> of <code>identifierName</code>.<li>Return a value of type Reference whose base value component is <code>bv</code>, whose referenced name component is <code>propertyNameString</code>, and whose strict reference flag is <code>strict</code>.</ol></blockquote><p>That is: <code>EvaluatePropertyAccessWithIdentifierKey</code> constructs a Reference which uses the provided <code>baseValue</code> as the base, the string value of <code>identifierName</code> as the property name, and <code>strict</code> as the strict mode flag.<p>Eventually this Reference gets passed to <code>GetValue</code>. This is defined in several places in the spec, depending on how the Reference ends up being used.<h3 id=memberexpression-as-a-parameter><code>MemberExpression</code> as a parameter <a href=#memberexpression-as-a-parameter class=bookmark>#</a></h3><p>In our example, we use the property access as a parameter:<pre class=language-js><code class=language-js>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o2<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>In this case, the behavior is defined in the runtime semantics of <code>ArgumentList</code> production which calls <code>GetValue</code> on the argument:<div class=ecmascript-algorithm><blockquote><p><strong><a href=https://tc39.es/ecma262/#sec-argument-lists-runtime-semantics-argumentlistevaluation>Runtime Semantics: <code>ArgumentListEvaluation</code></a></strong><p><code>ArgumentList : AssignmentExpression</code><ol><li>Let <code>ref</code> be the result of evaluating <code>AssignmentExpression</code>.<li>Let <code>arg</code> be <code>? GetValue(ref)</code>.<li>Return a List whose sole item is <code>arg</code>.</ol></blockquote><p><code>o2.foo</code> doesn’t look like an <code>AssignmentExpression</code> but it is one, so this production is applicable. To find out why, you can check out this <a href=/blog/extras/understanding-ecmascript-part-2-extra>extra content</a>, but it’s not strictly necessary at this point.<p>The <code>AssignmentExpression</code> in step 1 is <code>o2.foo</code>. <code>ref</code>, the result of evaluating <code>o2.foo</code>, is the above mentioned Reference. In step 2 we call <code>GetValue</code> on it. Thus, we know that the Object internal method <code>[[Get]]</code> will get invoked, and the prototype chain walk will occur.<h2 id=summary>Summary <a href=#summary class=bookmark>#</a></h2><p>In this episode, we looked at how the spec defines a language feature, in this case prototype lookup, across all the different layers: the syntactic constructs that trigger the feature and the algorithms defining it.</div></div></div></div></div></div></div></div><footer><div><picture><source srcset="/_img/avatars/marja-holtta.avif, /_img/avatars/marja-holtta@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/marja-holtta.jpg srcset="/_img/avatars/marja-holtta@2x.jpg 2x" width=96></picture><p>作者：<a href=https://twitter.com/marjakh>Marja Hölttä</a>, speculative specification spectator.</div><a href=https://twitter.com/v8js/status/1234550773629014016 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/understanding-ecmascript-part-2>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/understanding-ecmascript-part-2.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>