<!doctype html><html lang=zh-CN><meta charset=utf-8><title>BigInt: arbitrary-precision integers in JavaScript · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/_css/feature-support.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="BigInts are a new numeric primitive in JavaScript that can represent integers with arbitrary precision. This article walks through some use cases and explains the new functionality in Chrome 67 by comparing BigInts to Numbers in JavaScript." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li class=current><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>BigInt: arbitrary-precision integers in JavaScript</h1><p class=meta>发布时间 <time datetime="2018-05-01 00:00:00" itemprop=datePublished>2018-05-01</time> · 标签： <a href=/features/tags/ecmascript class=tag>ECMAScript</a> <a href=/features/tags/es2020 class=tag>ES2020</a></header><div itemprop=articleBody><p><code>BigInt</code>s are a new numeric primitive in JavaScript that can represent integers with arbitrary precision. With <code>BigInt</code>s, you can safely store and operate on large integers even beyond the safe integer limit for <code>Number</code>s. This article walks through some use cases and explains the new functionality in Chrome 67 by comparing <code>BigInt</code>s to <code>Number</code>s in JavaScript.<h2 id=use-cases>Use cases <a href=#use-cases class=bookmark>#</a></h2><p>Arbitrary-precision integers unlock lots of new use cases for JavaScript.<p><code>BigInt</code>s make it possible to correctly perform integer arithmetic without overflowing. That by itself enables countless new possibilities. Mathematical operations on large numbers are commonly used in financial technology, for example.<p><a href=https://developer.twitter.com/en/docs/basics/twitter-ids>Large integer IDs</a> and <a href=https://github.com/nodejs/node/pull/20220>high-accuracy timestamps</a> cannot safely be represented as <code>Number</code>s in JavaScript. This <a href=https://github.com/stedolan/jq/issues/1399>often</a> leads to <a href=https://github.com/nodejs/node/issues/12115>real-world bugs</a>, and causes JavaScript developers to represent them as strings instead. With <code>BigInt</code>, this data can now be represented as numeric values.<p><code>BigInt</code> could form the basis of an eventual <code>BigDecimal</code> implementation. This would be useful to represent sums of money with decimal precision, and to accurately operate on them (a.k.a. the <code>0.10 + 0.20 !== 0.30</code> problem).<p>Previously, JavaScript applications with any of these use cases had to resort to userland libraries that emulate <code>BigInt</code>-like functionality. When <code>BigInt</code> becomes widely available, such applications can drop these run-time dependencies in favor of native <code>BigInt</code>s. This helps reduce load time, parse time, and compile time, and on top of all that offers significant run-time performance improvements.<figure><img alt="" height=337 loading=lazy src=/_img/bigint/performance.svg width=809><figcaption>The native <code>BigInt</code> implementation in Chrome performs better than popular userland libraries.</figcaption></figure><h2 id=number :="">The status quo: <code>Number</code> <a href=#number class=bookmark>#</a></h2><p><code>Number</code>s in JavaScript are represented as <a href=https://en.wikipedia.org/wiki/Floating-point_arithmetic>double-precision floats</a>. This means they have limited precision. The <code>Number.MAX_SAFE_INTEGER</code> constant gives the greatest possible integer that can safely be incremented. Its value is <code>2**53-1</code>.<pre class=language-js><code class=language-js><span class="token keyword">const</span> max <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">;</span><br><span class="token comment">// → 9_007_199_254_740_991</span></code></pre><div class=note><p><strong>Note:</strong> For readability, I’m grouping the digits in this large number per thousand, using underscores as separators. <a href=/features/numeric-separators>The numeric literal separators proposal</a> enables exactly that for common JavaScript numeric literals.</div><p>Incrementing it once gives the expected result:<pre class=language-js><code class=language-js>max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token comment">// → 9_007_199_254_740_992 ✅</span></code></pre><p>But if we increment it a second time, the result is no longer exactly representable as a JavaScript <code>Number</code>:<pre class=language-js><code class=language-js>max <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><br><span class="token comment">// → 9_007_199_254_740_992 ❌</span></code></pre><p>Note how <code>max + 1</code> produces the same result as <code>max + 2</code>. Whenever we get this particular value in JavaScript, there is no way to tell whether it’s accurate or not. Any calculation on integers outside the safe integer range (i.e. from <code>Number.MIN_SAFE_INTEGER</code> to <code>Number.MAX_SAFE_INTEGER</code>) potentially loses precision. For this reason, we can only rely on numeric integer values within the safe range.<h2 id=bigint :="">The new hotness: <code>BigInt</code> <a href=#bigint class=bookmark>#</a></h2><p><code>BigInt</code>s are a new numeric primitive in JavaScript that can represent integers with <a href=https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic>arbitrary precision</a>. With <code>BigInt</code>s, you can safely store and operate on large integers even beyond the safe integer limit for <code>Number</code>s.<p>To create a <code>BigInt</code>, add the <code>n</code> suffix to any integer literal. For example, <code>123</code> becomes <code>123n</code>. The global <code>BigInt(number)</code> function can be used to convert a <code>Number</code> into a <code>BigInt</code>. In other words, <code>BigInt(123) === 123n</code>. Let’s use these two techniques to solve the problem we were having earlier:<pre class=language-js><code class=language-js><span class="token function">BigInt</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2n</span><span class="token punctuation">;</span><br><span class="token comment">// → 9_007_199_254_740_993n ✅</span></code></pre><p>Here’s another example, where we’re multiplying two <code>Number</code>s:<pre class=language-js><code class=language-js><span class="token number">1234567890123456789</span> <span class="token operator">*</span> <span class="token number">123</span><span class="token punctuation">;</span><br><span class="token comment">// → 151851850485185200000 ❌</span></code></pre><p>Looking at the least significant digits, <code>9</code> and <code>3</code>, we know that the result of the multiplication should end in <code>7</code> (because <code>9 * 3 === 27</code>). However, the result ends in a bunch of zeroes. That can’t be right! Let’s try again with <code>BigInt</code>s instead:<pre class=language-js><code class=language-js><span class="token number">1234567890123456789n</span> <span class="token operator">*</span> <span class="token number">123n</span><span class="token punctuation">;</span><br><span class="token comment">// → 151851850485185185047n ✅</span></code></pre><p>This time we get the correct result.<p>The safe integer limits for <code>Number</code>s don’t apply to <code>BigInt</code>s. Therefore, with <code>BigInt</code> we can perform correct integer arithmetic without having to worry about losing precision.<h3 id=a-new-primitive>A new primitive <a href=#a-new-primitive class=bookmark>#</a></h3><p><code>BigInt</code>s are a new primitive in the JavaScript language. As such, they get their own type that can be detected using the <code>typeof</code> operator:<pre class=language-js><code class=language-js><span class="token keyword">typeof</span> <span class="token number">123</span><span class="token punctuation">;</span><br><span class="token comment">// → 'number'</span><br><span class="token keyword">typeof</span> <span class="token number">123n</span><span class="token punctuation">;</span><br><span class="token comment">// → 'bigint'</span></code></pre><p>Because <code>BigInt</code>s are a separate type, a <code>BigInt</code> is never strictly equal to a <code>Number</code>, e.g. <code>42n !== 42</code>. To compare a <code>BigInt</code> to a <code>Number</code>, convert one of them into the other’s type before doing the comparison or use abstract equality (<code>==</code>):<pre class=language-js><code class=language-js><span class="token number">42n</span> <span class="token operator">===</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → true</span><br><span class="token number">42n</span> <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">;</span><br><span class="token comment">// → true</span></code></pre><p>When coerced into a boolean (which happens when using <code>if</code>, <code>&&</code>, <code>||</code>, or <code>Boolean(int)</code>, for example), <code>BigInt</code>s follow the same logic as <code>Number</code>s.<pre class=language-js><code class=language-js><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'if'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'else'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token comment">// → logs 'else', because `0n` is falsy.</span></code></pre><h3 id=operators>Operators <a href=#operators class=bookmark>#</a></h3><p><code>BigInt</code>s support the most common operators. Binary <code>+</code>, <code>-</code>, <code>*</code>, and <code>**</code> all work as expected. <code>/</code> and <code>%</code> work, and round towards zero as needed. Bitwise operations <code>|</code>, <code>&</code>, <code>&lt;&lt;</code>, <code>>></code>, and <code>^</code> perform bitwise arithmetic assuming a <a href=https://en.wikipedia.org/wiki/Two%27s_complement>two’s complement representation</a> for negative values, just like they do for <code>Number</code>s.<pre class=language-js><code class=language-js><span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">+</span> <span class="token number">6</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">**</span> <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span><br><span class="token comment">// → 1</span><br><span class="token punctuation">(</span><span class="token number">7n</span> <span class="token operator">+</span> <span class="token number">6n</span> <span class="token operator">-</span> <span class="token number">5n</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">**</span> <span class="token number">3n</span> <span class="token operator">/</span> <span class="token number">2n</span> <span class="token operator">%</span> <span class="token number">3n</span><span class="token punctuation">;</span><br><span class="token comment">// → 1n</span></code></pre><p>Unary <code>-</code> can be used to denote a negative <code>BigInt</code> value, e.g. <code>-42n</code>. Unary <code>+</code> is <em>not</em> supported because it would break asm.js code which expects <code>+x</code> to always produce either a <code>Number</code> or an exception.<p>One gotcha is that it’s not allowed to mix operations between <code>BigInt</code>s and <code>Number</code>s. This is a good thing, because any implicit coercion could lose information. Consider this example:<pre class=language-js><code class=language-js><span class="token function">BigInt</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2.5</span><span class="token punctuation">;</span><br><span class="token comment">// → ?? 🤔</span></code></pre><p>What should the result be? There is no good answer here. <code>BigInt</code>s can’t represent fractions, and <code>Number</code>s can’t represent <code>BigInt</code>s beyond the safe integer limit. For that reason, mixing operations between <code>BigInt</code>s and <code>Number</code>s results in a <code>TypeError</code> exception.<p>The only exception to this rule are comparison operators such as <code>===</code> (as discussed earlier), <code>&lt;</code>, and <code>>=</code> – because they return booleans, there is no risk of precision loss.<pre class=language-js><code class=language-js><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1n</span><span class="token punctuation">;</span><br><span class="token comment">// → TypeError</span><br><span class="token number">123</span> <span class="token operator">&lt;</span> <span class="token number">124n</span><span class="token punctuation">;</span><br><span class="token comment">// → true</span></code></pre><p>Because <code>BigInt</code>s and <code>Number</code>s generally don’t mix, please avoid overloading or magically “upgrading” your existing code to use <code>BigInt</code>s instead of <code>Number</code>s. Decide which of these two domains to operate in, and then stick to it. For <em>new</em> APIs that operate on potentially large integers, <code>BigInt</code> is the best choice. <code>Number</code>s still make sense for integer values that are known to be in the safe integer range.<p>Another thing to note is that <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift>the <code>>>></code> operator</a>, which performs an unsigned right shift, does not make sense for <code>BigInt</code>s since they’re always signed. For this reason, <code>>>></code> does not work for <code>BigInt</code>s.<h3 id=api>API <a href=#api class=bookmark>#</a></h3><p>Several new <code>BigInt</code>-specific APIs are available.<p>The global <code>BigInt</code> constructor is similar to the <code>Number</code> constructor: it converts its argument into a <code>BigInt</code> (as mentioned earlier). If the conversion fails, it throws a <code>SyntaxError</code> or <code>RangeError</code> exception.<pre class=language-js><code class=language-js><span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → 123n</span><br><span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → RangeError</span><br><span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token string">'1.5'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → SyntaxError</span></code></pre><p>The first of those examples passes a numeric literal to <code>BigInt()</code>. This is a bad practice, since <code>Number</code>s suffer from precision loss, and so we might already lose precision before the <code>BigInt</code> conversion happens:<pre class=language-js><code class=language-js><span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">123456789123456789</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → 123456789123456784n ❌</span></code></pre><p>For this reason, we recommend either sticking to the <code>BigInt</code> literal notation (with the <code>n</code> suffix), or passing a string (not a <code>Number</code>!) to <code>BigInt()</code> instead:<pre class=language-js><code class=language-js><span class="token number">123456789123456789n</span><span class="token punctuation">;</span><br><span class="token comment">// → 123456789123456789n ✅</span><br><span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token string">'123456789123456789'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → 123456789123456789n ✅</span></code></pre><p>Two library functions enable wrapping <code>BigInt</code> values as either signed or unsigned integers, limited to a specific number of bits. <code>BigInt.asIntN(width, value)</code> wraps a <code>BigInt</code> value to a <code>width</code>-digit binary signed integer, and <code>BigInt.asUintN(width, value)</code> wraps a <code>BigInt</code> value to a <code>width</code>-digit binary unsigned integer. If you’re doing 64-bit arithmetic for example, you can use these APIs to stay within the appropriate range:<pre class=language-js><code class=language-js><span class="token comment">// Highest possible BigInt value that can be represented as a</span><br><span class="token comment">// signed 64-bit integer.</span><br><span class="token keyword">const</span> max <span class="token operator">=</span> <span class="token number">2n</span> <span class="token operator">**</span> <span class="token punctuation">(</span><span class="token number">64n</span> <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">;</span><br>BigInt<span class="token punctuation">.</span><span class="token function">asIntN</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span><br>→ <span class="token number">9223372036854775807n</span><br>BigInt<span class="token punctuation">.</span><span class="token function">asIntN</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> max <span class="token operator">+</span> <span class="token number">1n</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → -9223372036854775808n</span><br><span class="token comment">//   ^ negative because of overflow</span></code></pre><p>Note how overflow occurs as soon as we pass a <code>BigInt</code> value exceeding the 64-bit integer range (i.e. 63 bits for the absolute numeric value + 1 bit for the sign).<p><code>BigInt</code>s make it possible to accurately represent 64-bit signed and unsigned integers, which are commonly used in other programming languages. Two new typed array flavors, <code>BigInt64Array</code> and <code>BigUint64Array</code>, make it easier to efficiently represent and operate on lists of such values:<pre class=language-js><code class=language-js><span class="token keyword">const</span> view <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInt64Array</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → [0n, 0n, 0n, 0n]</span><br>view<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br><span class="token comment">// → 4</span><br>view<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// → 0n</span><br>view<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42n</span><span class="token punctuation">;</span><br>view<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// → 42n</span></code></pre><p>The <code>BigInt64Array</code> flavor ensures that its values remain within the signed 64-bit limit.<pre class=language-js><code class=language-js><span class="token comment">// Highest possible BigInt value that can be represented as a</span><br><span class="token comment">// signed 64-bit integer.</span><br><span class="token keyword">const</span> max <span class="token operator">=</span> <span class="token number">2n</span> <span class="token operator">**</span> <span class="token punctuation">(</span><span class="token number">64n</span> <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">;</span><br>view<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">;</span><br>view<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// → 9_223_372_036_854_775_807n</span><br>view<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max <span class="token operator">+</span> <span class="token number">1n</span><span class="token punctuation">;</span><br>view<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// → -9_223_372_036_854_775_808n</span><br><span class="token comment">//   ^ negative because of overflow</span></code></pre><p>The <code>BigUint64Array</code> flavor does the same using the unsigned 64-bit limit instead.<h2 id=polyfilling-transpiling>Polyfilling and transpiling BigInts <a href=#polyfilling-transpiling class=bookmark>#</a></h2><p>At the time of writing, <code>BigInt</code>s are only supported in Chrome. Other browsers are actively working on implementing them. But what if you want to use <code>BigInt</code> functionality <em>today</em> without sacrificing browser compatibility? I’m glad you asked! The answer is… interesting, to say the least.<p>Unlike most other modern JavaScript features, <code>BigInt</code>s cannot reasonably be transpiled down to ES5.<p>The <code>BigInt</code> proposal <a href=#operators>changes the behavior of operators</a> (like <code>+</code>, <code>>=</code>, etc.) to work on <code>BigInt</code>s. These changes are impossible to polyfill directly, and they are also making it infeasible (in most cases) to transpile <code>BigInt</code> code to fallback code using Babel or similar tools. The reason is that such a transpilation would have to replace <em>every single operator</em> in the program with a call to some function that performs type checks on its inputs, which would incur an unacceptable run-time performance penalty. In addition, it would greatly increase the file size of any transpiled bundle, negatively impacting download, parse, and compile times.<p>A more feasible and future-proof solution is to write your code using <a href=https://github.com/GoogleChromeLabs/jsbi#why>the JSBI library</a> for now. JSBI is a JavaScript port of the <code>BigInt</code> implementation in V8 and Chrome — by design, it behaves exactly like the native <code>BigInt</code> functionality. The difference is that instead of relying on syntax, it exposes <a href=https://github.com/GoogleChromeLabs/jsbi#how>an API</a>:<pre class=language-js><code class=language-js><span class="token keyword">import</span> <span class="token constant">JSBI</span> <span class="token keyword">from</span> <span class="token string">'./jsbi.mjs'</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> max <span class="token operator">=</span> <span class="token constant">JSBI</span><span class="token punctuation">.</span><span class="token function">BigInt</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> two <span class="token operator">=</span> <span class="token constant">JSBI</span><span class="token punctuation">.</span><span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token constant">JSBI</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> two<span class="token punctuation">)</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → '9007199254740993'</span></code></pre><p>Once <code>BigInt</code>s are natively supported in all browsers you care about, you can <a href=https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint>use <code>babel-plugin-transform-jsbi-to-bigint</code> to transpile your code to native <code>BigInt</code> code</a> and drop the JSBI dependency. For example, the above example transpiles to:<pre class=language-js><code class=language-js><span class="token keyword">const</span> max <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> two <span class="token operator">=</span> <span class="token number">2n</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> max <span class="token operator">+</span> two<span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// → '9007199254740993'</span></code></pre><h2 id=further-reading>Further reading <a href=#further-reading class=bookmark>#</a></h2><p>If you’re interested in how <code>BigInt</code>s work behind the scenes (e.g. how they are represented in memory, and how operations on them are performed), <a href=/blog/bigint>read our V8 blog post with implementation details</a>.<h2 id=support><code>BigInt</code> support <a href=#support class=bookmark>#</a></h2><ul class=feature-support><li class="environment has-link has-support"><a href=/blog/bigint><span class="icon chrome">Chrome:</span> <span class=support>自 <span class=version>67</span> 版本开始支持</span></a><li class="environment has-link has-support"><a href=https://wingolog.org/archives/2019/05/23/bigint-shipping-in-firefox><span class="icon firefox">Firefox:</span> <span class=support>自 <span class=version>68</span> 版本开始支持</span></a><li class="environment no-support"><span class="icon safari">Safari:</span> <span class=support>不支持</span><li class="environment has-link has-support"><a href=https://twitter.com/mathias/status/1120700101637353473><span class="icon nodejs">Node.js:</span> <span class=support>自 <span class=version>12</span> 版本开始支持</span></a><li class="environment has-link has-support"><a href=#polyfilling-transpiling><span class="icon babel">Babel:</span> <span class=support>支持</span></a></ul><div class=feature-support-info><a href=/features/support>关于特性支持列表</a></div></div><footer><div><picture><source srcset="/_img/avatars/mathias-bynens.avif, /_img/avatars/mathias-bynens@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/mathias-bynens.jpg width=96 srcset="/_img/avatars/mathias-bynens@2x.jpg 2x"></picture><p>作者：Mathias Bynens (<a href=https://twitter.com/mathias>@mathias</a>).</div><a href=https://twitter.com/v8js/status/990991035630206977 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/features/bigint>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/features/bigint.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>