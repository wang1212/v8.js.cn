<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Atomics.wait, Atomics.notify, Atomics.waitAsync · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/_css/feature-support.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="Atomics.wait and Atomics.notify are low-level synchronization primitives useful for implementing e.g. mutexes. Atomics.wait is only usable on worker threads. V8 version 8.7 now supports a non-blocking version, Atomics.waitAsync, which is also usable on the main thread." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li class=current><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline><code>Atomics.wait</code>, <code>Atomics.notify</code>, <code>Atomics.waitAsync</code></h1><p class=meta>发布时间 <time datetime="2020-09-24 00:00:00" itemprop=datePublished>2020-09-24</time> · 标签： <a href=/features/tags/ecmascript class=tag>ECMAScript</a> <a href=/features/tags/es2020 class=tag>ES2020</a></header><div itemprop=articleBody><p><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait><code>Atomics.wait</code></a> and <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/notify><code>Atomics.notify</code></a> are low-level synchronization primitives useful for implementing mutexes and other means of synchronization. However, since <code>Atomics.wait</code> is blocking, it’s not possible to call it on the main thread (trying to do so throws a <code>TypeError</code>).<p>Starting from version 8.7, V8 supports a non-blocking version, <a href=https://github.com/tc39/proposal-atomics-wait-async/blob/master/PROPOSAL.md><code>Atomics.waitAsync</code></a>, which is also usable on the main thread.<p>In this post, we explain how to use these low-level APIs to implement a mutex that works both synchronously (for worker threads) and asynchronously (for worker threads or the main thread).<p><code>Atomics.wait</code> and <code>Atomics.waitAsync</code> take the following parameters:<ul><li><code>buffer</code>: an <code>Int32Array</code> or <code>BigInt64Array</code> backed by a <code>SharedArrayBuffer</code><li><code>index</code>: a valid index within the array<li><code>expectedValue</code>: a value we expect to be present in the memory location described by <code>(buffer, index)</code><li><code>timeout</code>: a timeout in milliseconds (optional, defaults to <code>Infinity</code>)</ul><p>The return value of <code>Atomics.wait</code> is a string. If the memory location doesn’t contain the expected value, <code>Atomics.wait</code> returns immediately with the value <code>'not-equal'</code>. Otherwise, the thread is blocked until another thread calls <code>Atomics.notify</code> with the same memory location or the timeout is reached. In the former case, <code>Atomics.wait</code> returns the value <code>'ok'</code>, in the latter case, <code>Atomics.wait</code> returns the value <code>'timed-out'</code>.<p><code>Atomics.notify</code> takes the following parameters:<ul><li>an <code>Int32Array</code> or <code>BigInt64Array</code> backed by a <code>SharedArrayBuffer</code><li>an index (valid within the array)<li>how many waiters to notify (optional, defaults to <code>Infinity</code>)</ul><p>It notifies the given amount of waiters, in FIFO order, waiting on the memory location described by <code>(buffer, index)</code>. If there are several pending <code>Atomics.wait</code> calls or <code>Atomics.waitAsync</code> calls related to the same location, they are all in the same FIFO queue.<p>In contrast to <code>Atomics.wait</code>, <code>Atomics.waitAsync</code> always returns immediately. The return value is one of the following:<ul><li><code>{ async: false, value: 'not-equal' }</code> (if the memory location didn’t contain the expected value)<li><code>{ async: false, value: 'timed-out' }</code> (only for immediate timeout 0)<li><code>{ async: true, value: promise }</code></ul><p>The promise may later be resolved with a string value <code>'ok'</code> (if <code>Atomics.notify</code> was called with the same memory location) or <code>'timed-out'</code> (if the timeout was reached). The promise is never rejected.<p>The following example demonstrates the basic usage of <code>Atomics.waitAsync</code>:<pre class=language-js><code class=language-js><span class="token keyword">const</span> sab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedArrayBuffer</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> i32a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Int32Array</span><span class="token punctuation">(</span>sab<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> Atomics<span class="token punctuation">.</span><span class="token function">waitAsync</span><span class="token punctuation">(</span>i32a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">//                                     |  |  ^ timeout (opt)</span><br><span class="token comment">//                                     |  ^ expected value</span><br><span class="token comment">//                                     ^ index</span><br><br><span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>value <span class="token operator">===</span> <span class="token string">'not-equal'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// The value in the SharedArrayBuffer was not the expected one.</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>  result<span class="token punctuation">.</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">;</span> <span class="token comment">// true</span><br>  result<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><br>    <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token string">'ok'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* notified */</span> <span class="token punctuation">}</span><br>      <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">/* value is 'timed-out' */</span> <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// In this thread, or in another thread:</span><br>Atomics<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>i32a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Next, we’ll show how to implement a mutex which can be used both synchronously and asynchronously. Implementing the synchronous version of the mutex has been previously discussed, e.g. <a href=https://blogtitle.github.io/using-javascript-sharedarraybuffers-and-atomics/ >in this blog post</a>.<p>In the example, we don’t use the timeout parameter in <code>Atomics.wait</code> and <code>Atomics.waitAsync</code>. The parameter can be used for implementing condition variables with a timeout.<p>Our mutex class, <code>AsyncLock</code>, operates on a <code>SharedArrayBuffer</code> and implements the following methods:<ul><li><code>lock</code> — blocks the thread until we're able to lock the mutex (usable only on a worker thread)<li><code>unlock</code> — unlocks the mutex (counterpart of <code>lock</code>)<li><code>executeLocked(callback)</code> — non-blocking lock, can be used by the main thread; schedules <code>callback</code> to be executed once we manage to get the lock</ul><p>Let’s see how each of those can be implemented. The class definition includes constants and a constructor which takes the <code>SharedArrayBuffer</code> as a parameter.<pre class=language-js><code class=language-js><span class="token keyword">class</span> <span class="token class-name">AsyncLock</span> <span class="token punctuation">{</span><br>  <span class="token keyword">static</span> <span class="token constant">INDEX</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>  <span class="token keyword">static</span> <span class="token constant">UNLOCKED</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>  <span class="token keyword">static</span> <span class="token constant">LOCKED</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br><br>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">sab</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>sab <span class="token operator">=</span> sab<span class="token punctuation">;</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>i32a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Int32Array</span><span class="token punctuation">(</span>sab<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">/* … */</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">/* … */</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token function">executeLocked</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">/* … */</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Here <code>i32a[0]</code> contains either the value <code>LOCKED</code> or <code>UNLOCKED</code>. It’s also the wait location for <code>Atomics.wait</code>and <code>Atomics.waitAsync</code>. The <code>AsyncLock</code> class ensures the following invariants:<ol><li>If <code>i32a[0] == LOCKED</code>, and a thread starts to wait (either via <code>Atomics.wait</code> or <code>Atomics.waitAsync</code>) on <code>i32a[0]</code>, it will eventually be notified.<li>After getting notified, the thread tries to grab the lock. If it gets the lock, it will notify again when releasing it.</ol><h2 id=sync-lock-and-unlock>Sync lock and unlock <a href=#sync-lock-and-unlock class=bookmark>#</a></h2><p>Next we show the blocking <code>lock</code> method which can only be called from a worker thread:<pre class=language-js><code class=language-js><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> oldValue <span class="token operator">=</span> Atomics<span class="token punctuation">.</span><span class="token function">compareExchange</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>i32a<span class="token punctuation">,</span> AsyncLock<span class="token punctuation">.</span><span class="token constant">INDEX</span><span class="token punctuation">,</span><br>                        <span class="token comment">/* old value >>> */</span>  AsyncLock<span class="token punctuation">.</span><span class="token constant">UNLOCKED</span><span class="token punctuation">,</span><br>                        <span class="token comment">/* new value >>> */</span>  AsyncLock<span class="token punctuation">.</span><span class="token constant">LOCKED</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">==</span> AsyncLock<span class="token punctuation">.</span><span class="token constant">UNLOCKED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">return</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    Atomics<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>i32a<span class="token punctuation">,</span> AsyncLock<span class="token punctuation">.</span><span class="token constant">INDEX</span><span class="token punctuation">,</span><br>                 AsyncLock<span class="token punctuation">.</span><span class="token constant">LOCKED</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;&lt;&lt; expected value at start</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>When a thread calls <code>lock()</code>, first it tries to get the lock by using <code>Atomics.compareExchange</code> to change the lock state from <code>UNLOCKED</code> to <code>LOCKED</code>. <code>Atomics.compareExchange</code> tries to do the state change atomically, and it returns the original value of the memory location. If the original value was <code>UNLOCKED</code>, we know the state change succeeded, and the thread acquired the lock. Nothing more is needed.<p>If <code>Atomics.compareExchange</code> doesn’t manage to change the lock state, another thread must be holding the lock. Thus, this thread tries <code>Atomics.wait</code> in order to wait for the other thread to release the lock. If the memory location still holds the expected value (in this case, <code>AsyncLock.LOCKED</code>), calling <code>Atomics.wait</code> will block the thread and the <code>Atomics.wait</code> call will return only when another thread calls <code>Atomics.notify</code>.<p>The <code>unlock</code> is method sets the lock to the <code>UNLOCKED</code> state and calls <code>Atomics.notify</code> to wake up one waiter which was waiting for the lock. The state change is always expected to succeed, since this thread is holding the lock, and nobody else should call <code>unlock()</code> meanwhile.<pre class=language-js><code class=language-js><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> oldValue <span class="token operator">=</span> Atomics<span class="token punctuation">.</span><span class="token function">compareExchange</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>i32a<span class="token punctuation">,</span> AsyncLock<span class="token punctuation">.</span><span class="token constant">INDEX</span><span class="token punctuation">,</span><br>                      <span class="token comment">/* old value >>> */</span>  AsyncLock<span class="token punctuation">.</span><span class="token constant">LOCKED</span><span class="token punctuation">,</span><br>                      <span class="token comment">/* new value >>> */</span>  AsyncLock<span class="token punctuation">.</span><span class="token constant">UNLOCKED</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">!=</span> AsyncLock<span class="token punctuation">.</span><span class="token constant">LOCKED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Tried to unlock while not holding the mutex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  Atomics<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>i32a<span class="token punctuation">,</span> AsyncLock<span class="token punctuation">.</span><span class="token constant">INDEX</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The straightforward case goes as follows: the lock is free and thread T1 acquires it by changing the lock state with <code>Atomics.compareExchange</code>. Thread T2 tries to acquire the lock by calling <code>Atomics.compareExchange</code>, but it doesn’t succeed in changing the lock state. T2 then calls <code>Atomics.wait</code>, which blocks the thread. At some point T1 releases the lock and calls <code>Atomics.notify</code>. That makes the <code>Atomics.wait</code> call in T2 return <code>'ok'</code>, waking up T2. T2 then tries to acquire the lock again, and this time succeeds.<p>There are also 2 possible corner cases — these demonstrate the reason for <code>Atomics.wait</code> and <code>Atomics.waitAsync</code> checking for a specific value at the index:<ul><li>T1 is holding the lock and T2 tries to get it. First, T2 tries to change the lock state with <code>Atomics.compareExchange</code>, but doesn’t succeed. But then T1 releases the lock before T2 manages to call <code>Atomics.wait</code>. When T2 calls <code>Atomics.wait</code>, it returns immediately with the value <code>'not-equal'</code>. In that case, T2 continues with the next loop iteration, trying to acquire the lock again.<li>T1 is holding the lock and T2 is waiting for it with <code>Atomics.wait</code>. T1 releases the lock — T2 wakes up (the <code>Atomics.wait</code> call returns) and tries to do <code>Atomics.compareExchange</code> to acquire the lock, but another thread T3 was faster and got the lock already. So the call to <code>Atomics.compareExchange</code> fails to get the lock, and T2 calls <code>Atomics.wait</code> again, blocking until T3 releases the lock.</ul><p>Because of the latter corner case, the mutex isn’t “fair”. It’s possible that T2 has been waiting for the lock to be released, but T3 comes and gets it immediately. A more realistic lock implementation may use several states to differentiate between “locked” and “locked with contention”.<h2 id=async-lock>Async lock <a href=#async-lock class=bookmark>#</a></h2><p>The non-blocking <code>executeLocked</code> method is callable from the main thread, unlike the blocking <code>lock</code> method. It gets a callback function as its only parameter and schedules the callback to be executed once it has successfully acquired the lock.<pre class=language-js><code class=language-js><span class="token function">executeLocked</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">tryGetLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">const</span> oldValue <span class="token operator">=</span> Atomics<span class="token punctuation">.</span><span class="token function">compareExchange</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>i32a<span class="token punctuation">,</span> AsyncLock<span class="token punctuation">.</span><span class="token constant">INDEX</span><span class="token punctuation">,</span><br>                          <span class="token comment">/* old value >>> */</span>  AsyncLock<span class="token punctuation">.</span><span class="token constant">UNLOCKED</span><span class="token punctuation">,</span><br>                          <span class="token comment">/* new value >>> */</span>  AsyncLock<span class="token punctuation">.</span><span class="token constant">LOCKED</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">==</span> AsyncLock<span class="token punctuation">.</span><span class="token constant">UNLOCKED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        self<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">return</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>      <span class="token keyword">const</span> result <span class="token operator">=</span> Atomics<span class="token punctuation">.</span><span class="token function">waitAsync</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>i32a<span class="token punctuation">,</span> AsyncLock<span class="token punctuation">.</span><span class="token constant">INDEX</span><span class="token punctuation">,</span><br>                                       AsyncLock<span class="token punctuation">.</span><span class="token constant">LOCKED</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>                                   <span class="token comment">//  ^ expected value at start</span><br>      <span class="token keyword">await</span> result<span class="token punctuation">.</span>value<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token function">tryGetLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The inner function <code>tryGetLock</code> tries to first get the lock with <code>Atomics.compareExchange</code>, as before. If that successfully changes the lock state, it can execute the callback, unlock the lock, and return.<p>If <code>Atomics.compareExchange</code> fails to get the lock, we need to try again when the lock is probably free. We can’t block and wait for the lock to become free — instead, we schedule the new try using <code>Atomics.waitAsync</code> and the Promise it returns.<p>If we successfully started <code>Atomics.waitAsync</code>, the returned Promise resolves when the lock-holding thread does <code>Atomics.notify</code>. Then the thread that was waiting for the lock tries to get the lock again, like before.<p>The same corner cases (the lock getting released between the <code>Atomics.compareExchange</code> call and the <code>Atomics.waitAsync</code> call, as well as the lock getting acquired again between the Promise resolving and the <code>Atomics.compareExchange</code> call) are possible in the asynchronous version too, so the code has to handle them in a robust way.<h2 id=conclusion>Conclusion <a href=#conclusion class=bookmark>#</a></h2><p>In this post, we showed how to use the synchronization primitives <code>Atomics.wait</code>, <code>Atomics.waitAsync</code>, and <code>Atomics.notify</code>, to implement a mutex which is usable both in the main thread an in worker threads.<h2 id=support>Feature support <a href=#support class=bookmark>#</a></h2><h3 id=atomics.wait-and-atomics.notify><code>Atomics.wait</code> and <code>Atomics.notify</code> <a href=#atomics.wait-and-atomics.notify class=bookmark>#</a></h3><ul class=feature-support><li class="environment has-support"><span class="icon chrome">Chrome:</span> <span class=support>自 <span class=version>68</span> 版本开始支持</span><li class="environment has-support"><span class="icon firefox">Firefox:</span> <span class=support>自 <span class=version>78</span> 版本开始支持</span><li class="environment no-support"><span class="icon safari">Safari:</span> <span class=support>不支持</span><li class="environment has-support"><span class="icon nodejs">Node.js:</span> <span class=support>自 <span class=version>8.10.0</span> 版本开始支持</span><li class="environment no-support"><span class="icon babel">Babel:</span> <span class=support>不支持</span></ul><div class=feature-support-info><a href=/features/support>关于特性支持列表</a></div><h3 id=atomics.waitasync><code>Atomics.waitAsync</code> <a href=#atomics.waitasync class=bookmark>#</a></h3><ul class=feature-support><li class="environment has-support"><span class="icon chrome">Chrome:</span> <span class=support>自 <span class=version>87</span> 版本开始支持</span><li class="environment no-support"><span class="icon firefox">Firefox:</span> <span class=support>不支持</span><li class="environment no-support"><span class="icon safari">Safari:</span> <span class=support>不支持</span><li class="environment no-support"><span class="icon nodejs">Node.js:</span> <span class=support>不支持</span><li class="environment no-support"><span class="icon babel">Babel:</span> <span class=support>不支持</span></ul><div class=feature-support-info><a href=/features/support>关于特性支持列表</a></div></div><footer><div><picture><source srcset="/_img/avatars/marja-holtta.avif, /_img/avatars/marja-holtta@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/marja-holtta.jpg srcset="/_img/avatars/marja-holtta@2x.jpg 2x" width=96></picture><p>作者：<a href=https://twitter.com/marjakh>Marja Hölttä</a>, a non-blocking blogger.</div><a href=https://twitter.com/v8js/status/1309118447377358848 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/features/atomics>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/features/atomics.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>