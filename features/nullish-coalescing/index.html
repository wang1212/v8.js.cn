<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Nullish coalescing · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/_css/feature-support.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="The JavaScript nullish coalescing operator enables safer default expressions." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li class=current><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Nullish coalescing</h1><p class=meta>发布时间 <time datetime="2019-09-17 00:00:00" itemprop=datePublished>2019-09-17</time> · 标签： <a href=/features/tags/ecmascript class=tag>ECMAScript</a> <a href=/features/tags/es2020 class=tag>ES2020</a></header><div itemprop=articleBody><p>The <a href=https://github.com/tc39/proposal-nullish-coalescing/ >nullish coalescing proposal</a> (<code>??</code>) adds a new short-circuiting operator meant to handle default values.<p>You might already be familiar with the other short-circuiting operators <code>&&</code> and <code>||</code>. Both of these operators handle “truthy” and “falsy” values. Imagine the code sample <code>lhs && rhs</code>. If <code>lhs</code> (read, <em>left-hand side</em>) is falsy, the expression evaluates to <code>lhs</code>. Otherwise, it evaluates to <code>rhs</code> (read, <em>right-hand side</em>). The opposite is true for the code sample <code>lhs || rhs</code>. If <code>lhs</code> is truthy, the expression evaluates to <code>lhs</code>. Otherwise, it evaluates to <code>rhs</code>.<p>But what exactly does “truthy” and “falsy” mean? In spec terms, it equates to the <a href=https://tc39.es/ecma262/#sec-toboolean><code>ToBoolean</code></a> abstract operation. For us regular JavaScript developers, <strong>everything</strong> is truthy except the falsy values <code>undefined</code>, <code>null</code>, <code>false</code>, <code>0</code>, <code>NaN</code>, and the empty string <code>''</code>. (Technically, the value associated with <code>document.all</code> is also falsy, but we’ll get to that later.)<p>So, what’s the issue with <code>&&</code> and <code>||</code>? And why do we need a new nullish coalescing operator? It’s because this definition of truthy and falsy doesn’t fit every scenario and this leads to bugs. Imagine the following:<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> enable <span class="token operator">=</span> props<span class="token punctuation">.</span>enabled <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre><p>In this example, let’s treat the <code>enabled</code> property as an optional boolean property that controls whether some functionality in the component is enabled. Meaning, we can explicitly set <code>enabled</code> to either <code>true</code> or <code>false</code>. But, because it is an <em>optional</em> property, we can implicitly set it to <code>undefined</code> by not setting it at all. If it’s <code>undefined</code> we want to treat it as if the component is <code>enabled = true</code> (its default value).<p>By now, you can probably spot the bug with the code example. If we explicitly set <code>enabled = true</code>, then the <code>enable</code> variable is <code>true</code>. If we implicitly set <code>enabled = undefined</code>, then the <code>enable</code> variable is <code>true</code>. And if we explicitly set <code>enabled = false</code>, then the <code>enable</code> variable is still <code>true</code>! Our intention was to <em>default</em> the value to <code>true</code>, but we actually forced the value instead. The fix in this case is to be very explicit about the values we expect:<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> enable <span class="token operator">=</span> props<span class="token punctuation">.</span>enabled <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">;</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre><p>We see this kind of bug pop up with every falsy value. This could have very easily been an optional string (where the empty string <code>''</code> is considered valid input), or an optional number (where <code>0</code> is considered a valid input). This is such a common problem that we’re now introducing the nullish coalescing operator to handle this sort of default value assignment:<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> enable <span class="token operator">=</span> props<span class="token punctuation">.</span>enabled <span class="token operator">??</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre><p>The nullish coalescing operator (<code>??</code>) acts very similar to the <code>||</code> operator, except that we don’t use “truthy” when evaluating the operator. Instead we use the definition of “nullish”, meaning “is the value strictly equal to <code>null</code> or <code>undefined</code>”. So imagine the expression <code>lhs ?? rhs</code>: if <code>lhs</code> is not nullish, it evaluates to <code>lhs</code>. Otherwise, it evaluates to <code>rhs</code>.<p>Explicitly, that means the values <code>false</code>, <code>0</code>, <code>NaN</code>, and the empty string <code>''</code> are all falsy values that are not nullish. When such falsy-but-not-nullish values are the left-hand side of a <code>lhs ?? rhs</code>, the expression evaluates to them instead of the right-hand side. Bugs begone!<pre class=language-js><code class=language-js><span class="token boolean">false</span> <span class="token operator">??</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment">// => false</span><br><span class="token number">0</span> <span class="token operator">??</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// => 0</span><br><span class="token string">''</span> <span class="token operator">??</span> <span class="token string">'default'</span><span class="token punctuation">;</span> <span class="token comment">// => ''</span><br><br><span class="token keyword">null</span> <span class="token operator">??</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// => []</span><br><span class="token keyword">undefined</span> <span class="token operator">??</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// => []</span></code></pre><h2 id=destructuring>What about default assignment while destructuring? <a href=#destructuring class=bookmark>#</a></h2><p>You might have noticed that the last code example could also be fixed by using default assignment inside an object destructure:<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> <span class="token punctuation">{</span><br>    enabled<span class="token operator">:</span> enable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span><br>  <span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre><p>It’s a bit of a mouthful, but still completely valid JavaScript. It uses slightly different semantics, though. Default assignment inside object destructures checks if the property is strictly equal to <code>undefined</code>, and if so defaults the assignment.<p>But these strict equality tests for only <code>undefined</code> aren’t always desirable, and an object to perform destructing on isn’t always available. For instance, maybe you want to default on a function’s return values (no object to destructure). Or maybe the function returns <code>null</code> (which is common for DOM APIs). These are the times you want to reach for nullish coalescing:<pre class=language-js><code class=language-js><span class="token comment">// Concise nullish coalescing</span><br><span class="token keyword">const</span> link <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'link'</span><span class="token punctuation">)</span> <span class="token operator">??</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'link'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Default assignment destructure with boilerplate</span><br><span class="token keyword">const</span> <span class="token punctuation">{</span><br>  link <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'link'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>  link<span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'link'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">undefined</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Additionally, certain new features like <a href=/features/optional-chaining>optional chaining</a> don’t work perfectly with destructuring. Since destructuring requires an object, you must guard the destructure in case the optional chain returned <code>undefined</code> instead of an object. With nullish coalescing, we have no such problem:<pre class=language-js><code class=language-js><span class="token comment">// Optional chaining and nullish coalescing in tandem</span><br><span class="token keyword">const</span> link <span class="token operator">=</span> obj<span class="token punctuation">.</span>deep<span class="token operator">?.</span>container<span class="token punctuation">.</span>link <span class="token operator">??</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'link'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Default assignment destructure with optional chaining</span><br><span class="token keyword">const</span> <span class="token punctuation">{</span><br>  link <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'link'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>deep<span class="token operator">?.</span>container <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id=mixing-and-matching-operators>Mixing and matching operators <a href=#mixing-and-matching-operators class=bookmark>#</a></h2><p>Language design is hard, and we’re not always able to create new operators without a certain amount of ambiguity in the intention of the developer. If you’ve ever mixed the <code>&&</code> and <code>||</code> operators together, you’ve probably run into this ambiguity yourself. Imagine the expression <code>lhs && middle || rhs</code>. In JavaScript, this is actually parsed the same as the expression <code>(lhs && middle) || rhs</code>. Now imagine the expression <code>lhs || middle && rhs</code>. This one is actually parsed the same as <code>lhs || (middle && rhs)</code>.<p>You can probably see that the <code>&&</code> operator has a higher precedence for its left- and right-hand side than the <code>||</code> operator, meaning that the implied parentheses wrap the <code>&&</code> instead of the <code>||</code>. When designing the <code>??</code> operator, we had to decide what the precedence would be. It could either have:<ol><li>lower precedence than both <code>&&</code> and <code>||</code><li>lower than <code>&&</code> but higher than <code>||</code><li>higher precedence than both <code>&&</code> and <code>||</code></ol><p>For each of these precedence definitions, we then had to run it through the four possible test cases:<ol><li><code>lhs && middle ?? rhs</code><li><code>lhs ?? middle && rhs</code><li><code>lhs || middle ?? rhs</code><li><code>lhs ?? middle || rhs</code></ol><p>In each test expression, we had to decide where the implicit parenthesis belonged. And if they didn’t wrap the expression exactly the way the developer intended, then we’d have badly-written code. Unfortunately no matter which precedence level we chose, one of the test expressions could violate the developer’s intentions.<p>In the end, we decided to require explicit parentheses when mixing the <code>??</code> and (<code>&&</code> or <code>||</code>) (notice I was explicit with my parentheses grouping! meta joke!). If you mix, you must wrap one of the operator groups in parentheses, or you get a syntax error.<pre class=language-js><code class=language-js><span class="token comment">// Explicit parentheses groups are required to mix</span><br><span class="token punctuation">(</span>lhs <span class="token operator">&&</span> middle<span class="token punctuation">)</span> <span class="token operator">??</span> rhs<span class="token punctuation">;</span><br>lhs <span class="token operator">&&</span> <span class="token punctuation">(</span>middle <span class="token operator">??</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token punctuation">(</span>lhs <span class="token operator">??</span> middle<span class="token punctuation">)</span> <span class="token operator">&&</span> rhs<span class="token punctuation">;</span><br>lhs <span class="token operator">??</span> <span class="token punctuation">(</span>middle <span class="token operator">&&</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token punctuation">(</span>lhs <span class="token operator">||</span> middle<span class="token punctuation">)</span> <span class="token operator">??</span> rhs<span class="token punctuation">;</span><br>lhs <span class="token operator">||</span> <span class="token punctuation">(</span>middle <span class="token operator">??</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token punctuation">(</span>lhs <span class="token operator">??</span> middle<span class="token punctuation">)</span> <span class="token operator">||</span> rhs<span class="token punctuation">;</span><br>lhs <span class="token operator">??</span> <span class="token punctuation">(</span>middle <span class="token operator">||</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This way, the language parser always matches what the developer intended. And anyone later reading the code can immediately understand it, too. Nice!<h2 id=document.all>Tell me about <code>document.all</code> <a href=#document.all class=bookmark>#</a></h2><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/Document/all><code>document.all</code></a> is a special value that you should never ever ever use. But if you do use it, it’s best you know how it interacts with “truthy” and “nullish”.<p><code>document.all</code> is an array-like object, meaning it has indexed properties like an array and a length. Objects are usually truthy — but surprisingly, <code>document.all</code> pretends to be a falsy value! In fact, it’s loosely equal to both <code>null</code> and <code>undefined</code> (which normally means that it can’t have properties at all).<p>When using <code>document.all</code> with either <code>&&</code> or <code>||</code>, it pretends to be falsy. But, it’s not strictly equal to <code>null</code> nor <code>undefined</code>, so it’s not nullish. So when using <code>document.all</code> with <code>??</code>, it behaves like any other object would.<pre class=language-js><code class=language-js>document<span class="token punctuation">.</span>all <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// => true</span><br>document<span class="token punctuation">.</span>all <span class="token operator">??</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// => HTMLAllCollection[]</span></code></pre><h2 id=support>Support for nullish coalescing <a href=#support class=bookmark>#</a></h2><ul class=feature-support><li class="environment has-link has-support"><a href="https://bugs.chromium.org/p/v8/issues/detail?id=9547"><span class="icon chrome">Chrome:</span> <span class=support>自 <span class=version>80</span> 版本开始支持</span></a><li class="environment has-link has-support"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1566141"><span class="icon firefox">Firefox:</span> <span class=support>自 <span class=version>72</span> 版本开始支持</span></a><li class="environment has-link has-support"><a href=https://webkit.org/blog/10247/new-webkit-features-in-safari-13-1/ ><span class="icon safari">Safari:</span> <span class=support>自 <span class=version>13.1</span> 版本开始支持</span></a><li class="environment has-link has-support"><a href=https://medium.com/@nodejs/node-js-version-14-available-now-8170d384567e><span class="icon nodejs">Node.js:</span> <span class=support>自 <span class=version>14</span> 版本开始支持</span></a><li class="environment has-link has-support"><a href=https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator><span class="icon babel">Babel:</span> <span class=support>支持</span></a></ul><div class=feature-support-info><a href=/features/support>关于特性支持列表</a></div></div><footer><div><picture><source srcset="/_img/avatars/justin-ridgewell.avif, /_img/avatars/justin-ridgewell@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/justin-ridgewell.jpg srcset="/_img/avatars/justin-ridgewell@2x.jpg 2x" width=96></picture><p>作者：Justin Ridgewell.</div><a href=https://twitter.com/v8js/status/1173971116865523714 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/features/nullish-coalescing>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/features/nullish-coalescing.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>