<!doctype html><html lang=zh-CN><meta charset=utf-8><title>WebAssembly - adding a new opcode · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="This tutorial explains how to implement a new WebAssembly instruction in V8." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li><a href=/blog/ >博客</a><li class=active><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><h1>WebAssembly - adding a new opcode</h1><p><a href=https://webassembly.org/ >WebAssembly</a> (Wasm) is a binary instruction format for a stack-based virtual machine. This tutorial walks the reader through implementing a new WebAssembly instruction in V8.<p>WebAssembly is implemented in V8 in three parts:<ul><li>the interpreter<li>the baseline compiler (Liftoff)<li>the optimizing compiler (TurboFan)</ul><p>The rest of this document focuses on the TurboFan pipeline, walking through how to add a new Wasm instruction and implement it in TurboFan.<p>At a high level, Wasm instructions are compiled into a TurboFan graph, and we rely on the TurboFan pipeline to compile the graph into (ultimately) machine code. For more on TurboFan, check out the <a href=/docs/turbofan>V8 docs</a>.<h2 id=opcodes%2Finstructions>Opcodes/Instructions <a href=#opcodes%2Finstructions class=bookmark>#</a></h2><p>Let’s define a new instruction that adds <code>1</code> to an <a href=https://webassembly.github.io/spec/core/syntax/types.html#syntax-valtype><code>int32</code></a> (on the top of the stack).<div class=note><p><strong>Note:</strong> A list of instructions supported by all Wasm implementations can be found in the <a href=https://webassembly.github.io/spec/core/appendix/index-instructions.html>spec</a>.</div><p>All Wasm instructions are defined in <a href=https://cs.chromium.org/chromium/src/v8/src/wasm/wasm-opcodes.h><code>src/wasm/wasm-opcodes.h</code></a>. The instructions are grouped roughly by what they do, e.g. control, memory, SIMD, atomic, etc.<p>Let’s add our new instruction, <code>I32Add1</code>, to the <code>FOREACH_SIMPLE_OPCODE</code> section:<pre class=language-diff><code class=language-diff>diff --git a/src/wasm/wasm-opcodes.h b/src/wasm/wasm-opcodes.h<br>index 6970c667e7..867cbf451a 100644<br><span class="token coord">--- a/src/wasm/wasm-opcodes.h</span><br><span class="token coord">+++ b/src/wasm/wasm-opcodes.h</span><br>@@ -96,6 +96,7 @@ bool IsJSCompatibleSignature(const FunctionSig* sig, bool hasBigIntFeature);<br><br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">// Expressions with signatures.<br></span><span class="token prefix unchanged"> </span><span class="token line">#define FOREACH_SIMPLE_OPCODE(V)  \<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">  V(I32Add1, 0xee, i_i)           \<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  V(I32Eqz, 0x45, i_i)            \<br></span><span class="token prefix unchanged"> </span><span class="token line">  V(I32Eq, 0x46, i_ii)            \<br></span><span class="token prefix unchanged"> </span><span class="token line">  V(I32Ne, 0x47, i_ii)            \</span></span></code></pre><p>WebAssembly is a binary format, so <code>0xee</code> specifies the encoding of this instruction. In this tutorial we chose <code>0xee</code> as it is currently unused.<div class=note><p><strong>Note:</strong> Actually adding an instruction to the spec involves work beyond what is described here.</div><p>We can run a simple unit test for opcodes with:<pre><code>$ tools/dev/gm.py x64.debug unittests/WasmOpcodesTest*
...
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from WasmOpcodesTest
[ RUN      ] WasmOpcodesTest.EveryOpcodeHasAName
../../test/unittests/wasm/wasm-opcodes-unittest.cc:27: Failure
Value of: false
  Actual: false
Expected: true
WasmOpcodes::OpcodeName(kExprI32Add1) == "unknown"; plazz halp in src/wasm/wasm-opcodes.cc
[  FAILED  ] WasmOpcodesTest.EveryOpcodeHasAName
</code></pre><p>This error indicates that we don’t have a name for our new instruction. Adding a name for the new opcode can be done in <a href=https://cs.chromium.org/chromium/src/v8/src/wasm/wasm-opcodes.cc><code>src/wasm/wasm-opcodes.cc</code></a>:<pre class=language-diff><code class=language-diff>diff --git a/src/wasm/wasm-opcodes.cc b/src/wasm/wasm-opcodes.cc<br>index 5ed664441d..2d4e9554fe 100644<br><span class="token coord">--- a/src/wasm/wasm-opcodes.cc</span><br><span class="token coord">+++ b/src/wasm/wasm-opcodes.cc</span><br>@@ -75,6 +75,7 @@ const char* WasmOpcodes::OpcodeName(WasmOpcode opcode) {<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    // clang-format off<br></span></span><br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    // Standard opcodes<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">    CASE_I32_OP(Add1, "add1")<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    CASE_INT_OP(Eqz, "eqz")<br></span><span class="token prefix unchanged"> </span><span class="token line">    CASE_ALL_OP(Eq, "eq")<br></span><span class="token prefix unchanged"> </span><span class="token line">    CASE_I64x2_OP(Eq, "eq")</span></span></code></pre><p>By adding our new instruction in <code>FOREACH_SIMPLE_OPCODE</code>, we are skipping a <a href="https://cs.chromium.org/chromium/src/v8/src/wasm/function-body-decoder-impl.h?l=1751-1756&rcl=686b68edf9f42c201c2b25bca9f4bef72ff41c0b">fair amount of work</a> that is done in <code>src/wasm/function-body-decoder-impl.h</code>, which decodes Wasm opcodes and calls into the TurboFan graph generator. Thus, depending on what your opcode does, you might have more work to do. We skip this in the interest of brevity.<h2 id=test>Writing a test for the new opcode <a href=#test class=bookmark>#</a></h2><p>Wasm tests can be found in <a href=https://cs.chromium.org/chromium/src/v8/test/cctest/wasm/ ><code>test/cctest/wasm/</code></a>. Let’s take a look at <a href=https://cs.chromium.org/chromium/src/v8/test/cctest/wasm/test-run-wasm.cc><code>test/cctest/wasm/test-run-wasm.cc</code></a>, where many “simple” opcodes are tested.<p>There are many examples in this file that we can follow. The general setup is:<ul><li>create a <code>WasmRunner</code><li>set up globals to hold result (optional)<li>set up locals as parameters to instruction (optional)<li>build the wasm module<li>run it and compare with an expected output</ul><p>Here’s a simple test for our new opcode:<pre class=language-diff><code class=language-diff>diff --git a/test/cctest/wasm/test-run-wasm.cc b/test/cctest/wasm/test-run-wasm.cc<br>index 26df61ceb8..b1ee6edd71 100644<br><span class="token coord">--- a/test/cctest/wasm/test-run-wasm.cc</span><br><span class="token coord">+++ b/test/cctest/wasm/test-run-wasm.cc</span><br>@@ -28,6 +28,15 @@ namespace test_run_wasm {<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define RET(x) x, kExprReturn<br></span><span class="token prefix unchanged"> </span><span class="token line">#define RET_I8(x) WASM_I32V_2(x), kExprReturn<br></span></span><br><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">#define WASM_I32_ADD1(x) x, kExprI32Add1<br></span><span class="token prefix inserted">+</span><span class="token line"><br></span><span class="token prefix inserted">+</span><span class="token line">WASM_EXEC_TEST(Int32Add1) {<br></span><span class="token prefix inserted">+</span><span class="token line">  WasmRunner&lt;int32_t> r(execution_tier);<br></span><span class="token prefix inserted">+</span><span class="token line">  // 10 + 1<br></span><span class="token prefix inserted">+</span><span class="token line">  BUILD(r, WASM_I32_ADD1(WASM_I32V_1(10)));<br></span><span class="token prefix inserted">+</span><span class="token line">  CHECK_EQ(11, r.Call());<br></span><span class="token prefix inserted">+</span><span class="token line">}<br></span><span class="token prefix inserted">+</span><span class="token line"><br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">WASM_EXEC_TEST(Int32Const) {<br></span><span class="token prefix unchanged"> </span><span class="token line">  WasmRunner&lt;int32_t> r(execution_tier);<br></span><span class="token prefix unchanged"> </span><span class="token line">  const int32_t kExpectedValue = 0x11223344;</span></span></code></pre><p>Run the test:<pre><code>$ tools/dev/gm.py x64.debug 'cctest/test-run-wasm-simd/RunWasmTurbofan_I32Add1'
...
=== cctest/test-run-wasm/RunWasmTurbofan_Int32Add1 ===
#
# Fatal error in ../../src/compiler/wasm-compiler.cc, line 988
# Unsupported opcode 0xee:i32.add1
</code></pre><div class=note><p><strong>Tip:</strong> Finding the test name can be tricky, since the test definition is behind a macro. Use <a href=https://cs.chromium.org/ >Code Search</a> to click around to discover the macro definitions.</div><p>This error indicates that the compiler does not know of our new instruction. That will change in the next section.<h2 id=compiling-wasm-into-turbofan>Compiling Wasm into TurboFan <a href=#compiling-wasm-into-turbofan class=bookmark>#</a></h2><p>In the introduction, we mentioned that Wasm instructions are compiled into a TurboFan graph. <code>wasm-compiler.cc</code> is where this happens. Let’s take a look at an example opcode, <a href="https://cs.chromium.org/chromium/src/v8/src/compiler/wasm-compiler.cc?l=716&rcl=686b68edf9f42c201c2b25bca9f4bef72ff41c0b"><code>I32Eqz</code></a>:<pre class=language-cpp><code class=language-cpp>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>opcode<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> wasm<span class="token operator">::</span>kExprI32Eqz<span class="token operator">:</span><br>      op <span class="token operator">=</span> m<span class="token operator">-></span><span class="token function">Word32Equal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token keyword">return</span> <span class="token function">graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">NewNode</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> input<span class="token punctuation">,</span> <span class="token function">mcgraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Int32Constant</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This switches on the Wasm opcode <code>wasm::kExprI32Eqz</code>, and builds a TurboFan graph consisting of the operation <code>Word32Equal</code> with the inputs <code>input</code>, which is the argument to the Wasm instruction, and a constant <code>0</code>.<p>The <code>Word32Equal</code> operator is provided by the underlying V8 abstract machine, which is architecture-independent. Later in the pipeline, this abstract machine operator will be translated into architecture-dependent assembly.<p>For our new opcode, <code>I32Add1</code>, we need a graph that adds a constant 1 to the input, so we can resuse an existing machine operator, <code>Int32Add</code>, passing it the input, and a constant 1:<pre class=language-diff><code class=language-diff>diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc<br>index f666bbb7c1..399293c03b 100644<br><span class="token coord">--- a/src/compiler/wasm-compiler.cc</span><br><span class="token coord">+++ b/src/compiler/wasm-compiler.cc</span><br>@@ -713,6 +713,8 @@ Node* WasmGraphBuilder::Unop(wasm::WasmOpcode opcode, Node* input,<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  const Operator* op;<br></span><span class="token prefix unchanged"> </span><span class="token line">  MachineOperatorBuilder* m = mcgraph()->machine();<br></span><span class="token prefix unchanged"> </span><span class="token line">  switch (opcode) {<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">    case wasm::kExprI32Add1:<br></span><span class="token prefix inserted">+</span><span class="token line">      return graph()->NewNode(m->Int32Add(), input, mcgraph()->Int32Constant(1));<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    case wasm::kExprI32Eqz:<br></span><span class="token prefix unchanged"> </span><span class="token line">      op = m->Word32Equal();<br></span><span class="token prefix unchanged"> </span><span class="token line">      return graph()->NewNode(op, input, mcgraph()->Int32Constant(0));</span></span></code></pre><p>This is enough to get the test passing. However, not all instructions have an existing TurboFan machine operator. In that case we have to add this new operator to the machine. Let’s try that.<h2 id=turbofan-machine-operators>TurboFan machine operators <a href=#turbofan-machine-operators class=bookmark>#</a></h2><p>We want to add the knowledge of <code>Int32Add1</code> to the TurboFan machine. So let’s pretend that it exists and use it first:<pre class=language-diff><code class=language-diff>diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc<br>index f666bbb7c1..1d93601584 100644<br><span class="token coord">--- a/src/compiler/wasm-compiler.cc</span><br><span class="token coord">+++ b/src/compiler/wasm-compiler.cc</span><br>@@ -713,6 +713,8 @@ Node* WasmGraphBuilder::Unop(wasm::WasmOpcode opcode, Node* input,<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  const Operator* op;<br></span><span class="token prefix unchanged"> </span><span class="token line">  MachineOperatorBuilder* m = mcgraph()->machine();<br></span><span class="token prefix unchanged"> </span><span class="token line">  switch (opcode) {<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">    case wasm::kExprI32Add1:<br></span><span class="token prefix inserted">+</span><span class="token line">      return graph()->NewNode(m->Int32Add1(), input);<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    case wasm::kExprI32Eqz:<br></span><span class="token prefix unchanged"> </span><span class="token line">      op = m->Word32Equal();<br></span><span class="token prefix unchanged"> </span><span class="token line">      return graph()->NewNode(op, input, mcgraph()->Int32Constant(0));</span></span></code></pre><p>Trying to run the same test leads to a compilation failure that hints at where to make changes:<pre><code>../../src/compiler/wasm-compiler.cc:717:34: error: no member named 'Int32Add1' in 'v8::internal::compiler::MachineOperatorBuilder'; did you mean 'Int32Add'?
      return graph()->NewNode(m->Int32Add1(), input);
                                 ^~~~~~~~~
                                 Int32Add
</code></pre><p>There are a couple of places that needs to be modified to add an operator:<ol><li><a href=https://cs.chromium.org/chromium/src/v8/src/compiler/machine-operator.cc><code>src/compiler/machine-operator.cc</code></a><li>header <a href=https://cs.chromium.org/chromium/src/v8/src/compiler/machine-operator.h><code>src/compiler/machine-operator.h</code></a><li>list of opcodes that the machine understands <a href=https://cs.chromium.org/chromium/src/v8/src/compiler/opcodes.h><code>src/compiler/opcodes.h</code></a><li>verifier <a href=https://cs.chromium.org/chromium/src/v8/src/compiler/verifier.cc><code>src/compiler/verifier.cc</code></a></ol><pre class=language-diff><code class=language-diff>diff --git a/src/compiler/machine-operator.cc b/src/compiler/machine-operator.cc<br>index 16e838c2aa..fdd6d951f0 100644<br><span class="token coord">--- a/src/compiler/machine-operator.cc</span><br><span class="token coord">+++ b/src/compiler/machine-operator.cc</span><br>@@ -136,6 +136,7 @@ MachineType AtomicOpType(Operator const* op) {<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define MACHINE_PURE_OP_LIST(V)                                               \<br></span><span class="token prefix unchanged"> </span><span class="token line">  PURE_BINARY_OP_LIST_32(V)                                                   \<br></span><span class="token prefix unchanged"> </span><span class="token line">  PURE_BINARY_OP_LIST_64(V)                                                   \<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">  V(Int32Add1, Operator::kNoProperties, 1, 0, 1)                              \<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  V(Word32Clz, Operator::kNoProperties, 1, 0, 1)                              \<br></span><span class="token prefix unchanged"> </span><span class="token line">  V(Word64Clz, Operator::kNoProperties, 1, 0, 1)                              \<br></span><span class="token prefix unchanged"> </span><span class="token line">  V(Word32ReverseBytes, Operator::kNoProperties, 1, 0, 1)                     \</span></span></code></pre><pre class=language-diff><code class=language-diff>diff --git a/src/compiler/machine-operator.h b/src/compiler/machine-operator.h<br>index a2b9fce0ee..f95e75a445 100644<br><span class="token coord">--- a/src/compiler/machine-operator.h</span><br><span class="token coord">+++ b/src/compiler/machine-operator.h</span><br>@@ -265,6 +265,8 @@ class V8_EXPORT_PRIVATE MachineOperatorBuilder final<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  const Operator* Word32PairShr();<br></span><span class="token prefix unchanged"> </span><span class="token line">  const Operator* Word32PairSar();<br></span></span><br><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">  const Operator* Int32Add1();<br></span><span class="token prefix inserted">+</span><span class="token line"><br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  const Operator* Int32Add();<br></span><span class="token prefix unchanged"> </span><span class="token line">  const Operator* Int32AddWithOverflow();<br></span><span class="token prefix unchanged"> </span><span class="token line">  const Operator* Int32Sub();</span></span></code></pre><pre class=language-diff><code class=language-diff>diff --git a/src/compiler/opcodes.h b/src/compiler/opcodes.h<br>index ce24a0bd3f..2c8c5ebaca 100644<br><span class="token coord">--- a/src/compiler/opcodes.h</span><br><span class="token coord">+++ b/src/compiler/opcodes.h</span><br><span class="token coord">@@ -506,6 +506,7 @@</span><br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  V(Float64LessThanOrEqual)<br></span></span><br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define MACHINE_UNOP_32_LIST(V) \<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">  V(Int32Add1)                  \<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  V(Word32Clz)                  \<br></span><span class="token prefix unchanged"> </span><span class="token line">  V(Word32Ctz)                  \<br></span><span class="token prefix unchanged"> </span><span class="token line">  V(Int32AbsWithOverflow)       \</span></span></code></pre><pre class=language-diff><code class=language-diff>diff --git a/src/compiler/verifier.cc b/src/compiler/verifier.cc<br>index 461aef0023..95251934ce 100644<br><span class="token coord">--- a/src/compiler/verifier.cc</span><br><span class="token coord">+++ b/src/compiler/verifier.cc</span><br>@@ -1861,6 +1861,7 @@ void Verifier::Visitor::Check(Node* node, const AllNodes& all) {<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    case IrOpcode::kSignExtendWord16ToInt64:<br></span><span class="token prefix unchanged"> </span><span class="token line">    case IrOpcode::kSignExtendWord32ToInt64:<br></span><span class="token prefix unchanged"> </span><span class="token line">    case IrOpcode::kStaticAssert:<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">    case IrOpcode::kInt32Add1:<br></span></span><br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SIMD_MACHINE_OP_CASE(Name) case IrOpcode::k##Name:<br></span><span class="token prefix unchanged"> </span><span class="token line">      MACHINE_SIMD_OP_LIST(SIMD_MACHINE_OP_CASE)</span></span></code></pre><p>Running the test again now gives us a different failure:<pre><code>=== cctest/test-run-wasm/RunWasmTurbofan_Int32Add1 ===
#
# Fatal error in ../../src/compiler/backend/instruction-selector.cc, line 2072
# Unexpected operator #289:Int32Add1 @ node #7
</code></pre><h2 id=instruction-selection>Instruction selection <a href=#instruction-selection class=bookmark>#</a></h2><p>So far we have been working at the TurboFan level, dealing with (a sea of) nodes in the TurboFan graph. However, at the assembly level, we have instructions and operands. Instruction selection is the process of translating this graph to instructions and operands.<p>The last test error indicated that we need something in <a href=https://cs.chromium.org/chromium/src/v8/src/compiler/backend/instruction-selector.cc><code>src/compiler/backend/instruction-selector.cc</code></a>. This is a big file with a giant switch statement over all the machine opcodes. It calls into architecture specific instruction selection, using the visitor pattern to emit instructions for each type of node.<p>Since we added a new TurboFan machine opcode, we need to add it here as well:<pre class=language-diff><code class=language-diff>diff --git a/src/compiler/backend/instruction-selector.cc b/src/compiler/backend/instruction-selector.cc<br>index 3152b2d41e..7375085649 100644<br><span class="token coord">--- a/src/compiler/backend/instruction-selector.cc</span><br><span class="token coord">+++ b/src/compiler/backend/instruction-selector.cc</span><br>@@ -2067,6 +2067,8 @@ void InstructionSelector::VisitNode(Node* node) {<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">      return MarkAsWord32(node), VisitS1x16AnyTrue(node);<br></span><span class="token prefix unchanged"> </span><span class="token line">    case IrOpcode::kS1x16AllTrue:<br></span><span class="token prefix unchanged"> </span><span class="token line">      return MarkAsWord32(node), VisitS1x16AllTrue(node);<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">    case IrOpcode::kInt32Add1:<br></span><span class="token prefix inserted">+</span><span class="token line">      return MarkAsWord32(node), VisitInt32Add1(node);<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    default:<br></span><span class="token prefix unchanged"> </span><span class="token line">      FATAL("Unexpected operator #%d:%s @ node #%d", node->opcode(),<br></span><span class="token prefix unchanged"> </span><span class="token line">            node->op()->mnemonic(), node->id());</span></span></code></pre><p>Instruction selection is architecture dependent, so we have to add it to the architecture specific instruction selector files too. For this codelab we only focus on the x64 architecture, so <a href=https://cs.chromium.org/chromium/src/v8/src/compiler/backend/x64/instruction-selector-x64.cc><code>src/compiler/backend/x64/instruction-selector-x64.cc</code></a><br>needs to be modified:<pre class=language-diff><code class=language-diff>diff --git a/src/compiler/backend/x64/instruction-selector-x64.cc b/src/compiler/backend/x64/instruction-selector-x64.cc<br>index 2324e119a6..4b55671243 100644<br><span class="token coord">--- a/src/compiler/backend/x64/instruction-selector-x64.cc</span><br><span class="token coord">+++ b/src/compiler/backend/x64/instruction-selector-x64.cc</span><br>@@ -841,6 +841,11 @@ void InstructionSelector::VisitWord32ReverseBytes(Node* node) {<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  Emit(kX64Bswap32, g.DefineSameAsFirst(node), g.UseRegister(node->InputAt(0)));<br></span><span class="token prefix unchanged"> </span><span class="token line">}<br></span></span><br><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">void InstructionSelector::VisitInt32Add1(Node* node) {<br></span><span class="token prefix inserted">+</span><span class="token line">  X64OperandGenerator g(this);<br></span><span class="token prefix inserted">+</span><span class="token line">  Emit(kX64Int32Add1, g.DefineSameAsFirst(node), g.UseRegister(node->InputAt(0)));<br></span><span class="token prefix inserted">+</span><span class="token line">}<br></span><span class="token prefix inserted">+</span><span class="token line"></span></span></code></pre><p>And we also need to add this new x64-specific opcode, <code>kX64Int32Add1</code> to <a href=https://cs.chromium.org/chromium/src/v8/src/compiler/backend/x64/instruction-codes-x64.h><code>src/compiler/backend/x64/instruction-codes-x64.h</code></a>:<pre class=language-diff><code class=language-diff>diff --git a/src/compiler/backend/x64/instruction-codes-x64.h b/src/compiler/backend/x64/instruction-codes-x64.h<br>index 9b8be0e0b5..7f5faeb87b 100644<br><span class="token coord">--- a/src/compiler/backend/x64/instruction-codes-x64.h</span><br><span class="token coord">+++ b/src/compiler/backend/x64/instruction-codes-x64.h</span><br>@@ -12,6 +12,7 @@ namespace compiler {<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">// X64-specific opcodes that specify which assembly sequence to emit.<br></span><span class="token prefix unchanged"> </span><span class="token line">// Most opcodes specify a single instruction.<br></span><span class="token prefix unchanged"> </span><span class="token line">#define TARGET_ARCH_OPCODE_LIST(V)        \<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">  V(X64Int32Add1)                         \<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  V(X64Add)                               \<br></span><span class="token prefix unchanged"> </span><span class="token line">  V(X64Add32)                             \<br></span><span class="token prefix unchanged"> </span><span class="token line">  V(X64And)                               \</span></span></code></pre><h2 id=instruction-scheduling-and-code-generation>Instruction scheduling and code generation <a href=#instruction-scheduling-and-code-generation class=bookmark>#</a></h2><p>Running our test, we see new compilation errors:<pre><code>../../src/compiler/backend/x64/instruction-scheduler-x64.cc:15:11: error: enumeration value 'kX64Int32Add1' not handled in switch [-Werror,-Wswitch]
  switch (instr->arch_opcode()) {
          ^
1 error generated.
...
../../src/compiler/backend/x64/code-generator-x64.cc:733:11: error: enumeration value 'kX64Int32Add1' not handled in switch [-Werror,-Wswitch]
  switch (arch_opcode) {
          ^
1 error generated.
</code></pre><p><a href=https://en.wikipedia.org/wiki/Instruction_scheduling>Instruction scheduling</a> takes care of dependencies that instructions may have to allow for more optimization (e.g. instruction reordering). Our new opcode has no data dependency, so we can add it simply to: <a href=https://cs.chromium.org/chromium/src/v8/src/compiler/backend/x64/instruction-scheduler-x64.cc><code>src/compiler/backend/x64/instruction-scheduler-x64.cc</code></a>:<pre class=language-diff><code class=language-diff>diff --git a/src/compiler/backend/x64/instruction-scheduler-x64.cc b/src/compiler/backend/x64/instruction-scheduler-x64.cc<br>index 79eda7e78d..3667a84577 100644<br><span class="token coord">--- a/src/compiler/backend/x64/instruction-scheduler-x64.cc</span><br><span class="token coord">+++ b/src/compiler/backend/x64/instruction-scheduler-x64.cc</span><br>@@ -13,6 +13,7 @@ bool InstructionScheduler::SchedulerSupported() { return true; }<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int InstructionScheduler::GetTargetInstructionFlags(<br></span><span class="token prefix unchanged"> </span><span class="token line">    const Instruction* instr) const {<br></span><span class="token prefix unchanged"> </span><span class="token line">  switch (instr->arch_opcode()) {<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">    case kX64Int32Add1:<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    case kX64Add:<br></span><span class="token prefix unchanged"> </span><span class="token line">    case kX64Add32:<br></span><span class="token prefix unchanged"> </span><span class="token line">    case kX64And:</span></span></code></pre><p>Code generation is where we translate our architecture specific opcodes into assembly. Let’s add a clause to <a href=https://cs.chromium.org/chromium/src/v8/src/compiler/backend/x64/code-generator-x64.cc><code>src/compiler/backend/x64/code-generator-x64.cc</code></a>:<pre class=language-diff><code class=language-diff>diff --git a/src/compiler/backend/x64/code-generator-x64.cc b/src/compiler/backend/x64/code-generator-x64.cc<br>index 61c3a45a16..9c37ed7464 100644<br><span class="token coord">--- a/src/compiler/backend/x64/code-generator-x64.cc</span><br><span class="token coord">+++ b/src/compiler/backend/x64/code-generator-x64.cc</span><br>@@ -731,6 +731,9 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  InstructionCode opcode = instr->opcode();<br></span><span class="token prefix unchanged"> </span><span class="token line">  ArchOpcode arch_opcode = ArchOpcodeField::decode(opcode);<br></span><span class="token prefix unchanged"> </span><span class="token line">  switch (arch_opcode) {<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">    case kX64Int32Add1: {<br></span><span class="token prefix inserted">+</span><span class="token line">      break;<br></span><span class="token prefix inserted">+</span><span class="token line">    }<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    case kArchCallCodeObject: {<br></span><span class="token prefix unchanged"> </span><span class="token line">      if (HasImmediateInput(instr, 0)) {<br></span><span class="token prefix unchanged"> </span><span class="token line">        Handle&lt;Code> code = i.InputCode(0);</span></span></code></pre><p>For now we leave our code generation empty, and we can run the test to make sure everything compiles:<pre><code>=== cctest/test-run-wasm/RunWasmTurbofan_Int32Add1 ===
#
# Fatal error in ../../test/cctest/wasm/test-run-wasm.cc, line 37
# Check failed: 11 == r.Call() (11 vs. 10).
</code></pre><p>This failure is expected, since our new instruction is not implemented yet — it is essentially a no-op, so our actual value was unchanged (<code>10</code>).<p>To implement our opcode, we can use the <code>add</code> assembly instruction:<pre class=language-diff><code class=language-diff>diff --git a/src/compiler/backend/x64/code-generator-x64.cc b/src/compiler/backend/x64/code-generator-x64.cc<br>index 6c828d6bc4..260c8619f2 100644<br><span class="token coord">--- a/src/compiler/backend/x64/code-generator-x64.cc</span><br><span class="token coord">+++ b/src/compiler/backend/x64/code-generator-x64.cc</span><br>@@ -744,6 +744,11 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  InstructionCode opcode = instr->opcode();<br></span><span class="token prefix unchanged"> </span><span class="token line">  ArchOpcode arch_opcode = ArchOpcodeField::decode(opcode);<br></span><span class="token prefix unchanged"> </span><span class="token line">  switch (arch_opcode) {<br></span></span><span class="token inserted inserted-sign"><span class="token prefix inserted">+</span><span class="token line">    case kX64Int32Add1: {<br></span><span class="token prefix inserted">+</span><span class="token line">      DCHECK_EQ(i.OutputRegister(), i.InputRegister(0));<br></span><span class="token prefix inserted">+</span><span class="token line">      __ addl(i.InputRegister(0), Immediate(1));<br></span><span class="token prefix inserted">+</span><span class="token line">      break;<br></span><span class="token prefix inserted">+</span><span class="token line">    }<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    case kArchCallCodeObject: {<br></span><span class="token prefix unchanged"> </span><span class="token line">      if (HasImmediateInput(instr, 0)) {<br></span><span class="token prefix unchanged"> </span><span class="token line">        Handle&lt;Code> code = i.InputCode(0);</span></span></code></pre><p>And this makes the test pass:<p>Luckily for us <code>addl</code> is already implemented. If our new opcode required writing a new assembly instruction implementation, we would add it to <a href=https://cs.chromium.org/chromium/src/v8/src/codegen/x64/assembler-x64.cc><code>src/compiler/backend/x64/assembler-x64.cc</code></a>, where the assembly instruction is encoded into bytes and emitted.<div class=note><p><strong>Tip:</strong> To inspect the generated code, we can pass <code>--print-code</code> to <code>cctest</code>.</div><h2 id=other-architectures>Other architectures <a href=#other-architectures class=bookmark>#</a></h2><p>In this codelab we only implemented this new instruction for x64. The steps required for other architectures are similar: add TurboFan machine operators, use the platform-dependent files for instruction selection, scheduling, code generation, assembler.<p>Tip: if we compile what we have done so far on another target, e.g. arm64, we are likely to get errors in linking. To resolve those errors, add <code>UNIMPLEMENTED()</code> stubs.</main><footer id=footer><div><nav><a href=https://v8.dev/docs/webassembly-opcode>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/docs/webassembly-opcode.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>