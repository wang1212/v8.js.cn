<!doctype html><html lang=zh-CN><meta charset=utf-8><title>V8 Torque user manual · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="This document explains the V8 Torque language, as used in the V8 codebase." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li><a href=/blog/ >博客</a><li class=active><a href=/docs/ >文档</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><h1>V8 Torque user manual</h1><p>V8 Torque is a language that allows developers contributing to the V8 project to express changes in the VM by focusing on the <em>intent</em> of their changes to the VM, rather than preoccupying themselves with unrelated implementation details. The language was designed to be simple enough to make it easy to directly translate the <a href=https://tc39.es/ecma262/ >ECMAScript specification</a> into an implementation in V8, but powerful enough to express the low-level V8 optimization tricks in a robust way, like creating fast-paths based on tests for specific object-shapes.<p>Torque will be familiar to V8 engineers and JavaScript developers, combining a TypeScript-like syntax that eases both writing and understanding V8 code with syntax and types that reflects concepts that are already common in the <a href=/blog/csa><code>CodeStubAssembler</code></a>. With a strong type system and structured control flow, Torque ensures correctness by construction. Torque’s expressiveness is sufficient to express almost all of the functionality that is <a href=/docs/builtin-functions>currently found in V8’s builtins</a>. It also is very interoperable with <code>CodeStubAssembler</code> builtins and <code>macro</code>s written in C++, allowing Torque code to use hand-written CSA functionality and vice-versa.<p>Torque provides language constructs to represent high-level, semantically-rich tidbits of V8 implementation, and the Torque compiler converts these morsels into efficient assembly code using the <code>CodeStubAssembler</code>. Both Torque’s language structure and the Torque compiler’s error checking ensure correctness in ways that were previously laborious and error-prone with direct usage of the <code>CodeStubAssembler</code>. Traditionally, writing optimal code with the <code>CodeStubAssembler</code> required V8 engineers to carry a lot of specialized knowledge in their heads — much of which was never formally captured in any written documentation — to avoid subtle pitfalls in their implementation. Without that knowledge, the learning curve for writing efficient builtins was steep. Even armed with the necessary knowledge, non-obvious and non-policed gotchas often led to correctness or <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=775888">security</a> <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=785804">bugs</a>. With Torque, many of these pitfalls can be avoided and recognized automatically by the Torque compiler.<h2 id=getting-started>Getting started <a href=#getting-started class=bookmark>#</a></h2><p>Most source written in Torque is checked into the V8 repository under <a href=https://github.com/v8/v8/tree/master/src/builtins>the <code>src/builtins</code> directory</a>, with the file extension <code>.tq</code>. (The actual Torque compiler can be found under <a href=https://github.com/v8/v8/tree/master/src/torque><code>src/torque</code></a>.). Tests for Torque functionality are checked in under <a href=https://github.com/v8/v8/tree/master/test/torque><code>test/torque</code></a>.<p>To give you a taste of the language, let’s write a V8 builtin that prints “Hello World!”. To do this, we’ll add a Torque <code>macro</code> in a test case and call it from the <code>cctest</code> test framework.<p>Begin by opening up the <code>test/torque/test-torque.tq</code> file and add the following code at the end (but before the last closing <code>}</code>):<pre class=language-torque><code class=language-torque>@export<br><span class="token keyword">macro</span> PrintHelloWorld<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  Print<span class="token punctuation">(</span><span class="token string">'Hello world!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Next, open up <code>test/cctest/torque/test-torque.cc</code> and add the following test case that uses the new Torque code to build a code stub:<pre class=language-cpp><code class=language-cpp><span class="token function">TEST</span><span class="token punctuation">(</span>HelloWorld<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  Isolate<span class="token operator">*</span> <span class="token function">isolate</span><span class="token punctuation">(</span><span class="token class-name">CcTest</span><span class="token operator">::</span><span class="token function">InitIsolateOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  CodeAssemblerTester <span class="token function">asm_tester</span><span class="token punctuation">(</span>isolate<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  TestTorqueAssembler <span class="token function">m</span><span class="token punctuation">(</span>asm_tester<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">{</span><br>    m<span class="token punctuation">.</span><span class="token function">PrintHelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    m<span class="token punctuation">.</span><span class="token function">Return</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">UndefinedConstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  FunctionTester <span class="token function">ft</span><span class="token punctuation">(</span>asm_tester<span class="token punctuation">.</span><span class="token function">GenerateCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  ft<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Then <a href=/docs/test>build the <code>cctest</code> executable</a>, and finally execute the <code>cctest</code> test to print ‘Hello world’:<pre class=language-bash><code class=language-bash>$ out/x64.debug/cctest test-torque/HelloWorld<br>Hello world<span class="token operator">!</span></code></pre><h2 id=how-torque-generates-code>How Torque generates code <a href=#how-torque-generates-code class=bookmark>#</a></h2><p>The Torque compiler doesn’t create machine code directly, but rather generates C++ code that calls V8’s existing <code>CodeStubAssembler</code> interface. The <code>CodeStubAssembler</code> uses the <a href=https://v8.dev/docs/turbofan>TurboFan compiler’s</a> backend to generate efficient code. Torque compilation therefore requires multiple steps:<ol><li>The <code>gn</code> build first runs the Torque compiler. It processes all <code>*.tq</code> files, outputting corresponding <code>*-tq-csa.cc</code><br>and <code>*-tq-csa.h</code> files in appropriate subdirectories under <code>gen/torque-generated</code>. The Torque compiler also generates various known <code>.h</code> files, meant to be consumed by the V8 build. These contain any class definitions found in the <code>.tq</code> files under<br>compile.<li>The <code>.h</code> files produced by Torque are included at strategic points in the V8 build, supplementing class definitions declared "by hand" in the V8 sources.<li>The <code>gn</code> build then compiles the generated <code>.cc</code> files from step 1 into the <code>mksnapshot</code> executable.<li>When <code>mksnapshot</code> runs, all of V8’s builtins are generated and packaged in to the snapshot file, including those that are defined in Torque and any other builtins that use Torque-defined functionality.<li>The rest of V8 is built. All of Torque-authored builtins are made accessible via the snapshot file which is linked into V8. They can be called like any other builtin. In the final packaging, no direct traces of Torque remain (except for debug information): neither the Torque source code (<code>.tq</code> files) nor Torque-generated <code>.cc</code> files are included in the <code>d8</code> or <code>chrome</code> executable.</ol><p>Graphically, the build process looks like this:<figure><img alt="" height=480 loading=lazy src=/_img/docs/torque/build-process.svg width=800></figure><h2 id=tooling>Torque tooling <a href=#tooling class=bookmark>#</a></h2><p>Basic tooling and development environment support is available for Torque.<ul><li>There is a Visual Studio code syntax highlighting plugin available for Torque: <code>tools/torque/vscode-torque</code><li>There is also a formatting tool that should be used after changing <code>.tq</code> files: <code>tools/torque/format-torque.py -i &lt;filename></code></ul><h2 id=troubleshooting>Troubleshooting builds involving Torque <a href=#troubleshooting class=bookmark>#</a></h2><p>Why do you need to know this? Understanding how Torque files get converted into machine code is important because different problems (and bugs) can potentially arise in the different stages of translating Torque into the binary bits embedded in the snapshot:<ul><li>If you have a syntax or semantic error in Torque code (i.e. a <code>.tq</code> file), the Torque compiler fails. The V8 build aborts during this stage, and you will not see other errors that may be uncovered by later parts of the build.<li>Once your Torque code is syntactically correct and passes the Torque compiler’s (more or less) rigorous semantic checks, the build of <code>mksnapshot</code> can still fail. This most frequently happens with inconsistencies in external definitions provided in <code>.tq</code> files. Definitions marked with the <code>extern</code> keyword in Torque code signal to the Torque compiler that the definition of required functionality is found in C++. Currently, the coupling between <code>extern</code> definitions from <code>.tq</code> files and the C++ code to which those <code>extern</code> definitions refer is loose, and there is no verification at Torque-compile time of that coupling. When <code>extern</code> definitions don’t match (or in the most subtle cases mask) the functionality that they access in the <code>code-stub-assembler.h</code> header file or other V8 headers, the C++ build of <code>mksnapshot</code> fails, usually in <code>*-gen.cc</code> files.<li>Even once <code>mksnapshot</code> successfully builds, it can fail during execution if a Torque-provided builtin has a bug. Many builtins run as part of snapshot creation, including Torque-generated ones. For example, <code>Array.prototype.splice</code>, a Torque-authored builtin, is called as part of the JavaScript snapshot initialization process to setup the default JavaScript environment. If there is a bug in the implementation, <code>mksnapshot</code> crashes during execution. When <code>mksnapshot</code> crashes, it’s sometimes useful to call <code>mksnapshot</code> passing the <code>--gdb-jit-full</code> flag, which generates extra debug information that provides useful context, e.g. names for Torque-generated builtins in <code>gdb</code> stack crawls.<li>Of course, even if Torque-authored code makes it through <code>mksnapshot</code>, it still may be buggy or crash. Adding test cases to <code>torque-test.tq</code> and <code>torque-test.cc</code> is a good way to ensure that your Torque code does what you actually expect. If your Torque code does end up crashing in <code>d8</code> or <code>chrome</code>, the <code>--gdb-jit-full</code> flag is again very useful.</ul><h2 id=constexpr><code>constexpr</code>: compile-time vs. run-time <a href=#constexpr class=bookmark>#</a></h2><p>Understanding the Torque build process is also important to understanding a core feature in the Torque language: <code>constexpr</code>.<p>Torque allows evaluation of expressions in Torque code at runtime (i.e. when V8 builtins are executed as part of executing JavaScript). However, it also allows expressions to be executed at compile time (i.e. as part of the Torque build process and before the V8 library and <code>d8</code> executable have even been created).<p>Torque uses the <code>constexpr</code> keyword to indicate that an expression must be evaluated at build-time. Its usage is somewhat analogous to <a href=https://en.cppreference.com/w/cpp/language/constexpr>C++’s <code>constexpr</code></a>: in addition to borrowing the <code>constexpr</code> keyword and some of its syntax from C++, Torque similarly uses <code>constexpr</code> to indicate the distinction between evaluation at compile-time and runtime.<p>However, there are some subtle differences in Torque’s <code>constexpr</code> semantics. In C++, <code>constexpr</code> expressions can be evaluated completely by the C++ compiler. In Torque <code>constexpr</code> expressions cannot fully be evaluated by the Torque compiler, but instead map to C++ types, variables and expressions that can be (and must be) fully evaluated when running <code>mksnapshot</code>. From the Torque-writer’s perspective, <code>constexpr</code> expressions do not generate code executed at runtime, so in that sense they are compile-time, even though they are technically evaluated by C++ code external to Torque that <code>mksnapshot</code> runs. So, in Torque, <code>constexpr</code> essentially means “<code>mksnapshot</code>-time”, not “compile time”.<p>In combination with generics, <code>constexpr</code> is a powerful Torque tool that can be used to automate the generation of multiple very efficient specialized builtins that differ from each other in a small number of specific details that can be anticipated by V8 developers in advance.<h2 id=files>Files <a href=#files class=bookmark>#</a></h2><p>Torque code is packaged in individual source files. Each source file consists of a series of declarations, which themselves can optionally wrapped in a namespace declaration to separate the namespaces of declarations. The grammar for a <code>.tq</code> file is as follows:<pre class=language-grammar><code class=language-grammar><span class="token production-name">Declaration</span> <span class="token literal">:</span><br>  <span class="token production-name">AbstractTypeDeclaration</span><br>  <span class="token production-name">ClassDeclaration</span><br>  <span class="token production-name">TypeAliasDeclaration</span><br>  <span class="token production-name">EnumDeclaration</span><br>  <span class="token production-name">CallableDeclaration</span><br>  <span class="token production-name">ConstDeclaration</span><br>  <span class="token production-name">GenericSpecialization</span><br><br><span class="token production-name">NamespaceDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">namespace</span> <span class="token production-name">IdentifierName</span> <span class="token literal">{</span> <span class="token production-name">Declaration</span><span class="token literal">*</span> <span class="token literal">}</span><br><br><span class="token production-name">FileDeclaration</span> <span class="token literal">:</span><br>  <span class="token production-name">NamespaceDeclaration</span><br>  <span class="token production-name">Declaration</span></code></pre><h2 id=namespaces>Namespaces <a href=#namespaces class=bookmark>#</a></h2><p>Torque namespaces allow declarations to be independent namespaces. They are similar to C++ namespaces. They allow you to create declarations that are not automatically visible in other namespaces. They can be nested, and declarations inside a nested namespace can access the declarations in the namespace that contains them without qualification. Declarations that are not explicitly in a namespace declaration are put in a shared global default namespace that is visible to all namespaces. Namespaces can be reopened, allowing them to be defined over multiple files.<p>For example:<pre class=language-torque><code class=language-torque><span class="token keyword">macro</span> IsJSObject<span class="token punctuation">(</span>o<span class="token class-name">: Object)</span><span class="token class-name">: bool {</span> … <span class="token punctuation">}</span>  <span class="token comment">// In default namespace</span><br><br><span class="token keyword">namespace</span> array <span class="token punctuation">{</span><br>  <span class="token keyword">macro</span> IsJSArray<span class="token punctuation">(</span>o<span class="token class-name">: Object)</span><span class="token class-name">: bool {</span> … <span class="token punctuation">}</span>  <span class="token comment">// In array namespace</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">namespace</span> string <span class="token punctuation">{</span><br>  <span class="token comment">// …</span><br>  <span class="token keyword">macro</span> TestVisibility<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    IsJsObject<span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK, global namespace visible here</span><br>    IsJSArray<span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR, not visible in this namespace</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">namespace</span> array <span class="token punctuation">{</span><br>  <span class="token comment">// OK, namespace has been re-opened.</span><br>  <span class="token keyword">macro</span> EnsureWriteableFastElements<span class="token punctuation">(</span>array<span class="token class-name">: JSArray)</span><span class="token punctuation">{</span> … <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id=declarations>Declarations <a href=#declarations class=bookmark>#</a></h2><h3 id=types>Types <a href=#types class=bookmark>#</a></h3><p>Torque is strongly typed. Its type system is the basis for many of the security and correctness guarantees it provides.<p>However, with a few notable exceptions discussed later, Torque doesn’t actually inherently know very much about the core types that are used to write most Torque code. In order to enable better interoperability between Torque and hand-written <code>CodeStubAssembler</code> code, Torque’s type system rigorously specifies the relationship between Torque types, but it is much less rigorous in specifying how the types themselves actually work. Instead, it is loosely coupled with <code>CodeStubAssembler</code> and C++ types through explicit type mappings, and it relies on the C++ compiler to enforce the rigor of that mapping.<p>In Torque, there are three different kinds of types: Abstract, Function and Union.<h4 id=abstract-types>Abstract types <a href=#abstract-types class=bookmark>#</a></h4><p>Torque’s abstract types map directly to C++ compile-time and CodeStubAssembler runtime values. Their declarations specify a name and a relationship to C++ types:<pre class=language-grammar><code class=language-grammar><span class="token production-name">AbstractTypeDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">type</span> <span class="token production-name">IdentifierName</span> <span class="token production-name">ExtendsDeclaration</span> <span class="token keyword">opt</span> <span class="token production-name">GeneratesDeclaration</span> <span class="token keyword">opt</span> <span class="token production-name">ConstexprDeclaration</span> <span class="token keyword">opt</span><br><br><span class="token production-name">ExtendsDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">extends</span> <span class="token production-name">IdentifierName</span> <span class="token literal">;</span><br><br><span class="token production-name">GeneratesDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">generates</span> <span class="token production-name">StringLiteral</span> <span class="token literal">;</span><br><br><span class="token production-name">ConstexprDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">constexpr</span> <span class="token production-name">StringLiteral</span> <span class="token literal">;</span></code></pre><p><code>IdentifierName</code> specifies the name of the abstract type, and <code>ExtendsDeclaration</code> optionally specifies the type from which the declared type derives. <code>GeneratesDeclaration</code> optionally specifies a string literal which corresponds to the C++ <code>TNode</code> type used in <code>CodeStubAssembler</code> code to contain a runtime value of its type. <code>ConstexprDeclaration</code> is a string literal specifying the C++ type corresponding to the <code>constexpr</code> version of the Torque type for build-time (<code>mksnapshot</code>-time) evaluation.<p>Here’s an example from <code>base.tq</code> for Torque’s 31- and 32-bit signed integer types:<pre class=language-torque><code class=language-torque><span class="token keyword">type</span> <span class="token class-name">int32</span> <span class="token keyword">generates</span> <span class="token string">'TNode&lt;Int32T>'</span> <span class="token keyword">constexpr</span> <span class="token string">'int32_t'</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name">int31</span> <span class="token keyword">extends</span> <span class="token class-name">int32</span> <span class="token keyword">generates</span> <span class="token string">'TNode&lt;Int32T>'</span> <span class="token keyword">constexpr</span> <span class="token string">'int31_t'</span><span class="token punctuation">;</span></code></pre><h4 id=union-types>Union types <a href=#union-types class=bookmark>#</a></h4><p>Union types express that a value belongs to one of several possible types. We only allow union types for tagged values, because they can be distinguished at runtime using the map pointer. For example, JavaScript numbers are either Smi values or allocated <code>HeapNumber</code> objects.<pre class=language-torque><code class=language-torque><span class="token keyword">type</span> <span class="token class-name">Number</span> <span class="token operator">=</span> <span class="token class-name">Smi</span> <span class="token operator">|</span> HeapNumber<span class="token punctuation">;</span></code></pre><p>Union types satisfy the following equalities:<ul><li><code>A | B = B | A</code><li><code>A | (B | C) = (A | B) | C</code><li><code>A | B = A</code> if <code>B</code> is a subtype of <code>A</code></ul><p>It is only allowed to form union types from tagged types because untagged types cannot be distinguished at runtime.<p>When mapping union types to CSA, the most specific common supertype of all the types of the union type is selected, with the exception of <code>Number</code> and <code>Numeric</code>, which are mapped to the corresponding CSA union types.<h4 id=class-types>Class types <a href=#class-types class=bookmark>#</a></h4><p>Class types make it possible to define, allocate and manipulate structured objects on the V8 GC heap from Torque code. Each Torque class type must correspond to a subclass of HeapObject in C++ code. In order to minimize the expense of maintaining boilerplate object-accessing code between V8’s C++ and Torque implementation, the Torque class definitions are used to generate the required C++ object-accessing code whenever possible (and appropriate) to reduce the hassle of keeping C++ and Torque synchronized by hand.<pre class=language-grammar><code class=language-grammar><span class="token production-name">ClassDeclaration</span> <span class="token literal">:</span><br>  <span class="token production-name">ClassAnnotation</span><span class="token literal">*</span> <span class="token literal">extern</span> <span class="token keyword">opt</span> <span class="token literal">transient</span> <span class="token keyword">opt</span> <span class="token literal">class</span> <span class="token production-name">IdentifierName</span> <span class="token production-name">ExtendsDeclaration</span> <span class="token keyword">opt</span> <span class="token production-name">GeneratesDeclaration</span> <span class="token keyword">opt</span> <span class="token literal">{</span><br>    <span class="token production-name">ClassMethodDeclaration</span><span class="token literal">*</span><br>    <span class="token production-name">ClassFieldDeclaration</span><span class="token literal">*</span><br>  <span class="token literal">}</span><br><br><span class="token production-name">ClassAnnotation</span> <span class="token literal">:</span><br>  <span class="token literal">@generateCppClass</span><br>  <span class="token literal">@generateBodyDescriptor</span><br>  <span class="token literal">@generatePrint</span><br>  <span class="token literal">@abstract</span><br>  <span class="token literal">@export</span><br>  <span class="token literal">@noVerifier</span><br>  <span class="token literal">@hasSameInstanceTypeAsParent</span><br>  <span class="token literal">@highestInstanceTypeWithinParentClassRange</span><br>  <span class="token literal">@lowestInstanceTypeWithinParentClassRange</span><br>  <span class="token literal">@reserveBitsInInstanceType</span> <span class="token literal">(</span> <span class="token production-name">NumericLiteral</span> <span class="token literal">)</span><br>  <span class="token literal">@apiExposedInstanceTypeValue</span> <span class="token literal">(</span> <span class="token production-name">NumericLiteral</span> <span class="token literal">)</span><br><br><span class="token production-name">ClassMethodDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">transitioning</span> <span class="token keyword">opt</span> <span class="token production-name">IdentifierName</span> <span class="token production-name">ImplicitParameters</span> <span class="token keyword">opt</span> <span class="token production-name">ExplicitParameters</span> <span class="token production-name">ReturnType</span> <span class="token keyword">opt</span> <span class="token production-name">LabelsDeclaration</span> <span class="token keyword">opt</span> <span class="token production-name">StatementBlock</span><br><br><span class="token production-name">ClassFieldDeclaration</span> <span class="token literal">:</span><br>  <span class="token production-name">ClassFieldAnnotation</span><span class="token literal">*</span> <span class="token literal">weak</span> <span class="token keyword">opt</span> <span class="token literal">const</span> <span class="token keyword">opt</span> <span class="token production-name">FieldDeclaration</span><span class="token literal">;</span><br><br><span class="token production-name">ClassFieldAnnotation</span> <span class="token literal">:</span><br>  <span class="token literal">@noVerifier</span><br>  <span class="token literal">@if</span> <span class="token literal">(</span> <span class="token production-name">Identifier</span> <span class="token literal">)</span><br>  <span class="token literal">@ifnot</span> <span class="token literal">(</span> <span class="token production-name">Identifier</span> <span class="token literal">)</span><br><br><span class="token production-name">FieldDeclaration</span> <span class="token literal">:</span><br>  <span class="token production-name">Identifier</span> <span class="token production-name">ArraySpecifier</span> <span class="token keyword">opt</span> <span class="token literal">:</span> <span class="token production-name">Type</span> <span class="token literal">;</span><br><br><span class="token production-name">ArraySpecifier</span> <span class="token literal">:</span><br>  <span class="token literal">[</span> <span class="token production-name">Expression</span> <span class="token literal">]</span></code></pre><p>An example class:<pre class=language-torque><code class=language-torque>@generateCppClass<br><span class="token keyword">extern</span> class JSProxy <span class="token keyword">extends</span> <span class="token class-name">JSReceiver</span> <span class="token punctuation">{</span><br>  target<span class="token punctuation">:</span> JSReceiver<span class="token operator">|</span>Null<span class="token punctuation">;</span><br>  handler<span class="token punctuation">:</span> JSReceiver<span class="token operator">|</span>Null<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p><code>extern</code> signifies that this class is defined in C++, rather than defined only in Torque.<p>The field declarations in classes implicitly generate field getters and setters that can be used from CodeStubAssembler, e.g.:<pre class=language-cpp><code class=language-cpp><span class="token comment">// In TorqueGeneratedExportedMacrosAssembler:</span><br>TNode<span class="token operator">&lt;</span>HeapObject<span class="token operator">></span> <span class="token function">LoadJSProxyTarget</span><span class="token punctuation">(</span>TNode<span class="token operator">&lt;</span>JSProxy<span class="token operator">></span> p_o<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">void</span> <span class="token function">StoreJSProxyTarget</span><span class="token punctuation">(</span>TNode<span class="token operator">&lt;</span>JSProxy<span class="token operator">></span> p_o<span class="token punctuation">,</span> TNode<span class="token operator">&lt;</span>HeapObject<span class="token operator">></span> p_v<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>As described above, the fields defined in Torque classes generate C++ code that removes the need for duplicate boilerplate accessor and heap visitor code. Because the example above uses <code>@generateCppClass</code>, the hand-written definition of JSProxy must inherit from a generated class template, like this:<pre class=language-cpp><code class=language-cpp><span class="token comment">// In js-proxy.h:</span><br><span class="token keyword">class</span> <span class="token class-name">JSProxy</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">TorqueGeneratedJSProxy</span><span class="token operator">&lt;</span><span class="token class-name">JSProxy</span><span class="token punctuation">,</span> <span class="token class-name">JSReceiver</span><span class="token operator">></span></span> <span class="token punctuation">{</span><br><br>  <span class="token comment">// Whatever the class needs beyond Torque-generated stuff goes here...</span><br><br>  <span class="token comment">// At the end, because it messes with public/private:</span><br>  <span class="token function">TQ_OBJECT_CONSTRUCTORS</span><span class="token punctuation">(</span>JSProxy<span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// In js-proxy-inl.h:</span><br><span class="token function">TQ_OBJECT_CONSTRUCTORS_IMPL</span><span class="token punctuation">(</span>JSProxy<span class="token punctuation">)</span></code></pre><p>The generated class provides cast functions, field accessor functions, and field offset constants (e.g. <code>kTargetOffset</code> and <code>kHandlerOffset</code> in this case) representing the byte offset of each field from the beginning of the class.<h5 id=class-type-annotations>Class type annotations <a href=#class-type-annotations class=bookmark>#</a></h5><p><code>@generateCppClass</code> is recommended where possible (as in the example above), but some classes still don't use it. In those cases, the class should instead include a Torque-generated macro for its field offset constants, and must implement its own accessors and cast functions. Using that macro looks like this:<pre class=language-cpp><code class=language-cpp><span class="token keyword">class</span> <span class="token class-name">JSProxy</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">JSReceiver</span></span> <span class="token punctuation">{</span><br> <span class="token keyword">public</span><span class="token operator">:</span><br>  <span class="token function">DEFINE_FIELD_OFFSET_CONSTANTS</span><span class="token punctuation">(</span><br>      JSReceiver<span class="token operator">::</span>kHeaderSize<span class="token punctuation">,</span> TORQUE_GENERATED_JS_PROXY_FIELDS<span class="token punctuation">)</span><br>  <span class="token comment">// Rest of class omitted...</span><br><span class="token punctuation">}</span></code></pre><p><code>@generateBodyDescriptor</code> causes Torque to emit a class <code>BodyDescriptor</code> within the generated class, which represents how the garbage collector should visit the object. Otherwise the C++ code must either define its own object visitation, or use one of the existing patterns (for example, inheriting from <code>Struct</code> and including the class in <code>STRUCT_LIST</code> means that the class is expected to contain only tagged values).<p>If the <code>@generatePrint</code> annotation is added, then the generator will implement a C++ function that prints the field values as defined by the Torque layout. Using the JSProxy example, the signature would be <code>void TorqueGeneratedJSProxy&lt;JSProxy, JSReceiver>::JSProxyPrint(std::ostream& os)</code>, which can be inherited by <code>JSProxy</code>.<p>The Torque compiler also generates verification code for all <code>extern</code> classes, unless the class opts out with the <code>@noVerifier</code> annotation. For example, the JSProxy class definition above will generate a C++ method <code>void TorqueGeneratedClassVerifiers::JSProxyVerify(JSProxy o, Isolate* isolate)</code> which verifies that its fields are valid according to the Torque type definition. It will also generate a corresponding function on the generated class, <code>TorqueGeneratedJSProxy&lt;JSProxy, JSReceiver>::JSProxyVerify</code>, which calls the static function from <code>TorqueGeneratedClassVerifiers</code>. If you want to add extra verification for a class (such as a range of acceptable values on a number, or a requirement that field <code>foo</code> is true if field <code>bar</code> is non-null, etc.), then add a <code>DECL_VERIFIER(JSProxy)</code> to the C++ class (which hides the inherited <code>JSProxyVerify</code>) and implement it in <code>src/objects-debug.cc</code>. The first step of any such custom verifier should be to call the generated verifier, such as <code>TorqueGeneratedClassVerifiers::JSProxyVerify(*this, isolate);</code>. (To run those verifiers before and after every GC, build with <code>v8_enable_verify_heap = true</code> and run with <code>--verify-heap</code>.)<p><code>@abstract</code> indicates that the class itself is not instantiated, and does not have its own instance type: the instance types that logically belong to the class are the instance types of the derived classes.<p>The <code>@export</code> annotation causes the Torque compiler to generate a concrete C++ class (such as <code>JSProxy</code> in the example above). This is obviously only useful if you don't want to add any C++ functionality beyond that provided by the Torque-generated code. Cannot be used in conjunction with <code>extern</code>. For a class that is defined and used only within Torque, it is most appropriate to use neither <code>extern</code> nor <code>@export</code>.<p><code>@hasSameInstanceTypeAsParent</code> indicates classes that have the same instance types as their parent class, but rename some fields, or possibly have a different map. In such cases, the parent class is not abstract.<p>The annotations <code>@highestInstanceTypeWithinParentClassRange</code>, <code>@lowestInstanceTypeWithinParentClassRange</code>, <code>@reserveBitsInInstanceType</code>, and <code>@apiExposedInstanceTypeValue</code> all affect generation of instance types. Generally you can ignore these and be okay. Torque is responsible for assigning a unique value in the enum <code>v8::internal::InstanceType</code> for every class so that V8 can determine at runtime the type any object in the JS heap. Torque's assignment of instance types should be adequate in the vast majority of cases, but there are a few cases where we want an instance type for a particular class to be stable across builds, or to be at the beginning or end of the range of instance types assigned to its superclass, or to be a range of reserved values that can be defined outside of Torque.<h5 id=class-fields>Class fields <a href=#class-fields class=bookmark>#</a></h5><p>As well as plain values, as in the example above, class fields may contain indexed data. Here's an example:<pre class=language-torque><code class=language-torque><span class="token keyword">extern</span> class CoverageInfo <span class="token keyword">extends</span> <span class="token class-name">HeapObject</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> slot_count<span class="token class-name">: int32;</span><br>  slots<span class="token punctuation">[</span>slot_count<span class="token punctuation">]</span><span class="token class-name">: CoverageInfoSlot;</span><br><span class="token punctuation">}</span></code></pre><p>This means that instances of <code>CoverageInfo</code> are of varying sizes based on the data in <code>slot_count</code>.<p>Unlike C++, Torque will not implicitly add padding between fields; instead, it will fail and emit an error if fields are not properly aligned. Torque also requires that strong fields, weak fields, and scalar fields be together with other fields of the same category in the field order.<p><code>const</code> means that a field cannot be altered at runtime (or at least not easily; Torque will fail compilation if you attempt to set it). This is a good idea for length fields, which should only be reset with great care because they would require freeing any released space and might cause data races with a marking thread.<p><code>weak</code> at the beginning of a field declaration means that the field should be grouped with other <code>weak</code> fields, and affects the generation of constants such as <code>kEndOfStrongFieldsOffset</code> and <code>kStartOfWeakFieldsOffset</code> which can be used in custom <code>BodyDescriptor</code>s. We hope to remove this keyword once Torque is fully capable of generating all <code>BodyDescriptor</code>s. If the object stored in a field may be a weak reference (with the second bit set), then <code>Weak&lt;T></code> should be used in the type. As an example, this field from <code>Map</code> can contain some strong and some weak types, and is also marked for inclusion in the <code>weak</code> section:<pre class=language-torque><code class=language-torque>  weak transitions_or_prototype_info<span class="token punctuation">:</span> Map<span class="token operator">|</span>Weak<span class="token operator">&lt;</span>Map<span class="token operator">></span><span class="token operator">|</span>TransitionArray<span class="token operator">|</span><br>      PrototypeInfo<span class="token operator">|</span>Smi<span class="token punctuation">;</span></code></pre><p><code>@if</code> and <code>@ifnot</code> mark fields that should be included in some build configurations but not others. They accept values from the list in <code>BuildFlags</code>, in <code>src/torque/torque-parser.cc</code>.<h5 id=classes-defined-entirely-outside-torque>Classes defined entirely outside Torque <a href=#classes-defined-entirely-outside-torque class=bookmark>#</a></h5><p>Some classes are not defined in Torque, but Torque must know about every class because it is responsible for assigning instance types. For this case, classes can be declared with no body, and Torque will generate nothing for them except the instance type. Example:<pre class=language-torque><code class=language-torque><span class="token keyword">extern</span> class OrderedHashMap <span class="token keyword">extends</span> <span class="token class-name">HashTable</span><span class="token punctuation">;</span></code></pre><h4 id=shapes>Shapes <a href=#shapes class=bookmark>#</a></h4><p>Defining a <code>shape</code> looks just like defining a <code>class</code> except that it uses the keyword <code>shape</code> instead of <code>class</code>. A <code>shape</code> is a subtype of <code>JSObject</code> representing a point-in-time arrangement of in-object properties (in spec-ese, these are "data properties" rather than "internal slots"). A <code>shape</code> does not have its own instance type. An object with a particular shape may change and lose that shape at any time because the object might go into dictionary mode and move all of its properties out to a separate backing store.<h4 id=structs>Structs <a href=#structs class=bookmark>#</a></h4><p><code>struct</code>s are collections of data that can easily be passed around together. (Completely unrelated to the class named <code>Struct</code>.) Like classes, they can include macros that operate on the data. Unlike classes, they also support generics. The syntax looks similar to a class:<pre class=language-torque><code class=language-torque>@export<br>struct PromiseResolvingFunctions <span class="token punctuation">{</span><br>  resolve<span class="token class-name">: JSFunction;</span><br>  reject<span class="token class-name">: JSFunction;</span><br><span class="token punctuation">}</span><br><br>struct ConstantIterator<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token keyword">type</span><span class="token operator">></span> <span class="token punctuation">{</span><br>  <span class="token keyword">macro</span> Empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">: bool {</span><br>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">macro</span> Next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">: T <span class="token keyword">labels</span></span> _NoMore <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> this<span class="token punctuation">.</span>value<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  value<span class="token class-name">: T;</span><br><span class="token punctuation">}</span></code></pre><h5 id=struct-annotations>Struct annotations <a href=#struct-annotations class=bookmark>#</a></h5><p>Any struct marked as <code>@export</code> will be included with a predictable name in the generated file <code>gen/torque-generated/csa-types-tq.h</code>. The name is prepended with <code>TorqueStruct</code>, so <code>PromiseResolvingFunctions</code> becomes <code>TorqueStructPromiseResolvingFunctions</code>.<p>Struct fields can be marked as <code>const</code>, which means they shouldn't be written to. The entire struct can still be overwritten.<h5 id=structs-as-class-fields>Structs as class fields <a href=#structs-as-class-fields class=bookmark>#</a></h5><p>A struct may be used as the type of a class field. In that case, it represents packed, ordered data within the class (otherwise, structs have no alignment requirements). This is particularly useful for indexed fields in classes. As an example, <code>DescriptorArray</code> contains an array of three-value structs:<pre class=language-torque><code class=language-torque>struct DescriptorEntry <span class="token punctuation">{</span><br>  key<span class="token punctuation">:</span> Name<span class="token operator">|</span>Undefined<span class="token punctuation">;</span><br>  details<span class="token punctuation">:</span> Smi<span class="token operator">|</span>Undefined<span class="token punctuation">;</span><br>  value<span class="token punctuation">:</span> JSAny<span class="token operator">|</span>Weak<span class="token operator">&lt;</span>Map<span class="token operator">></span><span class="token operator">|</span>AccessorInfo<span class="token operator">|</span>AccessorPair<span class="token operator">|</span>ClassPositions<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">extern</span> class DescriptorArray <span class="token keyword">extends</span> <span class="token class-name">HeapObject</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> number_of_all_descriptors<span class="token class-name">: uint16;</span><br>  number_of_descriptors<span class="token class-name">: uint16;</span><br>  raw_number_of_marked_descriptors<span class="token class-name">: uint16;</span><br>  filler16_bits<span class="token class-name">: uint16;</span><br>  enum_cache<span class="token class-name">: EnumCache;</span><br>  descriptors<span class="token punctuation">[</span>number_of_all_descriptors<span class="token punctuation">]</span><span class="token class-name">: DescriptorEntry;</span><br><span class="token punctuation">}</span></code></pre><h5 id=references-and-slices>References and Slices <a href=#references-and-slices class=bookmark>#</a></h5><p><code>Reference&lt;T></code> and <code>Slice&lt;T></code> are special structs representing pointers to data held within heap objects. They both contain an object and an offset; <code>Slice&lt;T></code> also contains a length. Rather than constructing these structs directly, you can use special syntax: <code>&o.x</code> will create a <code>Reference</code> to the field <code>x</code> within the object <code>o</code>, or a <code>Slice</code> to the data if <code>x</code> is an indexed field. <code>Reference&lt;T></code> can be dereferenced with <code>*</code> or <code>-></code>, consistent with C++.<p><code>Reference&lt;T></code> should not used directly. Instead, it has two subtypes <code>MutableReference&lt;T></code> and <code>ConstReference&lt;T></code>, which can be referred to using syntactic sugar: <code>&T</code> and <code>const &T</code>.<h4 id=bitfield-structs>Bitfield structs <a href=#bitfield-structs class=bookmark>#</a></h4><p>A <code>bitfield struct</code> represents a collection of numeric data that is packed into a single numeric value. Its syntax looks similar to a normal <code>struct</code>, with the addition of the number of bits for each field.<pre class=language-torque><code class=language-torque>bitfield struct DebuggerHints <span class="token keyword">extends</span> <span class="token class-name">uint31</span> <span class="token punctuation">{</span><br>  side_effect_state<span class="token punctuation">:</span> int32<span class="token punctuation">:</span> <span class="token number">2</span> bit<span class="token punctuation">;</span><br>  debug_is_blackboxed<span class="token punctuation">:</span> bool<span class="token punctuation">:</span> <span class="token number">1</span> bit<span class="token punctuation">;</span><br>  computed_debug_is_blackboxed<span class="token punctuation">:</span> bool<span class="token punctuation">:</span> <span class="token number">1</span> bit<span class="token punctuation">;</span><br>  debugging_id<span class="token punctuation">:</span> int32<span class="token punctuation">:</span> <span class="token number">20</span> bit<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>If a bitfield struct (or any other numeric data) is stored within a Smi, it can be represented using the type <code>SmiTagged&lt;T></code>.<h4 id=function-pointer-types>Function pointer types <a href=#function-pointer-types class=bookmark>#</a></h4><p>Function pointers can only point to builtins defined in Torque, since this guarantees the default ABI. They are especially useful to reduce binary code size.<p>While function pointer types are anonymous (like in C), they can be bound to a type alias (like a <code>typedef</code> in C).<pre class=language-torque><code class=language-torque><span class="token keyword">type</span> <span class="token class-name">CompareBuiltinFn</span> <span class="token operator">=</span> <span class="token class-name">builtin</span><span class="token punctuation">(</span><span class="token keyword">implicit</span> context<span class="token class-name">: Context)</span><span class="token punctuation">(</span>Object<span class="token punctuation">,</span> Object<span class="token punctuation">,</span> Object<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Number<span class="token punctuation">;</span></code></pre><h4 id=special-types>Special types <a href=#special-types class=bookmark>#</a></h4><p>There are two special types indicated by the keywords <code>void</code> and <code>never</code>. <code>void</code> is used as the return type for callables that do not return a value, and <code>never</code> is used as the return type for callables that never actually return (i.e. only exit through exceptional paths).<h4 id=transient-types>Transient types <a href=#transient-types class=bookmark>#</a></h4><p>In V8, heap objects can change layout at runtime. To express object layouts that are subject to change or other temporary assumptions in the type system, Torque supports the concept of a “transient type”. When declaring an abstract type, adding the keyword <code>transient</code> marks it as a transient type.<pre class=language-torque><code class=language-torque><span class="token comment">// A HeapObject with a JSArray map, and either fast packed elements, or fast</span><br><span class="token comment">// holey elements when the global NoElementsProtector is not invalidated.</span><br>transient <span class="token keyword">type</span> <span class="token class-name">FastJSArray</span> <span class="token keyword">extends</span> <span class="token class-name">JSArray</span><br>    <span class="token keyword">generates</span> <span class="token string">'TNode&lt;JSArray>'</span><span class="token punctuation">;</span></code></pre><p>For example, in the case of <code>FastJSArray</code>, the transient type is invalidated if the array changes to dictionary elements or if the global <code>NoElementsProtector</code> is invalidated. To express this in Torque, annotate all callables that could potentially do that as <code>transitioning</code>. For example, calling a JavaScript function can execute arbitrary JavaScript, so it is <code>transitioning</code>.<pre class=language-torque><code class=language-torque><span class="token keyword">extern</span> transitioning <span class="token keyword">macro</span> Call<span class="token punctuation">(</span><span class="token keyword">implicit</span> context<span class="token class-name">: Context)</span><br>                               <span class="token punctuation">(</span>Callable<span class="token punctuation">,</span> Object<span class="token punctuation">)</span><span class="token class-name">: Object;</span></code></pre><p>The way this is policed in the type system is that it is illegal to access a value of a transient type across a transitioning operation.<pre class=language-torque><code class=language-torque><span class="token keyword">const</span> fastArray <span class="token class-name">: FastJSArray =</span> <span class="token builtin">Cast</span><span class="token operator">&lt;</span>FastJSArray<span class="token operator">></span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token keyword">otherwise</span> Bailout<span class="token punctuation">;</span><br>Call<span class="token punctuation">(</span>f<span class="token punctuation">,</span> Undefined<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> fastArray<span class="token punctuation">;</span> <span class="token comment">// Type error: fastArray is invalid here.</span></code></pre><h4 id=enums>Enums <a href=#enums class=bookmark>#</a></h4><p>Enumerations provide a means to define a set of constants and group them under a name similar to<br>the enum classes in C++. A declaration is introduced by the <code>enum</code> keyword and adheres to the following<br>syntactical structure:<pre class=language-grammar><code class=language-grammar><span class="token production-name">EnumDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">extern</span> <span class="token literal">enum</span> <span class="token production-name">IdentifierName</span> <span class="token production-name">ExtendsDeclaration</span> <span class="token keyword">opt</span> <span class="token production-name">ConstexprDeclaration</span> <span class="token keyword">opt</span> <span class="token literal">{</span> <span class="token production-name">IdentifierName</span> <span class="token keyword">list+</span> <span class="token literal">(,</span> <span class="token literal">...)</span> <span class="token keyword">opt</span> <span class="token literal">}</span></code></pre><p>A basic example looks like this:<pre class=language-torque><code class=language-torque><span class="token keyword">extern</span> enum LanguageMode <span class="token keyword">extends</span> <span class="token class-name">Smi</span> <span class="token punctuation">{</span><br>  kStrict<span class="token punctuation">,</span><br>  kSloppy<br><span class="token punctuation">}</span></code></pre><p>This declaration defines a new type <code>LanguageMode</code>, where the <code>extends</code> clause specifies the underlying<br>type, that is the runtime type used to represent a value of the enum. In this example, this is <code>TNode&lt;Smi></code>,<br>since this is what the type <code>Smi</code> <code>generates</code>. A <code>constexpr LanguageMode</code> converts to <code>LanguageMode</code><br>in the generated CSA files since no <code>constexpr</code> clause is specified on the enum to replace the default name.<br>If the <code>extends</code> clause is omitted, Torque will generate only the <code>constexpr</code> version of the type. The <code>extern</code> keyword tells Torque that there is a C++ definition of this enum. Currently, only <code>extern</code> enums are supported.<p>Torque generates a distinct type and constant for each of the enum's entries. Those are defined<br>inside a namespace that matches the enum's name. Necessary specializations of <code>FromConstexpr&lt;></code> are<br>generated to convert from the entry's <code>constexpr</code> types to the enum type. The value generated for an entry in the C++ files is <code>&lt;enum-constexpr>::&lt;entry-name></code> where <code>&lt;enum-constexpr></code> is the <code>constexpr</code> name generated for the enum. In the above example, those are <code>LanguageMode::kStrict</code> and <code>LanguageMode::kSloppy</code>.<p>Torque's enumerations work very well together with the <code>typeswitch</code> construct, because the<br>values are defined using distinct types:<pre class=language-torque><code class=language-torque><span class="token keyword">typeswitch</span><span class="token punctuation">(</span>language_mode<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">case</span> <span class="token punctuation">(</span>LanguageMode<span class="token punctuation">:</span><span class="token punctuation">:</span>kStrict<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><br>    <span class="token comment">// ...</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">case</span> <span class="token punctuation">(</span>LanguageMode<span class="token punctuation">:</span><span class="token punctuation">:</span>kSloppy<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><br>    <span class="token comment">// ...</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>If the C++ definition of the enum contains more values than those used in <code>.tq</code> files, Torque needs to know that. This is done by declaring the enum 'open' by appending a <code>...</code> after the last entry. Consider the <code>ExtractFixedArrayFlag</code> for example, where only some of the options are available/used from within<br>Torque:<pre class=language-torque><code class=language-torque>enum ExtractFixedArrayFlag <span class="token keyword">constexpr</span> <span class="token string">'CodeStubAssembler::ExtractFixedArrayFlag'</span> <span class="token punctuation">{</span><br>  kFixedDoubleArrays<span class="token punctuation">,</span><br>  kAllFixedArrays<span class="token punctuation">,</span><br>  kFixedArrays<span class="token punctuation">,</span><br>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><br><span class="token punctuation">}</span></code></pre><h3 id=callables>Callables <a href=#callables class=bookmark>#</a></h3><p>Callables are conceptually like functions in JavaScript or C++, but they have some additional semantics that allow them to interact in useful ways with CSA code and with the V8 runtime. Torque provides several different types of callables: <code>macro</code>s, <code>builtin</code>s, <code>runtime</code>s and <code>intrinsic</code>s.<pre class=language-grammar><code class=language-grammar><span class="token production-name">CallableDeclaration</span> <span class="token literal">:</span><br>  <span class="token production-name">MacroDeclaration</span><br>  <span class="token production-name">BuiltinDeclaration</span><br>  <span class="token production-name">RuntimeDeclaration</span><br>  <span class="token production-name">IntrinsicDeclaration</span></code></pre><h4 id=macro-callables><code>macro</code> callables <a href=#macro-callables class=bookmark>#</a></h4><p>Macros are a callable that correspond to a chunk of generated CSA-producing C++. <code>macro</code>s can either be fully defined in Torque, in which case the CSA code is generated by Torque, or marked <code>extern</code>, in which case the implementation must be provided as hand-written CSA code in a CodeStubAssembler class. Conceptually, it’s useful to think of <code>macro</code>s of chunks of inlinable CSA code that are inlined at callsites.<p><code>macro</code> declarations in Torque take the following form:<pre class=language-grammar><code class=language-grammar><span class="token production-name">MacroDeclaration</span> <span class="token literal">:</span><br>   <span class="token literal">transitioning</span> <span class="token keyword">opt</span> <span class="token literal">macro</span> <span class="token production-name">IdentifierName</span> <span class="token production-name">ImplicitParameters</span> <span class="token keyword">opt</span> <span class="token production-name">ExplicitParameters</span> <span class="token production-name">ReturnType</span> <span class="token keyword">opt</span> <span class="token production-name">LabelsDeclaration</span> <span class="token keyword">opt</span> <span class="token production-name">StatementBlock</span><br>  <span class="token literal">extern</span> <span class="token literal">transitioning</span> <span class="token keyword">opt</span> <span class="token literal">macro</span> <span class="token production-name">IdentifierName</span> <span class="token production-name">ImplicitParameters</span> <span class="token keyword">opt</span> <span class="token production-name">ExplicitTypes</span> <span class="token production-name">ReturnType</span> <span class="token keyword">opt</span> <span class="token production-name">LabelsDeclaration</span> <span class="token keyword">opt</span> <span class="token literal">;</span></code></pre><p>Every non-<code>extern</code> Torque <code>macro</code> uses the <code>StatementBlock</code> body of the <code>macro</code> to create a CSA-generating function in its namespace’s generated <code>Assembler</code> class. This code looks just like other code that you might find in <code>code-stub-assembler.cc</code>, albeit a bit less readable because it’s machine-generated. <code>macro</code>s that are marked <code>extern</code> have no body written in Torque and simply provide the interface to hand-written C++ CSA code so that it’s usable from Torque.<p><code>macro</code> definitions specify implicit and explict parameters, an optional return type and optional labels. Parameters and return types will be discussed in more detail below, but for now it suffices to know that they work somewhat like TypeScript parameters, which as discussed in the Function Types section of the TypeScript documentation <a href=https://www.typescriptlang.org/docs/handbook/functions.html>here</a>.<p>Labels are a mechanism for exceptional exit from a <code>macro</code>. They map 1:1 to CSA labels and are added as <code>CodeStubAssemblerLabels*</code>-typed parameters to the C++ method generated for the <code>macro</code>. Their exact semantics are discussed below, but for the purpose of a <code>macro</code> declartion, the comma-separated list of a <code>macro</code>’s labels is optionally provided with the <code>labels</code> keywords and positioned after the <code>macro</code>’s parameter lists and return type.<p>Here’s an example from <code>base.tq</code> of external and Torque-defined <code>macro</code>s:<pre class=language-torque><code class=language-torque><span class="token keyword">extern</span> <span class="token keyword">macro</span> BranchIfFastJSArrayForCopy<span class="token punctuation">(</span>Object<span class="token punctuation">,</span> Context<span class="token punctuation">)</span><span class="token class-name">: never<br>    <span class="token keyword">labels</span></span> Taken<span class="token punctuation">,</span> NotTaken<span class="token punctuation">;</span><br><span class="token keyword">macro</span> BranchIfNotFastJSArrayForCopy<span class="token punctuation">(</span><span class="token keyword">implicit</span> context<span class="token class-name">: Context)</span><span class="token punctuation">(</span>o<span class="token class-name">: Object)</span><span class="token class-name">:<br>    never<br>    <span class="token keyword">labels</span></span> Taken<span class="token punctuation">,</span> NotTaken <span class="token punctuation">{</span><br>  BranchIfFastJSArrayForCopy<span class="token punctuation">(</span>o<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token keyword">otherwise</span> NotTaken<span class="token punctuation">,</span> Taken<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h4 id=builtin-callables><code>builtin</code> callables <a href=#builtin-callables class=bookmark>#</a></h4><p><code>builtin</code>s are similar to <code>macro</code>s in that they can either be fully defined in Torque or marked <code>extern</code>. In the Torque-based builtin case, the body for the builtin is used to generate a V8 builtin that can be called just like any other V8 builtin, including automatically adding the relevant information in <code>builtin-definitions.h</code>. Like <code>macro</code>s, Torque <code>builtin</code>s that are marked <code>extern</code> have no Torque-based body and simply provide an interface to existing V8 <code>builtin</code>s so that they can be used from Torque code.<p><code>builtin</code> declarations in Torque have the following form:<pre class=language-grammar><code class=language-grammar><span class="token production-name">MacroDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">transitioning</span> <span class="token keyword">opt</span> <span class="token literal">javascript</span> <span class="token keyword">opt</span> <span class="token literal">builtin</span> <span class="token production-name">IdentifierName</span> <span class="token production-name">ImplicitParameters</span> <span class="token keyword">opt</span> <span class="token production-name">ExplicitParametersOrVarArgs</span> <span class="token production-name">ReturnType</span> <span class="token keyword">opt</span> <span class="token production-name">StatementBlock</span><br>  <span class="token literal">extern</span> <span class="token literal">transitioning</span> <span class="token keyword">opt</span> <span class="token literal">javascript</span> <span class="token keyword">opt</span> <span class="token literal">builtin</span> <span class="token production-name">IdentifierName</span> <span class="token production-name">ImplicitParameters</span> <span class="token keyword">opt</span> <span class="token production-name">ExplicitTypesOrVarArgs</span> <span class="token production-name">ReturnType</span> <span class="token keyword">opt</span> <span class="token literal">;</span></code></pre><p>There is only one copy of the code for a Torque builtin, and that is in the generated builtin code object. Unlike <code>macro</code>s, when <code>builtin</code>s are called from Torque code, the CSA code is not inlined at the callsite, but instead a call is generated to the builtin.<p><code>builtin</code>s cannot have labels.<p>If you are coding the implementation of a <code>builtin</code>, you can craft a <a href=https://en.wikipedia.org/wiki/Tail_call>tailcall</a> to a builtin or a runtime function iff (if and only if) it's the final call in the builtin. The compiler may be able to avoid creating a new stack frame in this case. Simply add <code>tail</code> before the call, as in <code>tail MyBuiltin(foo, bar);</code>.<h4 id=runtime-callables><code>runtime</code> callables <a href=#runtime-callables class=bookmark>#</a></h4><p><code>runtime</code>s are similar to <code>builtin</code>s in that they can expose an interface to external functionality to Torque. However, instead of being implemented in CSA, the functionality provided by a <code>runtime</code> must always be implemented in the V8 as a standard runtime callback.<p><code>runtime</code> declarations in Torque have the following form:<pre class=language-grammar><code class=language-grammar><span class="token production-name">MacroDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">extern</span> <span class="token literal">transitioning</span> <span class="token keyword">opt</span> <span class="token literal">runtime</span> <span class="token production-name">IdentifierName</span> <span class="token production-name">ImplicitParameters</span> <span class="token keyword">opt</span> <span class="token production-name">ExplicitTypesOrVarArgs</span> <span class="token production-name">ReturnType</span> <span class="token keyword">opt</span> <span class="token literal">;</span></code></pre><p>The <code>extern runtime</code> specified with name <i>IdentifierName</i> corresponds to the runtime function specified by <code>Runtime::k<i>IdentifierName</i></code>.<p>Like <code>builtin</code>s, <code>runtime</code>s cannot have labels.<p>You can also call a <code>runtime</code> function as a tailcall when appropriate. Simply include the <code>tail</code> keyword before the call.<h4 id=intrinsic-callables><code>intrinsic</code> callables <a href=#intrinsic-callables class=bookmark>#</a></h4><p><code>intrinsic</code>s are builtin Torque callables that provide access to internal funtionality that can’t be otherwise implemented in Torque. They are declared in Torque, but not defined, since the implementation is provided by the Torque compiler. <code>intrinsic</code> declarations use the following grammar:<pre class=language-grammar><code class=language-grammar><span class="token production-name">IntrinsicDeclaration</span> <span class="token literal">:</span><br>  <span class="token literal">intrinsic</span> <span class="token literal">%</span> <span class="token production-name">IdentifierName</span> <span class="token production-name">ImplicitParameters</span> <span class="token keyword">opt</span> <span class="token production-name">ExplicitParameters</span> <span class="token production-name">ReturnType</span> <span class="token keyword">opt</span> <span class="token literal">;</span></code></pre><p>For the most part, “user” Torque code should rarely have to use <code>intrinsic</code>s directly. The currently supported intrinsics are:<pre class=language-torque><code class=language-torque><span class="token comment">// %RawObjectCast downcasts from Object to a subtype of Object without</span><br><span class="token comment">// rigorous testing if the object is actually the destination type.</span><br><span class="token comment">// RawObjectCasts should *never* (well, almost never) be used anywhere in</span><br><span class="token comment">// Torque code except for in Torque-based UnsafeCast operators preceeded by an</span><br><span class="token comment">// appropriate type assert()</span><br>intrinsic <span class="token operator">%</span>RawObjectCast<span class="token operator">&lt;</span>A<span class="token punctuation">:</span> <span class="token keyword">type</span><span class="token operator">></span><span class="token punctuation">(</span>o<span class="token class-name">: Object)</span><span class="token class-name">: A;</span><br><br><span class="token comment">// %RawPointerCast downcasts from RawPtr to a subtype of RawPtr without</span><br><span class="token comment">// rigorous testing if the object is actually the destination type.</span><br>intrinsic <span class="token operator">%</span>RawPointerCast<span class="token operator">&lt;</span>A<span class="token punctuation">:</span> <span class="token keyword">type</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token class-name">: RawPtr)</span><span class="token class-name">: A;</span><br><br><span class="token comment">// %RawConstexprCast converts one compile-time constant value to another.</span><br><span class="token comment">// Both the source and destination types should be 'constexpr'.</span><br><span class="token comment">// %RawConstexprCast translate to static_casts in the generated C++ code.</span><br>intrinsic <span class="token operator">%</span>RawConstexprCast<span class="token operator">&lt;</span>To<span class="token class-name">: type,</span> From<span class="token punctuation">:</span> <span class="token keyword">type</span><span class="token operator">></span><span class="token punctuation">(</span>f<span class="token class-name">: From)</span><span class="token class-name">: To;</span><br><br><span class="token comment">// %FromConstexpr converts a constexpr value into into a non-constexpr</span><br><span class="token comment">// value. Currently, only conversion to the following non-constexpr types</span><br><span class="token comment">// are supported: Smi, Number, String, uintptr, intptr, and int32</span><br>intrinsic <span class="token operator">%</span>FromConstexpr<span class="token operator">&lt;</span>To<span class="token class-name">: type,</span> From<span class="token punctuation">:</span> <span class="token keyword">type</span><span class="token operator">></span><span class="token punctuation">(</span>b<span class="token class-name">: From)</span><span class="token class-name">: To;</span><br><br><span class="token comment">// %Allocate allocates an unitialized object of size 'size' from V8's</span><br><span class="token comment">// GC heap and "reinterpret casts" the resulting object pointer to the</span><br><span class="token comment">// specified Torque class, allowing constructors to subsequently use</span><br><span class="token comment">// standard field access operators to initialize the object.</span><br><span class="token comment">// This intrinsic should never be called from Torque code. It's used</span><br><span class="token comment">// internally when desugaring the 'new' operator.</span><br>intrinsic <span class="token operator">%</span>Allocate<span class="token operator">&lt;</span>Class<span class="token punctuation">:</span> <span class="token keyword">type</span><span class="token operator">></span><span class="token punctuation">(</span>size<span class="token class-name">: intptr)</span><span class="token class-name">: Class;</span></code></pre><p>Like <code>builtin</code>s and <code>runtime</code>s, <code>intrinsic</code>s cannot have labels.<h3 id=explicit-parameters>Explicit parameters <a href=#explicit-parameters class=bookmark>#</a></h3><p>Declarations of Torque-defined Callables, e.g. Torque <code>macro</code>s and <code>builtin</code>s, have explicit parameter lists. They are a list of identifier and type pairs using a syntax reminiscent of typed TypeScript function parameter lists, with the exception that Torque doesn’t support optional parameters or default parameters. Moreover, Torque-implement <code>builtin</code>s can optionally support rest parameters if the builtin uses V8’s internal JavaScript calling convention (e.g. is marked with the <code>javascript</code> keyword).<pre class=language-grammar><code class=language-grammar><span class="token production-name">ExplicitParameters</span> <span class="token literal">:</span><br>  <span class="token literal">(</span> <span class="token literal">(</span> <span class="token production-name">IdentifierName</span> <span class="token literal">:</span> <span class="token production-name">TypeIdentifierName</span> <span class="token literal">)</span> <span class="token keyword">list*</span> <span class="token literal">)</span><br>  <span class="token literal">(</span> <span class="token literal">(</span> <span class="token production-name">IdentifierName</span> <span class="token literal">:</span> <span class="token production-name">TypeIdentifierName</span> <span class="token literal">)</span> <span class="token keyword">list+</span> <span class="token literal">(,</span> <span class="token literal">...</span> <span class="token production-name">IdentifierName</span> <span class="token literal">)</span> <span class="token keyword">opt</span> <span class="token literal">)</span></code></pre><p>As an example:<pre class=language-torque><code class=language-torque><span class="token keyword">javascript</span> <span class="token keyword">builtin</span> ArraySlice<span class="token punctuation">(</span><br>    <span class="token punctuation">(</span><span class="token keyword">implicit</span> context<span class="token class-name">: Context)</span><span class="token punctuation">(</span>receiver<span class="token class-name">: Object,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>arguments<span class="token punctuation">)</span><span class="token class-name">: Object {</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre><h3 id=implicit-parameters>Implicit parameters <a href=#implicit-parameters class=bookmark>#</a></h3><p>Torque callables can specify implicit parameters using something similar to <a href=https://docs.scala-lang.org/tour/implicit-parameters.html>Scala’s implicit parameters</a>:<pre class=language-grammar><code class=language-grammar><span class="token production-name">ImplicitParameters</span> <span class="token literal">:</span><br>  <span class="token literal">(</span> <span class="token literal">implicit</span> <span class="token literal">(</span> <span class="token production-name">IdentifierName</span> <span class="token literal">:</span> <span class="token production-name">TypeIdentifierName</span> <span class="token literal">)</span> <span class="token keyword">list*</span> <span class="token literal">)</span></code></pre><p>Concretely: A <code>macro</code> can declare implicit parameters in addition to explicit ones:<pre class=language-torque><code class=language-torque><span class="token keyword">macro</span> Foo<span class="token punctuation">(</span><span class="token keyword">implicit</span> context<span class="token class-name">: Context)</span><span class="token punctuation">(</span>x<span class="token class-name">: Smi,</span> y<span class="token class-name">: Smi)</span></code></pre><p>When mapping to CSA, implicit parameters and explicit parameters are treated the same and form a joint parameter list.<p>Implicit parameters are not mentioned at the callsite, but instead are passed implicitly: <code>Foo(4, 5)</code>. For this to work, <code>Foo(4, 5)</code> must be called in a context that provides a value named <code>context</code>. Example:<pre class=language-torque><code class=language-torque><span class="token keyword">macro</span> Bar<span class="token punctuation">(</span><span class="token keyword">implicit</span> context<span class="token class-name">: Context)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  Foo<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>In contrast to Scala, we forbid this if the names of the implicit parameters are not identical.<p>Since overload resolution can cause confusing behavior, we ensure that implicit parameters do not influence overload resolution at all. That is: when comparing candidates of an overload set, we do not consider the available implicit bindings at the call-site. Only after we found a single best overload, we check if implicit bindings for the implicit parameters are available.<p>Having the implicit parameters left of the explicit parameters is different from Scala, but maps better to the existing convention in CSA to have the <code>context</code> parameter first.<h4 id=js-implicit><code>js-implicit</code> <a href=#js-implicit class=bookmark>#</a></h4><p>For builtins with JavaScript linkage defined in Torque, you should use the keyword <code>js-implicit</code> instead of <code>implicit</code>. The arguments are limited to these four components of the calling convention:<ul><li>context: <code>NativeContext</code><li>receiver: <code>JSAny</code> (<code>this</code> in JavaScript)<li>target: <code>JSFunction</code> (<code>arguments.callee</code> in JavaScript)<li>newTarget: <code>JSAny</code> (<code>new.target</code> in JavaScript)</ul><p>They don’t all have to be declared, only the ones you want to use. For an example, here is our code for <code>Array.prototype.shift</code>:<pre class=language-torque><code class=language-torque>  <span class="token comment">// https://tc39.es/ecma262/#sec-array.prototype.shift</span><br>  transitioning <span class="token keyword">javascript</span> <span class="token keyword">builtin</span> ArrayPrototypeShift<span class="token punctuation">(</span><br>      js<span class="token operator">-</span><span class="token keyword">implicit</span> context<span class="token class-name">: NativeContext,</span> receiver<span class="token class-name">: JSAny)</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>arguments<span class="token punctuation">)</span><span class="token class-name">: JSAny {</span><br>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>Note that the <code>context</code> argument is a <code>NativeContext</code>. This is because builtins in V8 always embed the native context in their closures. Encoding this in the js-implicit convention allows the programmer to eliminate an operation to load the native context from the function context.<h3 id=overload-resolution>Overload resolution <a href=#overload-resolution class=bookmark>#</a></h3><p>Torque <code>macro</code>s and operators (which are just aliases for <code>macro</code>s) allow for argument-type overloading. The overloading rules are inspired by the ones of C++: an overload is selected if it is strictly better than all alternatives. This means that it has to be strictly better in at least one parameter, and better or equally good in all others.<p>When comparing a pair of corresponding parameters of two overloads…<ul><li>…they are considered equally good if:<ul><li>they are equal;<li>both require some implicit conversion.</ul><li>…one is considered better if:<ul><li>it is a strict subtype of the other;<li>it doesn’t require an implicit conversion, while the other does.</ul></ul><p>If no overload is strictly better than all alternatives, this results in a compile error.<h3 id=deferred-blocks>Deferred blocks <a href=#deferred-blocks class=bookmark>#</a></h3><p>A statement block can optionally be marked as <code>deferred</code>, which is a signal to the compiler that it's entered less often. The compiler may choose to locate these blocks at the end of the function, thus improving cache locality for the non-deferred regions of code. For example, in this code from the <code>Array.prototype.forEach</code> implementation, we expect to remain on the "fast" path, and only rarely take the bailout case:<pre class=language-torque><code class=language-torque>  <span class="token keyword">let</span> k<span class="token class-name">: Number =</span> <span class="token number">0</span><span class="token punctuation">;</span><br>  <span class="token keyword">try</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> FastArrayForEach<span class="token punctuation">(</span>o<span class="token punctuation">,</span> len<span class="token punctuation">,</span> callbackfn<span class="token punctuation">,</span> thisArg<span class="token punctuation">)</span><br>        <span class="token keyword">otherwise</span> Bailout<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">label</span> Bailout<span class="token punctuation">(</span>kValue<span class="token class-name">: Smi)</span> deferred <span class="token punctuation">{</span><br>    k <span class="token operator">=</span> kValue<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span></code></pre><p>Here is another example, where the dictionary elements case is marked as deferred to improve code generation for the more likely cases (from the <code>Array.prototype.join</code> implementation):<pre class=language-torque><code class=language-torque>  <span class="token keyword">if</span> <span class="token punctuation">(</span>IsElementsKindLessThanOrEqual<span class="token punctuation">(</span>kind<span class="token punctuation">,</span> HOLEY_ELEMENTS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    loadFn <span class="token operator">=</span> LoadJoinElement<span class="token operator">&lt;</span>FastSmiOrObjectElements<span class="token operator">></span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>IsElementsKindLessThanOrEqual<span class="token punctuation">(</span>kind<span class="token punctuation">,</span> HOLEY_DOUBLE_ELEMENTS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    loadFn <span class="token operator">=</span> LoadJoinElement<span class="token operator">&lt;</span>FastDoubleElements<span class="token operator">></span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>kind <span class="token operator">==</span> DICTIONARY_ELEMENTS<span class="token punctuation">)</span><br>    deferred <span class="token punctuation">{</span><br>      <span class="token keyword">const</span> dict<span class="token class-name">: NumberDictionary =</span><br>          <span class="token builtin">UnsafeCast</span><span class="token operator">&lt;</span>NumberDictionary<span class="token operator">></span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token keyword">const</span> nofElements<span class="token class-name">: Smi =</span> GetNumberDictionaryNumberOfElements<span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token comment">// &lt;etc>...</span></code></pre><h2 id=porting-csa-code-to-torque>Porting CSA code to Torque <a href=#porting-csa-code-to-torque class=bookmark>#</a></h2><p><a href=https://chromium-review.googlesource.com/c/v8/v8/+/1296464>The patch that ported <code>Array.of</code></a> serves as a minimal example of porting CSA code to Torque.</main><footer id=footer><div><nav><a href=https://v8.dev/docs/torque>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/docs/torque.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>